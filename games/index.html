<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trick Escalation Engine</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --hearts: #e63946;
  --hearts-glow: #ff6b7a;
  --diamonds: #f4a300;
  --diamonds-glow: #ffd166;
  --clubs: #2a9d8f;
  --clubs-glow: #5eead4;
  --spades: #6c5ce7;
  --spades-glow: #a78bfa;
  --bg-deep: #0a0a12;
  --bg-mid: #12121e;
  --bg-card: #1a1a2e;
  --bg-surface: #16213e;
  --text-primary: #e8e8f0;
  --text-secondary: #8888aa;
  --text-dim: #555577;
  --gold: #d4a843;
  --gold-glow: #f0d078;
  --accent: #c9a84c;
  --danger: #e63946;
  --success: #2a9d8f;
  --crown-row: #d4a843;
  --heart-row: #e63946;
  --foundation-row: #2a9d8f;
}

html, body {
  width: 100%; height: 100%;
  background: var(--bg-deep);
  color: var(--text-primary);
  font-family: 'Crimson Text', Georgia, serif;
  overflow: hidden;
}

/* ===== SCREEN SYSTEM ===== */
.screen { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
.screen.active { display: flex; }

/* ===== TITLE SCREEN ===== */
#title-screen {
  flex-direction: column; align-items: center; justify-content: center;
  background: radial-gradient(ellipse at 50% 40%, #1a1a3a 0%, #0a0a12 70%);
  gap: 30px;
}

.title-ornament {
  width: 200px; height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  position: relative;
}
.title-ornament::after {
  content: '‚óÜ'; position: absolute; left: 50%; top: 50%;
  transform: translate(-50%, -50%);
  color: var(--gold); font-size: 14px;
}

.game-title {
  font-family: 'Cinzel', serif; font-weight: 900;
  font-size: clamp(28px, 5vw, 56px);
  text-align: center;
  background: linear-gradient(180deg, #f0d078 0%, #d4a843 40%, #a07830 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  text-shadow: none; letter-spacing: 4px;
  line-height: 1.2;
}
.game-subtitle {
  font-family: 'Crimson Text', serif; font-style: italic;
  color: var(--text-secondary); font-size: clamp(14px, 2vw, 20px);
  text-align: center;
}

.class-select {
  display: flex; gap: 20px; margin-top: 10px; flex-wrap: wrap; justify-content: center;
}
.class-card {
  width: 220px; padding: 24px 20px;
  background: var(--bg-card);
  border: 1px solid #333355;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: center;
}
.class-card:hover {
  border-color: var(--gold);
  box-shadow: 0 0 30px rgba(212,168,67,0.15);
  transform: translateY(-4px);
}
.class-card.selected {
  border-color: var(--gold);
  background: linear-gradient(180deg, #1a1a2e, #1f1a30);
  box-shadow: 0 0 40px rgba(212,168,67,0.2);
}
.class-card h3 {
  font-family: 'Cinzel', serif; font-size: 16px; color: var(--gold);
  margin-bottom: 8px;
}
.class-card p {
  font-size: 13px; color: var(--text-secondary); line-height: 1.4;
}

.btn {
  font-family: 'Cinzel', serif; font-weight: 700;
  padding: 14px 40px; font-size: 16px;
  background: linear-gradient(180deg, #d4a843, #a07830);
  color: #0a0a12; border: none; border-radius: 8px;
  cursor: pointer; letter-spacing: 2px;
  transition: all 0.3s ease;
  text-transform: uppercase;
}
.btn:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(212,168,67,0.4); }
.btn:disabled { opacity: 0.4; cursor: default; transform: none; box-shadow: none; }

/* ===== MAP SCREEN ===== */
#map-screen {
  flex-direction: column; align-items: center;
  background: radial-gradient(ellipse at 50% 30%, #141428 0%, #0a0a12 70%);
  padding: 20px; overflow-y: auto;
}
.map-header {
  font-family: 'Cinzel', serif; font-size: 22px; color: var(--gold);
  margin-bottom: 4px;
}
.map-subheader { color: var(--text-secondary); font-size: 14px; margin-bottom: 16px; }
.map-stats {
  display: flex; gap: 24px; margin-bottom: 20px; font-size: 14px;
}
.map-stats span { color: var(--text-secondary); }
.map-stats .val { color: var(--gold); font-weight: 700; }

.map-container {
  display: flex; flex-direction: column; align-items: center; gap: 12px;
  padding: 20px;
}
.map-row {
  display: flex; gap: 16px; justify-content: center;
}
.map-node {
  width: 56px; height: 56px;
  border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 22px;
  border: 2px solid #333355;
  background: var(--bg-card);
  cursor: default;
  transition: all 0.3s ease;
  position: relative;
}
.map-node.available {
  cursor: pointer;
  border-color: var(--gold);
  animation: nodePulse 2s ease-in-out infinite;
}
.map-node.available:hover {
  transform: scale(1.15);
  box-shadow: 0 0 25px rgba(212,168,67,0.4);
}
.map-node.completed {
  opacity: 0.4;
  border-color: var(--text-dim);
}
.map-node.current {
  border-color: var(--gold-glow);
  box-shadow: 0 0 20px rgba(212,168,67,0.3);
}
.map-node.boss {
  width: 64px; height: 64px; font-size: 26px;
  border-color: var(--danger);
}
.map-node.boss.available { border-color: var(--danger); animation: bossNodePulse 2s ease-in-out infinite; }

@keyframes nodePulse {
  0%,100% { box-shadow: 0 0 8px rgba(212,168,67,0.2); }
  50% { box-shadow: 0 0 20px rgba(212,168,67,0.4); }
}
@keyframes bossNodePulse {
  0%,100% { box-shadow: 0 0 8px rgba(230,57,70,0.3); }
  50% { box-shadow: 0 0 25px rgba(230,57,70,0.6); }
}

.node-tooltip {
  position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%);
  font-size: 11px; color: var(--text-secondary); white-space: nowrap;
  font-family: 'Cinzel', serif; opacity: 0;
  transition: opacity 0.2s;
}
.map-node:hover .node-tooltip { opacity: 1; }

/* ===== BATTLE SCREEN ===== */
#battle-screen {
  flex-direction: column;
  background: var(--bg-deep);
  position: relative;
}

.battle-top-bar {
  display: flex; justify-content: space-between; align-items: center;
  padding: 8px 16px;
  background: rgba(0,0,0,0.4);
  border-bottom: 1px solid #222244;
  font-size: 13px; min-height: 44px;
}
.battle-top-bar .info-left { display: flex; gap: 16px; align-items: center; }
.battle-top-bar .info-right { display: flex; gap: 16px; align-items: center; }
.stat-badge {
  display: flex; align-items: center; gap: 4px;
  font-family: 'JetBrains Mono', monospace; font-size: 12px;
}
.stat-badge .label { color: var(--text-dim); }
.stat-badge .val { color: var(--gold); font-weight: 700; }
.hp-val { color: var(--hearts) !important; }
.ink-val { color: var(--diamonds) !important; }

/* Enemy Area */
.enemy-area {
  display: flex; flex-direction: column; align-items: center;
  padding: 12px 16px;
  min-height: 130px;
}
.enemy-name {
  font-family: 'Cinzel', serif; font-size: 18px; color: var(--danger);
  margin-bottom: 4px;
}
.enemy-intent {
  font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;
  font-style: italic;
}
.enemy-hp-bar {
  width: 240px; height: 14px;
  background: #1a1a2e; border-radius: 7px;
  overflow: hidden; border: 1px solid #333;
  margin-bottom: 10px;
}
.enemy-hp-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--danger), #ff8888);
  transition: width 0.5s ease;
  border-radius: 7px;
}
.enemy-hp-text {
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  color: var(--text-secondary); margin-bottom: 8px;
}

.enemy-card-slot {
  width: 80px; height: 110px;
  border: 2px dashed #333355;
  border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  color: var(--text-dim); font-size: 12px;
}
.enemy-card-slot.has-card {
  border: 2px solid;
  background: var(--bg-card);
}

/* Row Area */
.rows-area {
  display: flex; flex-direction: column; align-items: center;
  gap: 4px;
  padding: 8px 16px;
  flex: 1;
}
.row-lane {
  display: flex; align-items: center; gap: 10px;
  width: 100%; max-width: 600px;
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid transparent;
  transition: all 0.3s ease;
  min-height: 50px;
  cursor: default;
}
.row-lane.selectable {
  cursor: pointer;
  border: 1px dashed;
}
.row-lane.selectable:hover { background: rgba(255,255,255,0.03); }
.row-lane.selected { background: rgba(255,255,255,0.06); }

.row-lane.crown { border-color: rgba(212,168,67,0.3); }
.row-lane.crown.selectable { border-color: var(--crown-row); }
.row-lane.heart { border-color: rgba(230,57,70,0.3); }
.row-lane.heart.selectable { border-color: var(--heart-row); }
.row-lane.foundation { border-color: rgba(42,157,143,0.3); }
.row-lane.foundation.selectable { border-color: var(--foundation-row); }

.row-label {
  font-family: 'Cinzel', serif; font-size: 11px;
  width: 80px; text-align: right;
  letter-spacing: 1px; text-transform: uppercase;
}
.row-lane.crown .row-label { color: var(--crown-row); }
.row-lane.heart .row-label { color: var(--heart-row); }
.row-lane.foundation .row-label { color: var(--foundation-row); }

.row-cards {
  display: flex; gap: 4px; flex: 1; min-height: 40px; align-items: center;
}
.row-streak {
  font-family: 'JetBrains Mono', monospace; font-size: 10px;
  color: var(--text-dim); margin-left: auto;
}

.mini-card {
  width: 32px; height: 44px;
  border-radius: 4px;
  background: var(--bg-card);
  border: 1px solid #444;
  display: flex; align-items: center; justify-content: center;
  font-size: 11px; font-weight: 700;
  font-family: 'JetBrains Mono', monospace;
}

/* Trick Area */
.trick-area {
  display: flex; align-items: center; justify-content: center;
  gap: 40px; padding: 10px; min-height: 60px;
}
.trick-result {
  font-family: 'Cinzel', serif;
  font-size: 20px; font-weight: 700;
  opacity: 0; transition: opacity 0.4s;
}
.trick-result.visible { opacity: 1; }
.trick-result.win { color: var(--gold); }
.trick-result.lose { color: var(--danger); }

/* Score Display */
.score-display {
  text-align: center; padding: 4px;
  font-family: 'JetBrains Mono', monospace;
}
.score-number {
  font-size: 32px; font-weight: 700;
  color: var(--gold);
  transition: all 0.3s ease;
}
.score-number.exploding {
  animation: scoreExplode 0.6s ease-out;
}
@keyframes scoreExplode {
  0% { transform: scale(1); }
  30% { transform: scale(1.6); color: #fff; text-shadow: 0 0 30px var(--gold); }
  100% { transform: scale(1); }
}
.score-label { font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; }

/* Player Hand */
.hand-area {
  padding: 8px 16px 12px;
  background: linear-gradient(180deg, transparent, rgba(0,0,0,0.4));
  border-top: 1px solid #222244;
}
.hand-label {
  font-family: 'Cinzel', serif; font-size: 11px;
  color: var(--text-dim); text-align: center; margin-bottom: 6px;
  letter-spacing: 2px; text-transform: uppercase;
}
.hand-cards {
  display: flex; justify-content: center; gap: 6px;
  flex-wrap: wrap;
}

/* Cards */
.card {
  width: 72px; height: 100px;
  border-radius: 8px;
  background: var(--bg-card);
  border: 2px solid #333355;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  position: relative;
  user-select: none;
}
.card:hover {
  transform: translateY(-8px);
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
}
.card.selected {
  transform: translateY(-12px);
  border-color: var(--gold);
  box-shadow: 0 0 20px rgba(212,168,67,0.3);
}
.card.disabled { opacity: 0.4; cursor: default; pointer-events: none; }

.card-rank {
  font-family: 'Cinzel', serif; font-weight: 900;
  font-size: 22px; line-height: 1;
}
.card-suit { font-size: 20px; margin-top: 2px; }
.card-chips {
  font-family: 'JetBrains Mono', monospace;
  font-size: 9px; color: var(--text-dim);
  margin-top: 4px;
}

.card.hearts { border-color: rgba(230,57,70,0.4); }
.card.hearts .card-rank { color: var(--hearts); }
.card.diamonds { border-color: rgba(244,163,0,0.4); }
.card.diamonds .card-rank { color: var(--diamonds); }
.card.clubs { border-color: rgba(42,157,143,0.4); }
.card.clubs .card-rank { color: var(--clubs); }
.card.spades { border-color: rgba(108,92,231,0.4); }
.card.spades .card-rank { color: var(--spades); }

.card-keyword {
  position: absolute; top: 3px; right: 3px;
  font-size: 8px; background: rgba(0,0,0,0.5);
  padding: 1px 4px; border-radius: 3px;
  color: var(--gold); font-family: 'JetBrains Mono', monospace;
}

/* Escalation Matrix Panel */
.matrix-panel {
  position: absolute; right: 0; top: 44px; bottom: 0;
  width: 220px;
  background: rgba(10,10,18,0.95);
  border-left: 1px solid #222244;
  padding: 12px;
  overflow-y: auto;
  z-index: 10;
  transform: translateX(100%);
  transition: transform 0.3s ease;
}
.matrix-panel.open { transform: translateX(0); }

.matrix-toggle {
  position: absolute; right: 16px; top: 50px;
  width: 36px; height: 36px;
  background: var(--bg-card); border: 1px solid #333355;
  border-radius: 50%;
  color: var(--gold); font-size: 16px;
  cursor: pointer; z-index: 11;
  display: flex; align-items: center; justify-content: center;
  transition: all 0.3s;
}
.matrix-toggle:hover { border-color: var(--gold); }
.matrix-panel.open ~ .matrix-toggle { right: 226px; }

.matrix-title {
  font-family: 'Cinzel', serif; font-size: 13px;
  color: var(--gold); text-align: center; margin-bottom: 10px;
  letter-spacing: 2px; text-transform: uppercase;
}
.mod-item {
  padding: 6px 8px; margin-bottom: 4px;
  background: rgba(255,255,255,0.03);
  border-radius: 6px; border-left: 3px solid;
  font-size: 11px; line-height: 1.3;
}
.mod-item .mod-name { font-weight: 600; color: var(--text-primary); }
.mod-item .mod-val {
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px; color: var(--gold);
}
.mod-item .mod-tier {
  font-size: 9px; color: var(--text-dim);
  text-transform: uppercase; letter-spacing: 1px;
}
.mod-item.spark { border-color: #ff9f43; }
.mod-item.flame { border-color: #e63946; }
.mod-item.inferno { border-color: #6c5ce7; }

/* Score Preview */
.score-preview {
  text-align: center; font-size: 12px;
  color: var(--text-secondary); padding: 2px 0;
  min-height: 18px;
  font-family: 'JetBrains Mono', monospace;
}
.score-preview .preview-val {
  color: var(--gold); font-weight: 700;
}

/* Action Buttons */
.action-bar {
  display: flex; justify-content: center; gap: 10px;
  padding: 6px;
}
.btn-small {
  font-family: 'Cinzel', serif;
  padding: 8px 20px; font-size: 12px;
  background: var(--bg-surface);
  color: var(--text-primary);
  border: 1px solid #444466;
  border-radius: 6px;
  cursor: pointer; transition: all 0.2s;
  letter-spacing: 1px;
}
.btn-small:hover { border-color: var(--gold); color: var(--gold); }
.btn-small.primary {
  background: linear-gradient(180deg, #d4a843, #a07830);
  color: #0a0a12; border: none; font-weight: 700;
}
.btn-small:disabled { opacity: 0.3; cursor: default; }

/* ===== REWARD SCREEN ===== */
#reward-screen {
  flex-direction: column; align-items: center; justify-content: center;
  background: radial-gradient(ellipse at 50% 40%, #1a1a3a 0%, #0a0a12 70%);
  gap: 20px; padding: 20px;
}
.reward-title {
  font-family: 'Cinzel', serif; font-size: 24px; color: var(--gold);
}
.reward-subtitle { color: var(--text-secondary); font-size: 14px; }
.reward-cards {
  display: flex; gap: 16px; flex-wrap: wrap; justify-content: center;
}
.reward-card-option {
  width: 100px; height: 140px;
  border-radius: 10px; background: var(--bg-card);
  border: 2px solid #333355;
  cursor: pointer; transition: all 0.3s;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 8px;
}
.reward-card-option:hover {
  border-color: var(--gold);
  transform: translateY(-6px);
  box-shadow: 0 8px 25px rgba(212,168,67,0.2);
}
.reward-card-option .card-rank { font-size: 26px; }
.reward-card-option .card-suit { font-size: 24px; }
.reward-card-option .card-name {
  font-size: 10px; color: var(--text-secondary);
  margin-top: 6px; text-align: center;
}

/* ===== EVENT SCREEN ===== */
#event-screen {
  flex-direction: column; align-items: center; justify-content: center;
  background: radial-gradient(ellipse at 50% 40%, #1a1a3a 0%, #0a0a12 70%);
  gap: 16px; padding: 20px;
}
.event-title {
  font-family: 'Cinzel', serif; font-size: 22px; color: var(--gold);
}
.event-text {
  max-width: 500px; text-align: center;
  font-style: italic; color: var(--text-secondary);
  line-height: 1.6; font-size: 15px;
}
.event-choices { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 400px; }
.event-choice {
  padding: 14px 18px;
  background: var(--bg-card); border: 1px solid #333355;
  border-radius: 8px; cursor: pointer;
  transition: all 0.2s; text-align: left;
}
.event-choice:hover { border-color: var(--gold); background: #1f1f35; }
.event-choice .choice-label { font-weight: 600; color: var(--text-primary); font-size: 14px; }
.event-choice .choice-desc { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }

/* ===== REST SCREEN ===== */
#rest-screen {
  flex-direction: column; align-items: center; justify-content: center;
  background: radial-gradient(ellipse at 50% 40%, #1a1a3a 0%, #0a0a12 70%);
  gap: 20px;
}

/* ===== GAME OVER ===== */
#gameover-screen {
  flex-direction: column; align-items: center; justify-content: center;
  background: radial-gradient(ellipse at 50% 40%, #1a0a0a 0%, #0a0a12 70%);
  gap: 16px;
}
.gameover-title {
  font-family: 'Cinzel', serif; font-size: 36px;
}
.gameover-title.victory { color: var(--gold); }
.gameover-title.defeat { color: var(--danger); }
.gameover-stats { color: var(--text-secondary); font-size: 14px; text-align: center; line-height: 1.8; }

/* ===== FLOATING SCORE POPUPS ===== */
.score-popup {
  position: fixed;
  font-family: 'Cinzel', serif; font-weight: 900;
  pointer-events: none; z-index: 100;
  animation: popUp 1.2s ease-out forwards;
}
@keyframes popUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  50% { opacity: 1; transform: translateY(-40px) scale(1.3); }
  100% { opacity: 0; transform: translateY(-80px) scale(0.8); }
}

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #333355; border-radius: 3px; }

/* Responsive */
@media (max-width: 640px) {
  .card { width: 58px; height: 82px; }
  .card-rank { font-size: 18px; }
  .card-suit { font-size: 16px; }
  .matrix-panel { width: 180px; }
  .enemy-card-slot { width: 64px; height: 88px; }
}
</style>
</head>
<body>

<!-- ===== TITLE SCREEN ===== -->
<div id="title-screen" class="screen active">
  <div class="title-ornament"></div>
  <h1 class="game-title">Trick Escalation<br>Engine</h1>
  <p class="game-subtitle">Every trick won reshapes the next. Every hand played rewrites the rules.</p>
  <div class="title-ornament"></div>

  <p style="color: var(--text-secondary); font-size: 14px; margin-top: 10px;">Choose your class:</p>
  <div class="class-select">
    <div class="class-card selected" data-class="ember">
      <h3>The Ember Dealer</h3>
      <p>Hearts &amp; Diamonds focus. First trick each round grants a bonus modifier. Balanced &amp; forgiving.</p>
    </div>
    <div class="class-card" data-class="chrome">
      <h3>The Chrome Tactician</h3>
      <p>Spades &amp; Clubs focus. Losing tricks powers up your next play. Strategic &amp; calculated.</p>
    </div>
  </div>
  <button class="btn" onclick="startGame()">Begin Run</button>
</div>

<!-- ===== MAP SCREEN ===== -->
<div id="map-screen" class="screen">
  <h2 class="map-header" id="map-act-title">Act 1 ‚Äî The Outskirts</h2>
  <p class="map-subheader">Choose your path</p>
  <div class="map-stats">
    <span>HP: <span class="val hp-val" id="map-hp">100</span></span>
    <span>Ink: <span class="val ink-val" id="map-ink">0</span></span>
    <span>Deck: <span class="val" id="map-deck">20</span></span>
    <span>Modifiers: <span class="val" id="map-mods">0</span></span>
  </div>
  <div class="map-container" id="map-container"></div>
</div>

<!-- ===== BATTLE SCREEN ===== -->
<div id="battle-screen" class="screen">
  <div class="battle-top-bar">
    <div class="info-left">
      <div class="stat-badge"><span class="label">HP</span><span class="val hp-val" id="battle-hp">100</span></div>
      <div class="stat-badge"><span class="label">Ink</span><span class="val ink-val" id="battle-ink">0</span></div>
      <div class="stat-badge"><span class="label">Round</span><span class="val" id="battle-round">1</span></div>
      <div class="stat-badge"><span class="label">Trick</span><span class="val" id="battle-trick">0/3</span></div>
    </div>
    <div class="info-right">
      <div class="stat-badge"><span class="label">Act</span><span class="val" id="battle-act">1</span></div>
    </div>
  </div>

  <!-- Enemy -->
  <div class="enemy-area">
    <div class="enemy-name" id="enemy-name">Ink Imp</div>
    <div class="enemy-intent" id="enemy-intent">Intent: Attack</div>
    <div class="enemy-hp-bar"><div class="enemy-hp-fill" id="enemy-hp-fill" style="width:100%"></div></div>
    <div class="enemy-hp-text" id="enemy-hp-text">50 / 50</div>
    <div class="enemy-card-slot" id="enemy-card-slot">Waiting...</div>
  </div>

  <!-- Trick Result -->
  <div class="trick-area">
    <div class="score-display">
      <div class="score-label">Round Score</div>
      <div class="score-number" id="round-score">0</div>
    </div>
    <div class="trick-result" id="trick-result"></div>
  </div>

  <!-- Rows -->
  <div class="rows-area" id="rows-area">
    <div class="row-lane crown" data-row="crown">
      <div class="row-label">Crown<br>√óMult</div>
      <div class="row-cards" id="crown-row-cards"></div>
      <div class="row-streak" id="crown-streak"></div>
    </div>
    <div class="row-lane heart" data-row="heart">
      <div class="row-label">Heart<br>+Chips</div>
      <div class="row-cards" id="heart-row-cards"></div>
      <div class="row-streak" id="heart-streak"></div>
    </div>
    <div class="row-lane foundation" data-row="foundation">
      <div class="row-label">Shield<br>Defend</div>
      <div class="row-cards" id="foundation-row-cards"></div>
      <div class="row-streak" id="foundation-streak"></div>
    </div>
  </div>

  <!-- Action Bar -->
  <div class="score-preview" id="score-preview"></div>
  <div class="action-bar" id="action-bar">
    <button class="btn-small" onclick="toggleMatrix()" title="View Escalation Matrix (M)">‚ú¶ Matrix</button>
    <button class="btn-small primary" id="btn-play" onclick="playCard()" disabled>Play Card</button>
    <button class="btn-small" onclick="showHelp()" title="How to play">? Help</button>
  </div>

  <!-- Hand -->
  <div class="hand-area">
    <div class="hand-label">Your Hand</div>
    <div class="hand-cards" id="hand-cards"></div>
  </div>

  <!-- Escalation Matrix -->
  <button class="matrix-toggle" id="matrix-toggle" onclick="toggleMatrix()">‚ú¶</button>
  <div class="matrix-panel" id="matrix-panel">
    <div class="matrix-title">Escalation Matrix</div>
    <div id="matrix-list"></div>
  </div>
</div>

<!-- ===== REWARD SCREEN ===== -->
<div id="reward-screen" class="screen">
  <h2 class="reward-title">Victory!</h2>
  <p class="reward-subtitle" id="reward-ink">+30 Ink</p>
  <p style="color: var(--text-secondary); font-size: 14px;">Choose a card to add to your deck:</p>
  <div class="reward-cards" id="reward-cards"></div>
  <button class="btn-small" onclick="skipReward()">Skip</button>
</div>

<!-- ===== EVENT SCREEN ===== -->
<div id="event-screen" class="screen">
  <h2 class="event-title" id="event-title">???</h2>
  <p class="event-text" id="event-text"></p>
  <div class="event-choices" id="event-choices"></div>
</div>

<!-- ===== REST SCREEN ===== -->
<div id="rest-screen" class="screen">
  <h2 class="event-title">üî• Rest Site</h2>
  <p class="event-text">The warmth of a fire. A moment of respite.</p>
  <div class="event-choices" id="rest-choices"></div>
</div>

<!-- ===== HELP OVERLAY ===== -->
<div id="help-overlay" onclick="if(event.target===this)this.style.display='none'" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:200;display:none;align-items:center;justify-content:center;padding:20px;">
  <div style="background:var(--bg-card);border:1px solid #333355;border-radius:12px;max-width:480px;padding:28px;max-height:80vh;overflow-y:auto;">
    <h2 style="font-family:'Cinzel',serif;color:var(--gold);font-size:20px;margin-bottom:12px;">How to Play</h2>
    <div style="font-size:13px;color:var(--text-secondary);line-height:1.7;">
      <p><strong style="color:var(--text-primary)">Trick-Taking:</strong> The enemy leads a card. You respond. If you follow suit (play the same suit) and your rank is higher, you win the trick and deal damage!</p>
      <p style="margin-top:8px"><strong style="color:var(--text-primary)">Off-Suit:</strong> Playing a different suit means you lose the trick ‚Äî but you still place it in a row for strategic reasons.</p>
      <p style="margin-top:8px"><strong style="color:var(--text-primary)">Rows:</strong> Choose which row to play your card into:</p>
      <ul style="margin:4px 0 4px 16px;list-style:disc;">
        <li><span style="color:var(--crown-row)">Crown Row</span> ‚Äî √ó1.5 to multiplier modifiers (high risk, high reward)</li>
        <li><span style="color:var(--heart-row)">Heart Row</span> ‚Äî √ó1.5 to chip modifiers (consistent damage)</li>
        <li><span style="color:var(--foundation-row)">Foundation Row</span> ‚Äî Grants shield when you lose tricks (defense)</li>
      </ul>
      <p style="margin-top:8px"><strong style="color:var(--text-primary)">Escalation:</strong> Each trick won adds a modifier to your Escalation Matrix. Modifiers stack ‚Äî the more you win, the more damage each trick does!</p>
      <p style="margin-top:8px"><strong style="color:var(--text-primary)">Row Streaks:</strong> Playing multiple cards to the same row builds streak bonuses (√ó2 = +10%, √ó3 = +25%, √ó4+ = +50%).</p>
      <p style="margin-top:8px"><strong style="color:var(--text-primary)">Controls:</strong> Click a card, click a row, then hit Play. Keys: 1/2/3 for rows, Enter to play, M for matrix.</p>
    </div>
    <button class="btn-small" style="margin-top:16px;width:100%" onclick="document.getElementById('help-overlay').style.display='none'">Got it!</button>
  </div>
</div>

<!-- ===== GAME OVER ===== -->
<div id="gameover-screen" class="screen">
  <h2 class="gameover-title" id="gameover-title">Defeat</h2>
  <div class="gameover-stats" id="gameover-stats"></div>
  <button class="btn" onclick="location.reload()">Try Again</button>
</div>

<script>
// ============================================================
// TRICK ESCALATION ENGINE ‚Äî GAME LOGIC
// ============================================================

const SUITS = ['hearts','diamonds','clubs','spades'];
const SUIT_SYMBOLS = { hearts:'‚ô•', diamonds:'‚ô¶', clubs:'‚ô£', spades:'‚ô†' };
const SUIT_COLORS = { hearts:'var(--hearts)', diamonds:'var(--diamonds)', clubs:'var(--clubs)', spades:'var(--spades)' };
const RANK_NAMES = {2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K',14:'A'};
const CARD_NAMES_PREFIX = {
  hearts: ['Ember','Crimson','Blood','Flame','Rose','Scarlet','Ruby','Blaze','Burning','Pyre','Infernal','Heart','Ardent'],
  diamonds: ['Golden','Crystal','Gilded','Prism','Shining','Brilliant','Jeweled','Radiant','Lustrous','Gleaming','Opulent','Amber','Auric'],
  clubs: ['Iron','Steel','Chrome','Titanium','Bronze','Forged','Tempered','Granite','Obsidian','Onyx','Adamant','Cobalt','Zinc'],
  spades: ['Void','Shadow','Phantom','Spectral','Ethereal','Twilight','Arcane','Mystic','Nebula','Astral','Cosmic','Umbral','Cipher']
};
const KEYWORDS = ['Swift','Echo','Phantom','Crown','Bloom','Anchor','Volatile','Absorb','Linked','Fracture'];

// ====== GAME STATE ======
let G = {};

function initState(playerClass) {
  G = {
    playerClass,
    hp: playerClass === 'ember' ? 100 : 90,
    maxHp: playerClass === 'ember' ? 100 : 90,
    ink: 0,
    deck: [],
    hand: [],
    burnPile: [],
    modifiers: [],
    relics: [],
    act: 1,
    mapNodes: [],
    currentNode: -1,
    totalDamage: 0,
    tricksWon: 0,
    tricksLost: 0,
    encountersWon: 0,
    roundScore: 0,
    rowStreaks: { crown: 0, heart: 0, foundation: 0 },
    selectedCard: null,
    selectedRow: null,
    // encounter state
    enemy: null,
    roundNum: 0,
    trickNum: 0,
    tricksPerRound: 3,
    enemyCard: null,
    phase: 'idle', // idle, enemy_led, player_choose, resolving, round_end, encounter_end
    consecutiveWins: 0,
    shield: 0,
  };

  // Starting modifiers by class
  if (playerClass === 'ember') {
    G.modifiers.push({ name: 'Hearts Spark', suit: 'hearts', type: 'mult', value: 0.1, tier: 'spark', persistent: false });
  } else {
    G.modifiers.push({ name: 'Clubs Spark', suit: 'clubs', type: 'mult', value: 0.1, tier: 'spark', persistent: false });
  }

  buildStartingDeck();
}

function buildStartingDeck() {
  G.deck = [];
  const bias = G.playerClass === 'ember' ? ['hearts','diamonds','hearts','diamonds','clubs','spades']
    : ['spades','clubs','spades','clubs','hearts','diamonds'];

  for (let i = 0; i < 20; i++) {
    const suit = bias[i % bias.length];
    const rank = 2 + (i % 13);
    G.deck.push(makeCard(suit, Math.min(rank, 14)));
  }
  shuffleArray(G.deck);
}

function makeCard(suit, rank, rarity) {
  rarity = rarity || (Math.random() < 0.6 ? 'common' : Math.random() < 0.8 ? 'uncommon' : 'rare');
  const rarityBonus = { common: 0, uncommon: 2, rare: 4, epic: 8, legendary: 15 };
  const rarityMult = { common: 1.0, uncommon: 1.1, rare: 1.3, epic: 1.5, legendary: 2.0 };
  const prefixes = CARD_NAMES_PREFIX[suit];
  const name = prefixes[Math.floor(Math.random() * prefixes.length)] + ' ' + RANK_NAMES[rank];
  let keywords = [];
  if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
    keywords.push(KEYWORDS[Math.floor(Math.random() * KEYWORDS.length)]);
  }
  return {
    id: Math.random().toString(36).substr(2, 8),
    suit, rank, name, rarity,
    baseChips: rank + (rarityBonus[rarity] || 0),
    baseMult: rarityMult[rarity] || 1.0,
    keywords,
  };
}

function shuffleArray(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
}

// ====== SCREENS ======
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

// ====== TITLE ======
document.querySelectorAll('.class-card').forEach(c => {
  c.addEventListener('click', () => {
    document.querySelectorAll('.class-card').forEach(x => x.classList.remove('selected'));
    c.classList.add('selected');
  });
});

function startGame() {
  const cls = document.querySelector('.class-card.selected')?.dataset.class || 'ember';
  initState(cls);
  generateMap();
  showMap();
}

// ====== MAP ======
function generateMap() {
  const actNames = ['The Outskirts','The Contested Lands','The Monarch\'s Domain'];
  G.mapNodes = [];
  const nodeTypes = [
    { type: 'encounter', icon: '‚öîÔ∏è', label: 'Encounter', weight: 40 },
    { type: 'elite', icon: 'üíÄ', label: 'Elite', weight: 15 },
    { type: 'event', icon: '‚ùì', label: 'Event', weight: 15 },
    { type: 'rest', icon: 'üî•', label: 'Rest', weight: 10 },
    { type: 'shop', icon: 'üè™', label: 'Shop', weight: 10 },
    { type: 'treasure', icon: 'üíé', label: 'Treasure', weight: 5 },
    { type: 'shrine', icon: '‚ú®', label: 'Shrine', weight: 5 },
  ];

  const numNodes = 8 + Math.floor(Math.random() * 3);
  // Ensure first node is encounter
  G.mapNodes.push({ type: 'encounter', icon: '‚öîÔ∏è', label: 'Encounter', completed: false });

  for (let i = 1; i < numNodes; i++) {
    const roll = Math.random() * 100;
    let cumul = 0;
    let chosen = nodeTypes[0];
    for (const nt of nodeTypes) {
      cumul += nt.weight;
      if (roll < cumul) { chosen = nt; break; }
    }
    G.mapNodes.push({ type: chosen.type, icon: chosen.icon, label: chosen.label, completed: false });
  }
  // Boss at end
  G.mapNodes.push({ type: 'boss', icon: 'üëë', label: 'Boss', completed: false });
  G.currentNode = -1;
}

function showMap() {
  showScreen('map-screen');
  const actNames = ['Act 1 ‚Äî The Outskirts','Act 2 ‚Äî The Contested Lands','Act 3 ‚Äî The Monarch\'s Domain'];
  document.getElementById('map-act-title').textContent = actNames[G.act - 1] || 'Act ' + G.act;
  document.getElementById('map-hp').textContent = G.hp;
  document.getElementById('map-ink').textContent = G.ink;
  document.getElementById('map-deck').textContent = G.deck.length;
  document.getElementById('map-mods').textContent = G.modifiers.length;

  const container = document.getElementById('map-container');
  container.innerHTML = '';

  // Render nodes in rows of 3
  const nextIdx = G.currentNode + 1;
  for (let i = 0; i < G.mapNodes.length; i++) {
    const node = G.mapNodes[i];
    if (i % 3 === 0) {
      var rowDiv = document.createElement('div');
      rowDiv.className = 'map-row';
      container.appendChild(rowDiv);
    }
    const el = document.createElement('div');
    el.className = 'map-node';
    if (node.type === 'boss') el.classList.add('boss');
    if (node.completed) el.classList.add('completed');
    else if (i === nextIdx) el.classList.add('available');
    // allow clicking next available nodes (the next 1-2 nodes)
    if (!node.completed && i >= nextIdx && i <= nextIdx + 1 && i < G.mapNodes.length) {
      el.classList.add('available');
      el.addEventListener('click', () => enterNode(i));
    }
    el.innerHTML = `${node.icon}<span class="node-tooltip">${node.label}</span>`;
    rowDiv.appendChild(el);
  }
}

function enterNode(idx) {
  G.currentNode = idx;
  const node = G.mapNodes[idx];
  node.completed = true;

  switch (node.type) {
    case 'encounter': startEncounter(generateEnemy('standard')); break;
    case 'elite': startEncounter(generateEnemy('elite')); break;
    case 'boss': startEncounter(generateEnemy('boss')); break;
    case 'event': showEvent(); break;
    case 'rest': showRest(); break;
    case 'shop': showShop(); break;
    case 'treasure': showTreasure(); break;
    case 'shrine': showShrine(); break;
    default: showMap();
  }
}

// ====== ENEMIES ======
function generateEnemy(tier) {
  const actMult = G.act;
  const enemies = {
    standard: [
      { name: 'Ink Imp', hp: 30 + actMult * 15, passive: null },
      { name: 'Page Scratcher', hp: 35 + actMult * 15, passive: null },
      { name: 'Smudge Sprite', hp: 25 + actMult * 20, passive: 'Gains +1 rank per round' },
      { name: 'Blot Fiend', hp: 40 + actMult * 10, passive: null },
    ],
    elite: [
      { name: 'Eraser Wraith', hp: 80 + actMult * 30, passive: 'Disables your lowest modifier each round' },
      { name: 'Echo Shade', hp: 70 + actMult * 25, passive: 'Copies your last modifier at half strength' },
      { name: 'Page Golem', hp: 100 + actMult * 20, passive: 'Gains 5 armor each round' },
    ],
    boss: [
      { name: 'The Crimson Regent', hp: 150 + actMult * 60, passive: 'Heals 5% HP per trick won' },
      { name: 'The Golden Archon', hp: 140 + actMult * 50, passive: 'Diamonds cards have +3 rank' },
      { name: 'The Iron Marshal', hp: 180 + actMult * 40, passive: 'Gains 8 armor per round' },
      { name: 'The Void Librarian', hp: 130 + actMult * 55, passive: 'Rearranges modifier order each round' },
    ],
  };

  const pool = enemies[tier];
  const template = pool[Math.floor(Math.random() * pool.length)];

  // Build enemy hand
  const hand = [];
  const handSize = tier === 'boss' ? 10 : tier === 'elite' ? 8 : 6;
  const rankBonus = tier === 'boss' ? 3 : tier === 'elite' ? 1 : 0;
  for (let i = 0; i < handSize; i++) {
    const suit = SUITS[Math.floor(Math.random() * 4)];
    const rank = Math.min(14, Math.max(2, Math.floor(Math.random() * 13) + 2 + rankBonus));
    hand.push({ suit, rank, id: 'e' + Math.random().toString(36).substr(2, 6) });
  }
  hand.sort((a, b) => a.rank - b.rank); // weakest first for AI

  return {
    ...template,
    maxHp: template.hp,
    armor: 0,
    tier,
    hand,
    tricksPerRound: tier === 'boss' ? 5 : tier === 'elite' ? 4 : 3,
    intent: 'Attack',
  };
}

// ====== ENCOUNTER ======
function startEncounter(enemy) {
  G.enemy = enemy;
  G.roundNum = 0;
  G.trickNum = 0;
  G.roundScore = 0;
  G.consecutiveWins = 0;
  G.shield = 0;
  G.tricksPerRound = enemy.tricksPerRound;
  G.rowStreaks = { crown: 0, heart: 0, foundation: 0 };
  G.hand = [];
  G.burnPile = [];
  G.selectedCard = null;
  G.selectedRow = null;

  // Clear encounter-only (spark) modifiers unless persistent
  G.modifiers = G.modifiers.filter(m => m.tier !== 'spark' || m.persistent);

  showScreen('battle-screen');
  document.getElementById('matrix-panel').classList.remove('open');
  clearRows();
  startRound();
}

function startRound() {
  G.roundNum++;
  G.trickNum = 0;
  G.roundScore = 0;
  G.consecutiveWins = 0;

  // Draw hand ‚Äî reshuffle burn pile into deck if needed
  if (G.deck.length < 7) {
    G.deck.push(...G.burnPile);
    G.burnPile = [];
    shuffleArray(G.deck);
  }
  shuffleArray(G.deck);
  const drawCount = Math.min(7, G.deck.length);
  G.hand = G.deck.splice(0, drawCount);

  // Safety: if still no cards, generate emergency cards
  if (G.hand.length === 0) {
    for (let i = 0; i < 5; i++) {
      G.hand.push(makeCard(SUITS[Math.floor(Math.random()*4)], Math.floor(Math.random()*8)+2, 'common'));
    }
  }

  // Replenish enemy hand if needed
  while (G.enemy.hand.length < G.tricksPerRound) {
    const suit = SUITS[Math.floor(Math.random() * 4)];
    const rank = Math.min(14, Math.floor(Math.random() * 13) + 2 + (G.enemy.tier === 'boss' ? 3 : G.enemy.tier === 'elite' ? 1 : 0));
    G.enemy.hand.push({ suit, rank, id: 'e' + Math.random().toString(36).substr(2, 6) });
  }

  updateBattleUI();
  startTrick();
}

function startTrick() {
  G.trickNum++;
  G.selectedCard = null;
  G.selectedRow = null;
  G.enemyCard = null;
  G.phase = 'enemy_led';

  // Enemy leads
  const enemyIdx = Math.floor(Math.random() * G.enemy.hand.length);
  G.enemyCard = G.enemy.hand.splice(enemyIdx, 1)[0];

  updateBattleUI();
  G.phase = 'player_choose';
  enableRowSelection(true);
}

function selectCard(cardId) {
  if (G.phase !== 'player_choose') return;
  G.selectedCard = G.hand.find(c => c.id === cardId) || null;
  updateBattleUI();
}

function selectRow(row) {
  if (G.phase !== 'player_choose') return;
  G.selectedRow = row;
  updateBattleUI();
}

function playCard() {
  if (!G.selectedCard || !G.selectedRow || G.phase !== 'player_choose') return;
  G.phase = 'resolving';
  enableRowSelection(false);

  const pCard = G.selectedCard;
  const eCard = G.enemyCard;
  const row = G.selectedRow;

  // Remove from hand
  G.hand = G.hand.filter(c => c.id !== pCard.id);

  // Determine winner
  let playerWins = false;
  if (pCard.suit === eCard.suit) {
    playerWins = pCard.rank > eCard.rank;
  } else {
    playerWins = false; // off-suit = lose (no trump by default)
  }

  // Row streak
  G.rowStreaks[row]++;

  // Score the trick
  let trickScore = 0;
  if (playerWins) {
    trickScore = calculateScore(pCard, row);
    G.consecutiveWins++;
    G.tricksWon++;

    // Add spark modifier
    addSparkModifier(pCard.suit);

    // Class passive: Ember Dealer bonus
    if (G.playerClass === 'ember' && G.trickNum === 1) {
      G.modifiers.push({
        name: 'Warming Up',
        suit: pCard.suit, type: 'mult', value: 0.1,
        tier: 'spark', persistent: false
      });
    }

    // Enemy boss healing passive
    if (G.enemy.passive && G.enemy.passive.includes('Heals')) {
      G.enemy.hp = Math.min(G.enemy.maxHp, G.enemy.hp + Math.floor(G.enemy.maxHp * 0.03));
    }

    // Deal damage
    const finalDmg = Math.max(1, Math.floor(trickScore));
    const armorBlock = Math.min(finalDmg, G.enemy.armor);
    G.enemy.armor -= armorBlock;
    G.enemy.hp = Math.max(0, G.enemy.hp - (finalDmg - armorBlock));
    G.roundScore += finalDmg;
    G.totalDamage += finalDmg;

  } else {
    G.consecutiveWins = 0;
    G.tricksLost++;

    // Chrome Tactician passive
    if (G.playerClass === 'chrome') {
      G.modifiers.push({
        name: 'Calculated Risk',
        suit: null, type: 'mult', value: 0.5,
        tier: 'spark', persistent: false, duration: 1
      });
    }

    // Foundation row defense
    if (row === 'foundation') {
      G.shield += 3;
    }

    // Enemy damage on win
    let eDmg = Math.floor(eCard.rank * 0.8 * G.act);
    if (G.enemy.tier === 'boss') eDmg = Math.floor(eDmg * 1.5);
    eDmg = Math.max(0, eDmg - G.shield);
    G.shield = Math.max(0, G.shield - Math.floor(eCard.rank * 0.8 * G.act));
    G.hp = Math.max(0, G.hp - eDmg);
  }

  // Boss armor passive
  if (G.enemy.passive && G.enemy.passive.includes('armor') && G.trickNum === 1) {
    const armorGain = G.enemy.passive.includes('8') ? 8 : 5;
    G.enemy.armor += armorGain;
  }

  // Add to burn pile (loser's card)
  if (playerWins) {
    G.burnPile.push(eCard);
  } else {
    G.burnPile.push(pCard);
  }

  // Place mini card in row
  addMiniCard(row, pCard);

  // Show result
  showTrickResult(playerWins, trickScore, pCard);

  // Check enemy death
  setTimeout(() => {
    if (G.enemy.hp <= 0) {
      encounterVictory();
      return;
    }
    if (G.hp <= 0) {
      gameOver(false);
      return;
    }

    if (G.trickNum >= G.tricksPerRound) {
      // Round end
      G.phase = 'round_end';
      // Return hand to deck
      G.deck.push(...G.hand);
      G.hand = [];

      if (G.enemy.hp > 0) {
        setTimeout(() => startRound(), 600);
      }
    } else {
      G.phase = 'idle';
      setTimeout(() => startTrick(), 500);
    }
  }, 800);
}

function calculateScore(card, row) {
  // Chips
  let chips = card.baseChips;

  // Chip modifiers
  let chipMod = 0;
  G.modifiers.forEach(m => {
    if (m.type === 'chips' && (m.suit === card.suit || m.suit === null)) {
      chipMod += m.value;
    }
  });
  // Heart row bonus for chips
  if (row === 'heart') chipMod *= 1.5;

  chips += chipMod;

  // Multiplier
  let mult = card.baseMult;

  // Gather multiplier modifiers by tier
  let sparkMult = 0, flameMult = 0, infernoMult = 0;
  G.modifiers.forEach(m => {
    if (m.type !== 'mult') return;
    if (m.suit !== null && m.suit !== card.suit) return;
    if (m.tier === 'spark') sparkMult += m.value;
    else if (m.tier === 'flame') flameMult += m.value;
    else if (m.tier === 'inferno') infernoMult += m.value;
  });

  // Crown row bonus for multipliers
  const crownBonus = row === 'crown' ? 1.5 : 1.0;

  mult *= (1 + sparkMult * crownBonus) * (1 + flameMult * crownBonus) * (1 + infernoMult * crownBonus);

  // Row streak bonus
  const streak = G.rowStreaks[row] || 0;
  const streakBonus = streak >= 4 ? 1.5 : streak >= 3 ? 1.25 : streak >= 2 ? 1.1 : 1.0;
  mult *= streakBonus;

  // Combo multiplier (consecutive wins)
  mult *= (1 + 0.1 * G.consecutiveWins);

  // Keyword: Crown
  if (card.keywords.includes('Crown') && row === 'crown') mult *= 1.5;
  // Keyword: Volatile
  if (card.keywords.includes('Volatile')) {
    chips *= 2;
    // Card destroyed (removed from deck permanently)
    G.deck = G.deck.filter(c => c.id !== card.id);
  }
  // Keyword: Bloom
  if (card.keywords.includes('Bloom')) {
    const activeModCount = G.modifiers.length;
    chips += activeModCount;
  }

  return Math.max(1, Math.floor(chips * mult));
}

function addSparkModifier(suit) {
  // Check if this spark exists
  const existing = G.modifiers.find(m => m.tier === 'spark' && m.suit === suit && m.type === 'mult' && !m.persistent);
  if (existing) {
    // Stack with diminishing returns
    const stacks = G.modifiers.filter(m => m.tier === 'spark' && m.suit === suit && m.type === 'mult').length;
    existing.value += stacks >= 5 ? 0.05 : 0.1;
    existing.value = Math.min(existing.value, 2.0); // cap
  } else {
    G.modifiers.push({
      name: suit.charAt(0).toUpperCase() + suit.slice(1) + ' Spark',
      suit, type: 'mult', value: 0.1,
      tier: 'spark', persistent: false,
    });
  }
}

function showTrickResult(won, score, card) {
  const el = document.getElementById('trick-result');
  el.textContent = won ? `Won! +${score}` : 'Lost!';
  el.className = 'trick-result visible ' + (won ? 'win' : 'lose');

  if (won && score > 0) {
    const scoreEl = document.getElementById('round-score');
    scoreEl.classList.add('exploding');
    setTimeout(() => scoreEl.classList.remove('exploding'), 600);

    // Floating popup
    if (score >= 20) {
      spawnScorePopup(score);
    }
  }

  setTimeout(() => { el.classList.remove('visible'); }, 700);
  updateBattleUI();
}

function spawnScorePopup(score) {
  const popup = document.createElement('div');
  popup.className = 'score-popup';
  popup.textContent = '+' + score;
  popup.style.left = (40 + Math.random() * 20) + '%';
  popup.style.top = (30 + Math.random() * 20) + '%';
  popup.style.fontSize = Math.min(48, 20 + score / 5) + 'px';
  popup.style.color = score >= 100 ? '#ffd166' : score >= 50 ? '#f0d078' : 'var(--gold)';
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 1200);
}

function encounterVictory() {
  G.encountersWon++;
  const inkGain = G.enemy.tier === 'boss' ? 80 : G.enemy.tier === 'elite' ? 50 : 30;
  G.ink += inkGain;

  // Return hand to deck
  G.deck.push(...G.hand);
  G.hand = [];

  // Add flame modifier from elite/boss
  if (G.enemy.tier === 'elite' || G.enemy.tier === 'boss') {
    const suit = SUITS[Math.floor(Math.random() * 4)];
    G.modifiers.push({
      name: suit.charAt(0).toUpperCase() + suit.slice(1) + (G.enemy.tier === 'boss' ? ' Inferno' : ' Flame'),
      suit, type: 'mult', value: G.enemy.tier === 'boss' ? 0.3 : 0.2,
      tier: G.enemy.tier === 'boss' ? 'inferno' : 'flame', persistent: true
    });
  }

  if (G.enemy.tier === 'boss') {
    // Act completed
    G.act++;
    if (G.act > 3) {
      gameOver(true);
      return;
    }
    generateMap();
    showRewardScreen(inkGain, true);
  } else {
    showRewardScreen(inkGain, false);
  }
}

function showRewardScreen(inkGain, isBoss) {
  showScreen('reward-screen');
  document.getElementById('reward-ink').textContent = '+' + inkGain + ' Ink' + (isBoss ? '  ‚Ä¢  Act Complete!' : '');
  const container = document.getElementById('reward-cards');
  container.innerHTML = '';

  // Generate 3 reward cards
  const tier = G.enemy?.tier || 'standard';
  for (let i = 0; i < 3; i++) {
    const suit = SUITS[Math.floor(Math.random() * 4)];
    const rank = Math.min(14, Math.floor(Math.random() * 13) + 2 + (tier === 'boss' ? 3 : tier === 'elite' ? 2 : 0));
    const rarity = tier === 'boss' ? 'rare' : tier === 'elite' ? (Math.random() < 0.5 ? 'uncommon' : 'rare') : (Math.random() < 0.7 ? 'common' : 'uncommon');
    const card = makeCard(suit, rank, rarity);

    const el = document.createElement('div');
    el.className = 'reward-card-option';
    el.innerHTML = `
      <div class="card-rank" style="color:${SUIT_COLORS[suit]}">${RANK_NAMES[rank]}</div>
      <div class="card-suit">${SUIT_SYMBOLS[suit]}</div>
      <div class="card-name">${card.name}</div>
      <div style="font-size:9px;color:var(--text-dim);margin-top:2px">${card.baseChips}‚ô¶ ${card.baseMult}√ó</div>
      ${card.keywords.length ? '<div style="font-size:8px;color:var(--gold);margin-top:2px">'+card.keywords.join(', ')+'</div>' : ''}
    `;
    el.addEventListener('click', () => {
      G.deck.push(card);
      showMap();
    });
    container.appendChild(el);
  }
}

function skipReward() { showMap(); }

// ====== EVENTS ======
const EVENTS = [
  {
    title: 'The Ink Well',
    text: 'You find a bubbling well of pure Ink. Its depths seem bottomless.',
    choices: [
      { label: 'Drink Deep', desc: '+80 Ink, but add 3 random common cards to deck', fn: () => { G.ink += 80; for(let i=0;i<3;i++) G.deck.push(makeCard(SUITS[Math.floor(Math.random()*4)], Math.floor(Math.random()*8)+2, 'common')); }},
      { label: 'Bottle It', desc: '+35 Ink', fn: () => { G.ink += 35; }},
      { label: 'Drown a Card', desc: 'Remove a random card from your deck', fn: () => { if(G.deck.length>15) G.deck.splice(Math.floor(Math.random()*G.deck.length),1); }},
    ]
  },
  {
    title: 'The Modifier Merchant',
    text: 'A cloaked figure offers you a glowing sigil. "Trade me something precious," they whisper.',
    choices: [
      { label: 'Trade HP', desc: 'Lose 15 max HP. Gain a Flame modifier.', fn: () => { G.maxHp -= 15; G.hp = Math.min(G.hp, G.maxHp); const s=SUITS[Math.floor(Math.random()*4)]; G.modifiers.push({name:s.charAt(0).toUpperCase()+s.slice(1)+' Flame',suit:s,type:'mult',value:0.3,tier:'flame',persistent:true}); }},
      { label: 'Trade Ink', desc: 'Pay 50 Ink. Gain +0.2x universal multiplier.', fn: () => { if(G.ink>=50){G.ink-=50;G.modifiers.push({name:'Universal Flame',suit:null,type:'mult',value:0.2,tier:'flame',persistent:true});}else{G.ink+=10;} }},
      { label: 'Refuse', desc: 'Nothing happens.', fn: () => {} },
    ]
  },
  {
    title: 'The Gambler\'s Ghost',
    text: 'A spectral card player materializes before you. "One trick. That\'s all I ask."',
    choices: [
      { label: 'Accept the Wager', desc: '50% chance: gain +0.3x mult. 50% chance: lose a card.', fn: () => { if(Math.random()<0.5){G.modifiers.push({name:'Ghost\'s Gift',suit:null,type:'mult',value:0.3,tier:'flame',persistent:true});}else if(G.deck.length>15){G.deck.splice(Math.floor(Math.random()*G.deck.length),1);} }},
      { label: 'Decline', desc: 'The ghost vanishes.', fn: () => {} },
    ]
  },
  {
    title: 'The Broken Mirror',
    text: 'A shattered mirror shows a version of you from a lost timeline.',
    choices: [
      { label: 'Merge Timelines', desc: 'Add 2 rare cards to your deck.', fn: () => { for(let i=0;i<2;i++) G.deck.push(makeCard(SUITS[Math.floor(Math.random()*4)], Math.floor(Math.random()*5)+10, 'rare')); }},
      { label: 'Shatter It', desc: 'Gain +5 chips modifier.', fn: () => { G.modifiers.push({name:'Fracture Chips',suit:null,type:'chips',value:5,tier:'flame',persistent:true}); }},
    ]
  },
];

function showEvent() {
  showScreen('event-screen');
  const evt = EVENTS[Math.floor(Math.random() * EVENTS.length)];
  document.getElementById('event-title').textContent = evt.title;
  document.getElementById('event-text').textContent = evt.text;
  const container = document.getElementById('event-choices');
  container.innerHTML = '';
  evt.choices.forEach(ch => {
    const el = document.createElement('div');
    el.className = 'event-choice';
    el.innerHTML = `<div class="choice-label">${ch.label}</div><div class="choice-desc">${ch.desc}</div>`;
    el.addEventListener('click', () => { ch.fn(); showMap(); });
    container.appendChild(el);
  });
}

function showRest() {
  showScreen('rest-screen');
  const container = document.getElementById('rest-choices');
  container.innerHTML = '';
  const choices = [
    { label: 'üî• Rest & Heal', desc: `Recover 30% HP (+${Math.floor(G.maxHp*0.3)} HP)`, fn: () => { G.hp = Math.min(G.maxHp, G.hp + Math.floor(G.maxHp * 0.3)); }},
    { label: '‚öíÔ∏è Upgrade a Card', desc: 'A random card gains +50% base chips', fn: () => { if(G.deck.length>0){ const c=G.deck[Math.floor(Math.random()*G.deck.length)]; c.baseChips=Math.floor(c.baseChips*1.5); c.name='‚òÖ '+c.name; } }},
    { label: '‚ú® Meditate', desc: 'Gain a random Flame modifier', fn: () => { const s=SUITS[Math.floor(Math.random()*4)]; G.modifiers.push({name:s.charAt(0).toUpperCase()+s.slice(1)+' Flame',suit:s,type:'mult',value:0.15,tier:'flame',persistent:true}); }},
  ];
  choices.forEach(ch => {
    const el = document.createElement('div');
    el.className = 'event-choice';
    el.innerHTML = `<div class="choice-label">${ch.label}</div><div class="choice-desc">${ch.desc}</div>`;
    el.addEventListener('click', () => { ch.fn(); showMap(); });
    container.appendChild(el);
  });
}

function showShop() {
  showScreen('event-screen');
  document.getElementById('event-title').textContent = 'üè™ The Card Shop';
  document.getElementById('event-text').textContent = `You have ${G.ink} Ink to spend.`;
  const container = document.getElementById('event-choices');
  container.innerHTML = '';
  const items = [
    { label: `Buy a Rare Card (100 Ink)`, desc: 'Add a random rare card', fn: () => { if(G.ink>=100){G.ink-=100;G.deck.push(makeCard(SUITS[Math.floor(Math.random()*4)],Math.floor(Math.random()*5)+10,'rare'));} }},
    { label: `Remove a Card (50 Ink)`, desc: 'Remove a random weak card from your deck', fn: () => { if(G.ink>=50&&G.deck.length>15){G.ink-=50;G.deck.sort((a,b)=>a.rank-b.rank);G.deck.shift();} }},
    { label: `Heal Potion (40 Ink)`, desc: `Heal 25% HP (+${Math.floor(G.maxHp*0.25)})`, fn: () => { if(G.ink>=40){G.ink-=40;G.hp=Math.min(G.maxHp,G.hp+Math.floor(G.maxHp*0.25));} }},
    { label: 'Leave', desc: 'Return to the map', fn: () => {} },
  ];
  items.forEach(ch => {
    const el = document.createElement('div');
    el.className = 'event-choice';
    el.innerHTML = `<div class="choice-label">${ch.label}</div><div class="choice-desc">${ch.desc}</div>`;
    el.addEventListener('click', () => { ch.fn(); showMap(); });
    container.appendChild(el);
  });
}

function showTreasure() {
  showScreen('event-screen');
  document.getElementById('event-title').textContent = 'üíé Treasure Found!';
  const suit = SUITS[Math.floor(Math.random() * 4)];
  G.modifiers.push({ name: suit.charAt(0).toUpperCase()+suit.slice(1)+' Flame', suit, type: 'mult', value: 0.25, tier: 'flame', persistent: true });
  G.ink += 40;
  document.getElementById('event-text').textContent = `You found a ${suit} Flame Modifier (+0.25√ó mult) and 40 Ink!`;
  const container = document.getElementById('event-choices');
  container.innerHTML = '';
  const el = document.createElement('div');
  el.className = 'event-choice';
  el.innerHTML = `<div class="choice-label">Continue</div>`;
  el.addEventListener('click', () => showMap());
  container.appendChild(el);
}

function showShrine() {
  showScreen('event-screen');
  document.getElementById('event-title').textContent = '‚ú® Modifier Shrine';
  document.getElementById('event-text').textContent = 'Ancient energy hums through the sigils. Choose your blessing.';
  const container = document.getElementById('event-choices');
  container.innerHTML = '';
  for (let i = 0; i < 3; i++) {
    const suit = SUITS[i % 4];
    const type = Math.random() < 0.5 ? 'mult' : 'chips';
    const val = type === 'mult' ? +(0.15 + Math.random() * 0.2).toFixed(2) : Math.floor(3 + Math.random() * 5);
    const el = document.createElement('div');
    el.className = 'event-choice';
    el.innerHTML = `<div class="choice-label">${suit.charAt(0).toUpperCase()+suit.slice(1)} ${type === 'mult' ? 'Mult' : 'Chips'}</div>
      <div class="choice-desc">+${val}${type==='mult'?'√ó':''} ${type} for ${suit} cards (Flame)</div>`;
    el.addEventListener('click', () => {
      G.modifiers.push({ name: suit.charAt(0).toUpperCase()+suit.slice(1)+' Shrine', suit, type, value: val, tier: 'flame', persistent: true });
      showMap();
    });
    container.appendChild(el);
  }
}

// ====== GAME OVER ======
function gameOver(victory) {
  showScreen('gameover-screen');
  const titleEl = document.getElementById('gameover-title');
  titleEl.textContent = victory ? 'Victory!' : 'Defeat';
  titleEl.className = 'gameover-title ' + (victory ? 'victory' : 'defeat');

  const score = G.totalDamage + (G.tricksWon * 10) + (G.modifiers.length * 50) + (G.hp * 20);
  document.getElementById('gameover-stats').innerHTML = `
    Total Damage Dealt: ${G.totalDamage}<br>
    Tricks Won: ${G.tricksWon} | Lost: ${G.tricksLost}<br>
    Encounters Won: ${G.encountersWon}<br>
    Modifiers Collected: ${G.modifiers.length}<br>
    Act Reached: ${G.act}<br>
    <br>
    <span style="color:var(--gold);font-family:'Cinzel',serif;font-size:20px;">
      Final Score: ${score.toLocaleString()}
    </span>
  `;
}

// ====== UI HELPERS ======
function updateBattleUI() {
  document.getElementById('battle-hp').textContent = G.hp + (G.shield > 0 ? ' (üõ°' + G.shield + ')' : '');
  document.getElementById('battle-ink').textContent = G.ink;
  document.getElementById('battle-round').textContent = G.roundNum;
  document.getElementById('battle-trick').textContent = G.trickNum + '/' + G.tricksPerRound;
  document.getElementById('battle-act').textContent = G.act;
  document.getElementById('round-score').textContent = G.roundScore;

  // Enemy
  if (G.enemy) {
    document.getElementById('enemy-name').textContent = G.enemy.name;
    document.getElementById('enemy-intent').textContent = G.enemy.passive ? `Passive: ${G.enemy.passive}` : 'Intent: Attack';
    const hpPct = Math.max(0, (G.enemy.hp / G.enemy.maxHp) * 100);
    document.getElementById('enemy-hp-fill').style.width = hpPct + '%';
    document.getElementById('enemy-hp-text').textContent = G.enemy.hp + ' / ' + G.enemy.maxHp + (G.enemy.armor > 0 ? ' [üõ°' + G.enemy.armor + ']' : '');
  }

  // Enemy card slot
  const ecs = document.getElementById('enemy-card-slot');
  if (G.enemyCard) {
    ecs.className = 'enemy-card-slot has-card';
    ecs.style.borderColor = SUIT_COLORS[G.enemyCard.suit].replace('var(--','').replace(')','');
    ecs.style.borderColor = getComputedSuitColor(G.enemyCard.suit);
    ecs.innerHTML = `
      <div style="text-align:center">
        <div style="font-family:'Cinzel',serif;font-size:24px;font-weight:900;color:${SUIT_COLORS[G.enemyCard.suit]}">${RANK_NAMES[G.enemyCard.rank]}</div>
        <div style="font-size:22px">${SUIT_SYMBOLS[G.enemyCard.suit]}</div>
        <div style="font-size:10px;color:var(--text-dim)">${G.enemyCard.suit}</div>
      </div>
    `;
  } else {
    ecs.className = 'enemy-card-slot';
    ecs.innerHTML = 'Waiting...';
  }

  // Hand
  renderHand();

  // Play button
  const playBtn = document.getElementById('btn-play');
  playBtn.disabled = !(G.selectedCard && G.selectedRow && G.phase === 'player_choose');

  // Score preview
  const previewEl = document.getElementById('score-preview');
  if (G.selectedCard && G.selectedRow && G.phase === 'player_choose') {
    const est = calculateScore(G.selectedCard, G.selectedRow);
    const followsSuit = G.enemyCard && G.selectedCard.suit === G.enemyCard.suit;
    const wouldWin = followsSuit && G.selectedCard.rank > G.enemyCard.rank;
    previewEl.innerHTML = followsSuit
      ? (wouldWin
        ? `Follows suit ‚Äî <span class="preview-val">Win! ‚âà${est} damage</span>`
        : `Follows suit ‚Äî <span style="color:var(--danger)">Lose (outranked)</span>`)
      : `Off-suit ‚Äî <span style="color:var(--danger)">Cannot win trick</span> (plays to ${G.selectedRow} row)`;
  } else if (G.selectedCard && !G.selectedRow) {
    previewEl.innerHTML = '<span style="color:var(--text-dim)">Select a row ‚Üë (1=Crown, 2=Heart, 3=Shield)</span>';
  } else {
    previewEl.innerHTML = '';
  }

  // Row streaks
  ['crown','heart','foundation'].forEach(r => {
    const el = document.getElementById(r + '-streak');
    el.textContent = G.rowStreaks[r] > 0 ? '√ó' + G.rowStreaks[r] : '';
  });

  // Escalation Matrix
  renderMatrix();
}

function renderHand() {
  const container = document.getElementById('hand-cards');
  container.innerHTML = '';
  G.hand.forEach(card => {
    const matchesSuit = G.enemyCard && card.suit === G.enemyCard.suit;
    const el = document.createElement('div');
    el.className = 'card ' + card.suit;
    if (G.selectedCard && G.selectedCard.id === card.id) el.classList.add('selected');
    if (G.phase !== 'player_choose') el.classList.add('disabled');
    if (matchesSuit && G.phase === 'player_choose') {
      el.style.boxShadow = '0 0 12px rgba(212,168,67,0.25)';
    }
    el.innerHTML = `
      <div class="card-rank">${RANK_NAMES[card.rank]}</div>
      <div class="card-suit">${SUIT_SYMBOLS[card.suit]}</div>
      <div class="card-chips">${card.baseChips}‚ô¶ ${card.baseMult}√ó</div>
      ${card.keywords.length ? '<div class="card-keyword">'+card.keywords[0]+'</div>' : ''}
      ${matchesSuit && G.phase === 'player_choose' ? '<div style="position:absolute;bottom:2px;left:50%;transform:translateX(-50%);font-size:8px;color:var(--gold)">match</div>' : ''}
    `;
    el.addEventListener('click', () => selectCard(card.id));
    container.appendChild(el);
  });
}

function renderMatrix() {
  const list = document.getElementById('matrix-list');
  list.innerHTML = '';
  if (G.modifiers.length === 0) {
    list.innerHTML = '<div style="text-align:center;color:var(--text-dim);font-size:12px;padding:16px">No modifiers yet.<br>Win tricks to build your engine!</div>';
    return;
  }
  // Group by tier
  const tiers = ['inferno','flame','spark'];
  tiers.forEach(tier => {
    const mods = G.modifiers.filter(m => m.tier === tier);
    if (mods.length === 0) return;
    mods.forEach(m => {
      const el = document.createElement('div');
      el.className = 'mod-item ' + tier;
      el.innerHTML = `
        <div class="mod-tier">${tier}</div>
        <div class="mod-name">${m.name}</div>
        <div class="mod-val">+${typeof m.value === 'number' ? (m.type === 'mult' ? m.value.toFixed(2) + '√ó' : m.value) : m.value} ${m.type === 'mult' ? 'mult' : 'chips'}${m.suit ? ' ('+m.suit+')' : ' (all)'}</div>
      `;
      list.appendChild(el);
    });
  });
}

function enableRowSelection(enable) {
  document.querySelectorAll('.row-lane').forEach(el => {
    if (enable) {
      el.classList.add('selectable');
      el.onclick = () => selectRow(el.dataset.row);
    } else {
      el.classList.remove('selectable', 'selected');
      el.onclick = null;
    }
  });
  if (enable) updateRowHighlight();
}

function updateRowHighlight() {
  document.querySelectorAll('.row-lane').forEach(el => {
    el.classList.toggle('selected', el.dataset.row === G.selectedRow);
  });
}

// Override selectRow to also update highlight
const _origSelectRow = selectRow;
// selectRow is already defined above, let's wrap it
(function() {
  const orig = window.selectRow;
  // It's fine - selectRow calls updateBattleUI which handles everything
})();

function clearRows() {
  ['crown','heart','foundation'].forEach(r => {
    document.getElementById(r + '-row-cards').innerHTML = '';
    document.getElementById(r + '-streak').textContent = '';
  });
}

function addMiniCard(row, card) {
  const container = document.getElementById(row + '-row-cards');
  const el = document.createElement('div');
  el.className = 'mini-card';
  el.style.color = SUIT_COLORS[card.suit];
  el.style.borderColor = getComputedSuitColor(card.suit);
  el.textContent = RANK_NAMES[card.rank];
  container.appendChild(el);
}

function getComputedSuitColor(suit) {
  const map = { hearts: '#e63946', diamonds: '#f4a300', clubs: '#2a9d8f', spades: '#6c5ce7' };
  return map[suit] || '#888';
}

function toggleMatrix() {
  document.getElementById('matrix-panel').classList.toggle('open');
}

// ====== KEYBOARD SHORTCUTS ======
function showHelp() {
  document.getElementById('help-overlay').style.display = 'flex';
}

document.addEventListener('keydown', (e) => {
  if (G.phase === 'player_choose') {
    if (e.key === '1' || e.key === 'q') selectRow('crown');
    if (e.key === '2' || e.key === 'w') selectRow('heart');
    if (e.key === '3' || e.key === 'e') selectRow('foundation');
    if (e.key === 'Enter' || e.key === ' ') playCard();
  }
  if (e.key === 'm') toggleMatrix();
  if (e.key === 'Escape') {
    document.getElementById('help-overlay').style.display = 'none';
    document.getElementById('matrix-panel').classList.remove('open');
  }
});

// Select row on click needs to update UI
const origSelectRow2 = selectRow;
window.selectRow = function(row) {
  if (G.phase !== 'player_choose') return;
  G.selectedRow = row;
  document.querySelectorAll('.row-lane').forEach(el => {
    el.classList.toggle('selected', el.dataset.row === row);
  });
  updateBattleUI();
};
</script>
</body>
</html>
