<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Bastard</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CORE VARIABLES & RESET
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --bg: #0a0c12;
  --bg-panel: #12151e;
  --bg-card: #1a1e2a;
  --border: rgba(255,255,255,0.07);
  --border-hover: rgba(255,255,255,0.15);
  --gold: #d4a843;
  --gold-dim: rgba(212,168,67,0.15);
  --gold-glow: rgba(212,168,67,0.3);
  --red: #c0392b;
  --red-dim: rgba(192,57,43,0.2);
  --green: #27ae60;
  --green-dim: rgba(46,204,113,0.15);
  --blue: #3498db;
  --purple: #9b59b6;
  --text: #c8c2b8;
  --text-dim: rgba(255,255,255,0.35);
  --text-bright: #eee8dd;
  --card-w: 64px;
  --card-h: 92px;
  --card-radius: 8px;
}
*,*::before,*::after { margin:0; padding:0; box-sizing:border-box; }
html { scroll-behavior:smooth; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Outfit','Segoe UI',sans-serif;
  min-height: 100vh;
  min-height: 100dvh;
  overflow-x: hidden;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}
button {
  font-family: 'Outfit',sans-serif;
  cursor: pointer;
  transition: all .2s;
  border: none;
  outline: none;
}
button:hover:not(:disabled) { filter:brightness(1.15); transform:translateY(-1px); }
button:active:not(:disabled) { transform:translateY(0) scale(0.97); }
button:disabled { opacity:.4; cursor:not-allowed; }
::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:rgba(255,255,255,.08); border-radius:3px; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BACKGROUND TEXTURE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
body::before {
  content:'';
  position:fixed; inset:0;
  background:
    radial-gradient(ellipse 80% 60% at 20% 10%, rgba(212,168,67,0.03) 0%, transparent 60%),
    radial-gradient(ellipse 60% 50% at 80% 80%, rgba(59,130,246,0.02) 0%, transparent 60%);
  pointer-events:none; z-index:0;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SCREENS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.screen { display:none; min-height:100vh; min-height:100dvh; flex-direction:column; align-items:center; justify-content:center; position:relative; z-index:1; }
.screen.active { display:flex; }

/* â”€â”€â”€ Title Screen â”€â”€â”€ */
#title-screen {
  background: radial-gradient(ellipse at 50% 30%, #151220 0%, #0a0c12 70%);
  gap: 8px;
  padding: 40px 24px;
}
#title-screen h1 {
  font-family:'Cinzel',serif;
  font-size: clamp(36px, 8vw, 56px);
  font-weight:900;
  background: linear-gradient(135deg, var(--gold), #f0d78c, var(--gold));
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  letter-spacing:8px;
  text-shadow:0 2px 20px var(--gold-glow);
  text-transform: uppercase;
}
.title-sub {
  color: var(--text-dim);
  font-size:13px;
  letter-spacing:4px;
  text-transform:uppercase;
  font-weight:300;
  margin-bottom:32px;
}

.setup-section {
  margin-bottom: 24px;
  text-align: center;
}
.setup-label {
  color: var(--text-dim);
  font-size:11px;
  letter-spacing:2.5px;
  text-transform:uppercase;
  margin-bottom:10px;
  font-weight:500;
}
.option-row {
  display:flex; gap:8px; justify-content:center;
}
.option-btn {
  min-width:52px; height:52px; border-radius:12px;
  border:2px solid var(--border);
  background: rgba(255,255,255,0.03);
  color: var(--text-dim);
  font-size:15px; font-weight:600;
  font-family:'Outfit',sans-serif;
  transition: all .2s;
  padding: 0 14px;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap: 2px;
}
.option-btn .opt-sub {
  font-size: 8px;
  letter-spacing: 1px;
  text-transform: uppercase;
  opacity: 0.6;
}
.option-btn.sel {
  border-color: var(--gold);
  background: var(--gold-dim);
  color: var(--gold);
}
.player-num-btn {
  width:52px; height:52px;
  font-family:'Cinzel',serif;
  font-size:20px; font-weight:700;
}

.start-btn {
  padding:14px 52px;
  font-size:16px; font-weight:700;
  letter-spacing:4px;
  background:linear-gradient(135deg, #8b2020, var(--red));
  color:#fff;
  border-radius:12px;
  font-family:'Cinzel',serif;
  box-shadow:0 4px 24px rgba(192,57,43,.35);
  text-transform:uppercase;
  margin-top: 8px;
}
.back-link {
  position:absolute; top:20px; left:20px;
  color: var(--text-dim);
  text-decoration:none;
  font-size:13px;
  letter-spacing:1px;
  transition: color .2s;
}
.back-link:hover { color: var(--gold); }

.rules-link {
  margin-top: 20px;
  color: var(--text-dim);
  font-size:12px;
  letter-spacing:1.5px;
  text-transform:uppercase;
  cursor:pointer;
  transition: color .2s;
  text-decoration: underline;
  text-underline-offset: 3px;
  background:none; border:none;
  font-family:'Outfit',sans-serif;
}
.rules-link:hover { color: var(--gold); transform:none; }

/* â”€â”€â”€ Game Screen â”€â”€â”€ */
#game-screen {
  justify-content: flex-start;
  padding: 6px 8px 0;
  gap: 0;
  min-height: 100vh;
  min-height: 100dvh;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PLAYING CARDS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.card {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-radius);
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: 'Cinzel', serif;
  font-weight: 700;
  position: relative;
  flex-shrink: 0;
  transition: transform .15s, box-shadow .15s, outline .15s;
}
.card-face {
  background: linear-gradient(145deg, #f5f2ea, #e8e2d4);
  border: 1px solid rgba(0,0,0,0.12);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8);
  color: #1a1a1a;
  cursor: pointer;
}
.card-face.red { color: #b22222; }
.card-face .card-rank { font-size:17px; line-height:1; }
.card-face .card-suit { font-size:20px; line-height:1; margin-top:1px; }
.card-face .card-corner {
  position:absolute; font-size:9px; line-height:1;
}
.card-face .card-corner.tl { top:4px; left:5px; }
.card-face .card-corner.br { bottom:4px; right:5px; transform:rotate(180deg); }

/* Special card indicators */
.card-face.special-2 { box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8), 0 0 0 1.5px rgba(52,152,219,0.5); }
.card-face.special-3 { box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8), 0 0 0 1.5px rgba(155,89,182,0.5); }
.card-face.special-5 { box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8), 0 0 0 1.5px rgba(46,204,113,0.5); }
.card-face.special-7 { box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8), 0 0 0 1.5px rgba(243,156,18,0.5); }
.card-face.special-10 { box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8), 0 0 0 1.5px rgba(231,76,60,0.5); }
.card-face.special-joker {
  background: linear-gradient(145deg, #2c1654, #1a0d33);
  color: #f0d78c;
  border: 1.5px solid rgba(212,168,67,0.4);
  box-shadow: 0 2px 12px rgba(212,168,67,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
}
.card-face.special-joker .card-corner { color: #f0d78c; }
.card-face .card-power {
  position:absolute; bottom: 2px; left: 50%; transform: translateX(-50%);
  font-size: 7px; font-family: 'Outfit',sans-serif; font-weight: 600;
  letter-spacing: 0.5px; text-transform: uppercase; opacity: 0.5;
}
.card-face.special-joker .card-power { opacity: 0.7; }

.card-back {
  background: linear-gradient(145deg, #1a3a6a, #0f2544);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
}
.card-back::after {
  content:'';
  width: 44px; height: 64px;
  border-radius: 4px;
  border: 1.5px solid rgba(212,168,67,0.3);
  background: repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(212,168,67,0.06) 3px, rgba(212,168,67,0.06) 6px);
}

.card.selectable { cursor:pointer; }
.card.selectable:hover {
  transform: translateY(-8px);
  box-shadow: 0 8px 24px rgba(212,168,67,0.25);
  z-index: 10;
}
.card.selected {
  transform: translateY(-12px);
  outline: 2.5px solid var(--gold);
  box-shadow: 0 8px 20px var(--gold-glow);
  z-index: 10;
}
.card.not-playable { opacity: 0.4; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME TABLE LAYOUT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.opponents-row {
  display:flex;
  justify-content:center;
  gap: 10px;
  flex-wrap: wrap;
  width: 100%;
  padding: 4px 0;
}
.opponent-zone {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 8px 10px;
  text-align: center;
  min-width: 130px;
  max-width: 200px;
  flex: 1;
  transition: border-color .3s, box-shadow .3s;
}
.opponent-zone.is-turn {
  border-color: rgba(212,168,67,0.3);
  box-shadow: 0 0 20px rgba(212,168,67,0.08);
}
.opponent-name {
  font-family:'Cinzel',serif;
  font-size: 11px;
  color: var(--text-dim);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}
.opponent-name.active-turn {
  color: var(--gold);
  text-shadow: 0 0 10px var(--gold-glow);
}
.hand-count {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,0.06);
  border-radius: 10px;
  padding: 1px 6px;
  font-family: 'Outfit', sans-serif;
  font-size: 9px;
  font-weight: 500;
  color: var(--text-dim);
  min-width: 20px;
}
.opponent-table-cards {
  display:flex; gap:4px; justify-content:center;
}
.opp-stack {
  position: relative;
  width: 40px;
  height: 56px;
}
.opp-stack .card {
  --card-w: 40px;
  --card-h: 56px;
  --card-radius: 5px;
  position: absolute;
  top: 0; left: 0;
}
.opp-stack .card-face .card-rank { font-size:11px; }
.opp-stack .card-face .card-suit { font-size:12px; }
.opp-stack .card-face .card-corner { font-size:7px; }
.opp-stack .card-face .card-power { display:none; }
.opp-stack .card-back::after { width:26px; height:38px; }

/* â”€â”€â”€ Center Play Area â”€â”€â”€ */
.center-area {
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 28px;
  padding: 10px 0;
  flex-shrink: 0;
  width: 100%;
  min-height: 150px;
}
.pile-zone {
  display:flex; flex-direction:column; align-items:center; gap:5px;
}
.pile-label {
  font-size:10px; color:var(--text-dim); letter-spacing:1.5px; text-transform:uppercase; font-weight:500;
}
.pile-cards {
  position:relative;
  width: var(--card-w);
  height: var(--card-h);
}
.pile-cards .card {
  position:absolute; top:0; left:0;
}
.pile-placeholder {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-radius);
  border: 2px dashed rgba(255,255,255,0.08);
  display:flex; align-items:center; justify-content:center;
  font-size:10px; color:var(--text-dim); letter-spacing:1px;
}
.pile-count {
  font-size:11px; color:var(--text-dim); font-weight:500; min-height: 16px;
}

/* Effective value indicator on discard */
.effective-badge {
  position: absolute;
  top: -8px; right: -8px;
  background: var(--bg-panel);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 12px;
  padding: 2px 6px;
  font-size: 9px;
  font-family: 'Outfit', sans-serif;
  font-weight: 600;
  color: var(--gold);
  z-index: 20;
  white-space: nowrap;
  letter-spacing: 0.5px;
}
.seven-warning {
  background: rgba(243,156,18,0.15);
  border-color: rgba(243,156,18,0.3);
  color: #f39c12;
}

/* â”€â”€â”€ Action area â”€â”€â”€ */
.action-bar {
  display:flex; align-items:center; justify-content:center; gap:10px;
  padding: 4px 0;
  min-height: 44px;
  flex-shrink: 0;
  flex-wrap: wrap;
}
.action-btn {
  padding: 10px 28px;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 1.5px;
  text-transform: uppercase;
}
.btn-play {
  background: linear-gradient(135deg, #1a6b3a, var(--green));
  color: #fff;
  box-shadow: 0 2px 12px rgba(46,204,113,0.3);
}
.btn-pickup {
  background: linear-gradient(135deg, #8b2020, var(--red));
  color: #fff;
  box-shadow: 0 2px 12px rgba(192,57,43,0.3);
}
.btn-confirm-swap {
  background: linear-gradient(135deg, #1a5a8b, var(--blue));
  color: #fff;
  box-shadow: 0 2px 12px rgba(52,152,219,0.3);
}
.btn-quick-finish {
  background: linear-gradient(135deg, #5a3d8b, var(--purple));
  color: #fff;
  box-shadow: 0 2px 12px rgba(155,89,182,0.3);
  animation: pulse 1.5s infinite;
}

/* â”€â”€â”€ Player Zone â”€â”€â”€ */
.player-zone {
  width: 100%;
  padding: 0 0 8px;
  text-align: center;
}
.player-label {
  font-family:'Cinzel',serif;
  font-size: 12px;
  color: var(--text-dim);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 3px;
}
.player-label.active-turn {
  color: var(--gold);
  text-shadow: 0 0 10px var(--gold-glow);
}

/* Table cards section */
.player-section {
  margin-bottom: 4px;
}
.section-label {
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 4px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}
.section-label::before, .section-label::after {
  content: '';
  height: 1px;
  width: 30px;
  background: var(--border);
}
.player-table-cards {
  display:flex; gap:8px; justify-content:center;
  padding: 6px 0;
}
.player-stack {
  position:relative;
  width: var(--card-w);
  height: var(--card-h);
}
.player-stack .card {
  position:absolute; top:0; left:0;
}
.player-hand-section {
  background: rgba(255,255,255,0.02);
  border-top: 1px solid var(--border);
  border-radius: 0 0 16px 16px;
  padding: 6px 4px 8px;
  margin: 0 -8px;
}
.player-hand {
  display:flex;
  gap: 3px;
  justify-content:center;
  flex-wrap: wrap;
  padding: 2px 4px;
  min-height: calc(var(--card-h) + 16px);
}

/* â”€â”€â”€ Game Log â”€â”€â”€ */
.game-log {
  position: fixed;
  top: 0; right: 0;
  width: 200px;
  max-height: 100vh;
  overflow-y: auto;
  padding: 40px 10px 10px;
  z-index: 50;
  pointer-events: none;
  display: none;
}
.log-entry {
  font-size: 10px;
  color: var(--text-dim);
  padding: 3px 8px;
  margin-bottom: 2px;
  border-radius: 6px;
  background: rgba(10,12,18,0.8);
  backdrop-filter: blur(4px);
  animation: fadeIn .3s ease;
}
.log-entry.burn { color: #e74c3c; }
.log-entry.pickup { color: #f39c12; }

/* â”€â”€â”€ Message overlay â”€â”€â”€ */
.game-message {
  position:fixed;
  top: 50%; left:50%;
  transform: translate(-50%,-50%);
  background: rgba(10,12,18,0.97);
  border: 1px solid var(--gold);
  border-radius: 16px;
  padding: 32px 48px;
  text-align:center;
  z-index:100;
  box-shadow: 0 0 60px rgba(212,168,67,0.15);
  display:none;
}
.game-message.show { display:block; animation: fadeIn .3s ease; }
.game-message h2 {
  font-family:'Cinzel',serif;
  font-size: 28px;
  color: var(--gold);
  letter-spacing: 4px;
  margin-bottom: 8px;
}
.game-message p { color: var(--text-dim); margin-bottom: 20px; font-size:14px; }
.game-message button {
  padding: 10px 36px;
  font-family:'Cinzel',serif;
  font-size:14px; font-weight:700;
  letter-spacing:3px;
  text-transform:uppercase;
  background:linear-gradient(135deg,#8b2020,var(--red));
  color:#fff; border-radius:10px;
  box-shadow:0 4px 20px rgba(192,57,43,.3);
}

/* â”€â”€â”€ Toast notification â”€â”€â”€ */
.toast {
  position:fixed;
  top: 16px; left:50%;
  transform: translateX(-50%) translateY(-60px);
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 10px 24px;
  font-size: 13px;
  color: var(--text-bright);
  letter-spacing: 0.5px;
  z-index: 200;
  opacity:0;
  transition: all .3s ease;
  pointer-events:none;
  white-space: nowrap;
  max-width: 90vw;
  text-align: center;
}
.toast.show {
  transform: translateX(-50%) translateY(0);
  opacity:1;
}

/* â”€â”€â”€ Swap phase banner â”€â”€â”€ */
.swap-banner {
  background: var(--gold-dim);
  border: 1px solid rgba(212,168,67,0.25);
  border-radius: 10px;
  padding: 8px 16px;
  font-size: 12px;
  color: var(--gold);
  letter-spacing: 0.5px;
  text-align:center;
  width: 100%;
  max-width: 500px;
  line-height: 1.5;
}

/* â”€â”€â”€ Status bar â”€â”€â”€ */
.status-bar {
  font-size: 11px;
  color: var(--text-dim);
  letter-spacing: 1px;
  padding: 3px 0;
  text-align: center;
  flex-shrink: 0;
}

/* â”€â”€â”€ Top bar â”€â”€â”€ */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 2px 4px 4px;
  flex-shrink: 0;
}
.top-bar-left {
  display: flex; align-items: center; gap: 8px;
}
.menu-btn {
  background: none;
  color: var(--text-dim);
  font-size: 11px;
  letter-spacing: 1px;
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid var(--border);
  font-family: 'Outfit', sans-serif;
}
.menu-btn:hover { color: var(--gold); border-color: rgba(212,168,67,0.3); transform:none; }
.game-info {
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 1px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RULES MODAL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.modal-overlay {
  position: fixed; inset:0;
  background: rgba(0,0,0,0.8);
  z-index: 300;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.modal-overlay.show { display:flex; }
.modal-content {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 28px;
  max-width: 480px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
  position:relative;
}
.modal-content h2 {
  font-family:'Cinzel',serif;
  font-size: 20px;
  color: var(--gold);
  letter-spacing: 3px;
  margin-bottom: 16px;
  text-align: center;
}
.modal-close {
  position: absolute;
  top: 12px; right: 16px;
  background: none; color: var(--text-dim);
  font-size: 20px; cursor: pointer;
  border: none; font-family: sans-serif;
}
.modal-close:hover { color: var(--text-bright); transform:none; }
.rule-card {
  display: flex;
  gap: 12px;
  padding: 10px 0;
  border-bottom: 1px solid var(--border);
  align-items: flex-start;
}
.rule-card:last-child { border-bottom: none; }
.rule-rank {
  font-family:'Cinzel',serif;
  font-size: 18px;
  font-weight: 700;
  min-width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  flex-shrink: 0;
}
.rule-rank.r2 { background: rgba(52,152,219,0.15); color: #3498db; }
.rule-rank.r3 { background: rgba(155,89,182,0.15); color: #9b59b6; }
.rule-rank.r5 { background: rgba(46,204,113,0.15); color: #2ecc71; }
.rule-rank.r7 { background: rgba(243,156,18,0.15); color: #f39c12; }
.rule-rank.r10 { background: rgba(231,76,60,0.15); color: #e74c3c; }
.rule-rank.rjk { background: rgba(212,168,67,0.15); color: #d4a843; }
.rule-desc {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text);
}
.rule-desc strong { color: var(--text-bright); font-weight: 600; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME OVER SCREEN
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#gameover-screen {
  background: radial-gradient(ellipse at 50% 40%, #1a1520 0%, #0a0c12 70%);
  gap: 12px;
}
#gameover-screen h1 {
  font-family:'Cinzel',serif;
  font-size: 40px;
  font-weight:900;
  letter-spacing:6px;
}
#gameover-screen .loser-name {
  font-size: 20px;
  color: var(--text-dim);
  letter-spacing: 3px;
  margin-bottom: 8px;
}
#gameover-screen .subtitle {
  color: var(--text-dim);
  font-size: 13px;
  margin-bottom: 32px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ANIMATIONS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
@keyframes popIn { 0%{transform:scale(0.85);opacity:0} 100%{transform:scale(1);opacity:1} }
.card { animation: popIn .15s ease both; }

/* Play again indicator */
@keyframes playAgainPulse {
  0%,100% { box-shadow: 0 0 0 0 rgba(46,204,113,0.4); }
  50% { box-shadow: 0 0 0 6px rgba(46,204,113,0); }
}
.play-again-indicator {
  animation: playAgainPulse 1.2s infinite;
  border-color: rgba(46,204,113,0.4) !important;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESPONSIVE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@media (max-width:600px) {
  :root { --card-w:54px; --card-h:78px; }
  .opponent-zone { min-width:100px; padding:6px 6px; }
  .opp-stack { width:34px; height:48px; }
  .opp-stack .card { --card-w:34px; --card-h:48px; }
  .opp-stack .card-face .card-rank { font-size:9px; }
  .opp-stack .card-face .card-suit { font-size:10px; }
  .opp-stack .card-back::after { width:22px; height:32px; }
  .player-hand { gap:2px; }
  .center-area { gap:16px; min-height:120px; }
  .opponents-row { gap:6px; }
  .player-hand-section { margin: 0 -8px; }
}

@media (max-width:380px) {
  :root { --card-w:48px; --card-h:70px; }
  .player-hand { gap:1px; }
}
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     TITLE SCREEN
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="title-screen" class="screen active">
  <a href="../" class="back-link">â† Game Hub</a>
  <h1>Bastard</h1>
  <div class="title-sub">The Classic Shedding Game</div>

  <div class="setup-section">
    <div class="setup-label">Players</div>
    <div class="option-row" id="player-select">
      <button class="option-btn player-num-btn" data-count="2">2</button>
      <button class="option-btn player-num-btn sel" data-count="3">3</button>
      <button class="option-btn player-num-btn" data-count="4">4</button>
      <button class="option-btn player-num-btn" data-count="5">5</button>
    </div>
  </div>

  <div class="setup-section">
    <div class="setup-label">Game Length</div>
    <div class="option-row" id="deck-select">
      <button class="option-btn sel" data-decks="1">
        1 Deck
        <span class="opt-sub">Short</span>
      </button>
      <button class="option-btn" data-decks="2">
        2 Decks
        <span class="opt-sub">Medium</span>
      </button>
      <button class="option-btn" data-decks="3">
        3 Decks
        <span class="opt-sub">Long</span>
      </button>
    </div>
  </div>

  <button class="start-btn" onclick="startGame()">Deal</button>
  <button class="rules-link" onclick="showRules()">Card Powers & Rules</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME SCREEN
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="game-screen" class="screen">
  <div class="top-bar">
    <div class="top-bar-left">
      <button class="menu-btn" onclick="backToTitle()">âœ• Quit</button>
      <button class="menu-btn" onclick="showRules()">? Rules</button>
    </div>
    <div class="game-info" id="game-info"></div>
  </div>
  <div class="opponents-row" id="opponents-row"></div>
  <div class="status-bar" id="status-bar"></div>
  <div class="center-area">
    <div class="pile-zone">
      <div class="pile-label">Draw</div>
      <div class="pile-cards" id="draw-pile"></div>
      <div class="pile-count" id="draw-count"></div>
    </div>
    <div class="pile-zone">
      <div class="pile-label">Discard</div>
      <div class="pile-cards" id="discard-pile"></div>
      <div class="pile-count" id="discard-count"></div>
    </div>
  </div>
  <div class="action-bar" id="action-bar"></div>
  <div class="player-zone" id="player-zone"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME OVER SCREEN
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="gameover-screen" class="screen">
  <h1 id="go-title"></h1>
  <div class="loser-name" id="go-loser"></div>
  <div class="subtitle" id="go-subtitle"></div>
  <button class="start-btn" onclick="backToTitle()">Play Again</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     TOAST
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="toast" id="toast"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     RULES MODAL
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="modal-overlay" id="rules-modal">
  <div class="modal-content">
    <button class="modal-close" onclick="hideRules()">âœ•</button>
    <h2>Card Powers</h2>
    <div class="rule-card">
      <div class="rule-rank r2">2</div>
      <div class="rule-desc"><strong>Reset</strong> â€” Plays on any card. Resets the pile so anything can be played next.</div>
    </div>
    <div class="rule-card">
      <div class="rule-rank r3">3</div>
      <div class="rule-desc"><strong>Mirror</strong> â€” Plays on any card. Acts as the same value and power of the card underneath it.</div>
    </div>
    <div class="rule-card">
      <div class="rule-rank r5">5</div>
      <div class="rule-desc"><strong>Play Again</strong> â€” Has value 5 (normal play rules). Allows you to immediately play another card or cards.</div>
    </div>
    <div class="rule-card">
      <div class="rule-rank r7">7</div>
      <div class="rule-desc"><strong>Under</strong> â€” Has value 7 (normal play rules). Next player must play 7 or lower, or a special card (2, 3, 10, Joker).</div>
    </div>
    <div class="rule-card">
      <div class="rule-rank r10">10</div>
      <div class="rule-desc"><strong>Burn</strong> â€” Plays on any card. Removes the entire discard pile. You go again.</div>
    </div>
    <div class="rule-card">
      <div class="rule-rank rjk">â˜…</div>
      <div class="rule-desc"><strong>Joker â€” Burn</strong> â€” Plays on any card. Same as 10 â€” removes the discard pile. You go again.</div>
    </div>
    <div style="padding-top:12px; border-top:1px solid var(--border); margin-top:4px;">
      <div class="rule-desc" style="color:var(--text-dim); font-size:11px; line-height:1.7;">
        <strong style="color:var(--text);">General Rules:</strong> Play cards equal or higher than the top card. Play all cards from your hand first, then face-up table cards, then flip face-down cards blind. Four of a kind burns the pile. Last player with cards is the Barstard!
      </div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME LOGIC
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   CONSTANTS & UTILITY
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SUITS = ['â™ ','â™¥','â™¦','â™£'];
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const RANK_VALUE = {2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, 10:10, J:11, Q:12, K:13, A:14, JK:0};
// For sorting hand display â€” special cards aren't ranked higher, they're just special
const SORT_VALUE = {2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, 10:10, J:11, Q:12, K:13, A:14, JK:16};

const SPECIAL_RANKS = new Set(['2','3','5','7','10','JK']);
const ALWAYS_PLAYABLE = new Set(['2','3','10','JK']); // these can be played on any card

const AI_NAMES = ['Caesar','Brutus','Nero','Cleo'];
const isRed = s => s === 'â™¥' || s === 'â™¦';

function makeCard(rank, suit) { return { rank, suit, id: rank + suit + Math.random().toString(36).slice(2,6) }; }

function makeDeck(numDecks) {
  const d = [];
  for (let n = 0; n < numDecks; n++) {
    for (const s of SUITS) for (const r of RANKS) d.push(makeCard(r, s));
    // 2 Jokers per deck
    d.push(makeCard('JK', 'â˜…'));
    d.push(makeCard('JK', 'â˜†'));
  }
  return d;
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   GAME STATE
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let G = {};

function initState(numPlayers, numDecks) {
  const deck = shuffle(makeDeck(numDecks));
  const players = [];
  for (let i = 0; i < numPlayers; i++) {
    players.push({
      name: i === 0 ? 'You' : AI_NAMES[i - 1],
      isHuman: i === 0,
      faceDown: [],
      faceUp: [],
      hand: [],
      out: false,
    });
  }
  // Deal: 3 face-down, 3 face-up, 3 hand
  for (let round = 0; round < 3; round++)
    for (const p of players) p.faceDown.push(deck.pop());
  for (let round = 0; round < 3; round++)
    for (const p of players) p.faceUp.push(deck.pop());
  for (let round = 0; round < 3; round++)
    for (const p of players) p.hand.push(deck.pop());

  G = {
    players,
    drawPile: deck,
    discardPile: [],
    burnPile: [],
    currentPlayer: 0,
    phase: 'swap', // swap | play | gameover
    selectedCards: [],
    swapSource: null,
    direction: 1,
    activePlayers: numPlayers,
    numDecks,
    playAgainPending: false, // true when current player must play again (from 5)
    lastPlayedBy: 0, // tracks who last successfully played a card (for pickup turn logic)
    quickFinish: false, // when true, AI plays at max speed
  };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   CARD PLAY RULES
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function topDiscard() {
  return G.discardPile.length > 0 ? G.discardPile[G.discardPile.length - 1] : null;
}

// Get the effective card on top of the discard pile (skipping 3s to find what they mirror)
function getEffectiveTop() {
  for (let i = G.discardPile.length - 1; i >= 0; i--) {
    if (G.discardPile[i].rank !== '3') return G.discardPile[i];
  }
  return null; // all 3s or empty â€” treat as reset/empty
}

function isSevenActive() {
  const eff = getEffectiveTop();
  return eff && eff.rank === '7';
}

function canPlayCard(card) {
  // Cards that always play on anything
  if (ALWAYS_PLAYABLE.has(card.rank)) return true;

  const effective = getEffectiveTop();
  if (!effective) return true; // empty or all 3s
  if (effective.rank === '2') return true; // anything on a 2

  // 7 on top: must play 7 or under
  if (effective.rank === '7') {
    return RANK_VALUE[card.rank] <= 7;
  }

  // Normal: must play equal or higher
  return RANK_VALUE[card.rank] >= RANK_VALUE[effective.rank];
}

function canPlaySet(cards) {
  if (cards.length === 0) return false;
  const rank = cards[0].rank;
  if (!cards.every(c => c.rank === rank)) return false;
  return canPlayCard(cards[0]);
}

function checkFourOfAKind() {
  if (G.discardPile.length < 4) return false;
  // Check top 4 by effective rank (skip 3s logic â€” actually for 4-of-a-kind, 
  // we check literal top 4 cards, but 3s mirror, so a 3 on a K counts as K)
  const top4 = G.discardPile.slice(-4);
  const effectiveRanks = top4.map(c => {
    if (c.rank !== '3') return c.rank;
    // Find what this 3 mirrors
    const idx = G.discardPile.indexOf(c);
    for (let i = idx - 1; i >= 0; i--) {
      if (G.discardPile[i].rank !== '3') return G.discardPile[i].rank;
    }
    return '3'; // all 3s
  });
  return effectiveRanks.every(r => r === effectiveRanks[0]);
}

function burnPile() {
  G.burnPile.push(...G.discardPile);
  G.discardPile = [];
}

function replenishHand(player) {
  while (player.hand.length < 3 && G.drawPile.length > 0) {
    player.hand.push(G.drawPile.pop());
  }
  // Sort hand for readability
  player.hand.sort((a, b) => SORT_VALUE[a.rank] - SORT_VALUE[b.rank]);
}

function getPlayableSource(player) {
  if (player.hand.length > 0) return 'hand';
  if (player.faceUp.length > 0) return 'faceUp';
  if (player.faceDown.length > 0) return 'faceDown';
  return null;
}

function isPlayerDone(player) {
  return player.hand.length === 0 && player.faceUp.length === 0 && player.faceDown.length === 0;
}

function findFirstPlayer() {
  // Player with lowest non-special card goes first. Check 4, then 5, 6, etc.
  const searchOrder = ['4','5','6','7','8','9','J','Q','K','A','3','2','10','JK'];
  for (const rank of searchOrder) {
    for (let i = 0; i < G.players.length; i++) {
      if (G.players[i].faceUp.some(c => c.rank === rank)) return i;
      if (G.players[i].hand.some(c => c.rank === rank)) return i;
    }
  }
  return 0;
}

// Determine the effect of playing a card (considering 3 mirroring)
function getPlayEffect(card) {
  let effectiveRank = card.rank;
  if (card.rank === '3') {
    const eff = getEffectiveTop();
    effectiveRank = eff ? eff.rank : '3';
  }
  return {
    burns: effectiveRank === '10' || effectiveRank === 'JK',
    playAgain: effectiveRank === '5',
    sevenRule: effectiveRank === '7',
    reset: effectiveRank === '2',
    effectiveRank,
  };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   AI LOGIC
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function aiChooseCards(player) {
  const source = getPlayableSource(player);
  if (!source) return null;

  if (source === 'faceDown') {
    return { source: 'faceDown', indices: [0] };
  }

  const cards = source === 'hand' ? player.hand : player.faceUp;
  const byRank = {};
  cards.forEach((c, i) => {
    if (!byRank[c.rank]) byRank[c.rank] = [];
    byRank[c.rank].push(i);
  });

  const playableRanks = Object.entries(byRank)
    .filter(([rank]) => canPlayCard(makeCard(rank, 'â™ ')))
    .sort((a, b) => RANK_VALUE[a[0]] - RANK_VALUE[b[0]]);

  if (playableRanks.length === 0) return null;

  // Strategy: burn if pile large
  if (G.discardPile.length >= 5) {
    const burnEntry = playableRanks.find(([r]) => r === '10' || r === 'JK');
    if (burnEntry) return { source, indices: [burnEntry[1][0]] };
  }

  // Try four-of-a-kind completion
  for (const [rank, indices] of playableRanks) {
    if (ALWAYS_PLAYABLE.has(rank)) continue;
    const topCount = G.discardPile.length > 0 ?
      [...G.discardPile].reverse().findIndex(c => {
        const effR = c.rank === '3' ? getEffectiveTop()?.rank : c.rank;
        return effR !== rank;
      }) : 0;
    const onPile = topCount === -1 ? G.discardPile.length : topCount;
    if (onPile + indices.length >= 4) {
      return { source, indices };
    }
  }

  // Play lowest normal card (skip specials if possible)
  for (const [rank, indices] of playableRanks) {
    if (!ALWAYS_PLAYABLE.has(rank) && rank !== '5' && rank !== '7') {
      return { source, indices };
    }
  }
  // Play 5 or 7 if needed
  for (const [rank, indices] of playableRanks) {
    if (rank === '5' || rank === '7') {
      return { source, indices: [indices[0]] };
    }
  }
  // Only specials left
  return { source, indices: [playableRanks[0][1][0]] };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   GAME FLOW
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function nextPlayer() {
  let next = G.currentPlayer;
  const total = G.players.length;
  for (let i = 0; i < total; i++) {
    next = (next + G.direction + total) % total;
    if (!G.players[next].out) return next;
  }
  return G.currentPlayer;
}

function checkGameOver() {
  const remaining = G.players.filter(p => !p.out);
  if (remaining.length <= 1) {
    G.phase = 'gameover';
    const loser = remaining[0] || G.players[G.currentPlayer];
    showGameOver(loser);
    return true;
  }
  return false;
}

function executePlay(playerIdx, cardIndices, source) {
  const player = G.players[playerIdx];
  const srcArr = source === 'hand' ? player.hand :
                 source === 'faceUp' ? player.faceUp : player.faceDown;

  const sorted = [...cardIndices].sort((a, b) => b - a);
  const played = sorted.map(i => srcArr[i]);
  sorted.forEach(i => srcArr.splice(i, 1));

  // Face-down blind play check
  if (source === 'faceDown') {
    const card = played[0];
    if (!canPlayCard(card)) {
      G.discardPile.push(card);
      player.hand.push(...G.discardPile);
      G.discardPile = [];
      replenishHand(player);
      return { burned: false, blindFail: true, playAgain: false };
    }
  }

  // Add to discard
  G.discardPile.push(...played);
  replenishHand(player);

  // Determine effect of played cards
  const effect = getPlayEffect(played[0]);

  // Check burn (10, Joker, or 3 mirroring them)
  if (effect.burns) {
    burnPile();
    return { burned: true, samePlayer: true, playAgain: false };
  }

  // Check four of a kind
  if (checkFourOfAKind()) {
    burnPile();
    return { burned: true, samePlayer: true, playAgain: false };
  }

  // Check play again (5 or 3 mirroring 5)
  if (effect.playAgain) {
    return { burned: false, samePlayer: true, playAgain: true };
  }

  return { burned: false, samePlayer: false, playAgain: false };
}

function doPickup(playerIdx) {
  const player = G.players[playerIdx];
  player.hand.push(...G.discardPile);
  G.discardPile = [];
  player.hand.sort((a, b) => SORT_VALUE[a.rank] - SORT_VALUE[b.rank]);
}

function advanceTurnAfterPickup() {
  // After a pickup, the player who last played a card goes next
  // If that player is out, find the next active player after them
  G.currentPlayer = G.lastPlayedBy;
  if (G.players[G.currentPlayer].out) {
    G.currentPlayer = nextPlayer();
  }
  G.playAgainPending = false;
  G.selectedCards = [];
}

async function advanceTurn(samePlayer = false) {
  if (G.phase !== 'play') return;

  const cur = G.players[G.currentPlayer];
  if (isPlayerDone(cur)) {
    cur.out = true;
    G.activePlayers--;
    if (checkGameOver()) return;
  }

  if (!samePlayer) {
    G.currentPlayer = nextPlayer();
    G.playAgainPending = false;
  } else {
    if (cur.out) {
      G.currentPlayer = nextPlayer();
      G.playAgainPending = false;
    }
  }

  G.selectedCards = [];
  render();

  if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
    await delay(G.quickFinish ? 80 : 700);
    await aiTurn();
  }
}

async function aiTurn() {
  if (G.phase !== 'play') return;
  const player = G.players[G.currentPlayer];
  const choice = aiChooseCards(player);

  if (!choice) {
    doPickup(G.currentPlayer);
    showToast(`${player.name} picks up the pile!`);
    advanceTurnAfterPickup();
    render();
    await delay(G.quickFinish ? 80 : 400);
    if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
      await delay(G.quickFinish ? 80 : 300);
      await aiTurn();
    }
    return;
  }

  const result = executePlay(G.currentPlayer, choice.indices, choice.source);

  if (result.blindFail) {
    showToast(`${player.name} flips blind â€” bad luck! Picks up!`);
    advanceTurnAfterPickup();
    render();
    await delay(G.quickFinish ? 80 : 600);
    if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
      await delay(G.quickFinish ? 80 : 300);
      await aiTurn();
    }
    return;
  }

  // Successful play â€” track who played last
  G.lastPlayedBy = G.currentPlayer;

  if (result.burned) {
    showToast(`${player.name} burns the pile! ğŸ”¥`);
  } else if (result.playAgain) {
    showToast(`${player.name} played a 5 â€” plays again!`);
  }

  render();
  await delay(G.quickFinish ? 80 : 400);

  if (result.samePlayer || result.playAgain) {
    // AI plays again
    if (!isPlayerDone(player)) {
      await delay(G.quickFinish ? 80 : 500);
      await aiTurn();
    } else {
      await advanceTurn(true);
    }
  } else {
    await advanceTurn(false);
  }
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

function startQuickFinish() {
  G.quickFinish = true;
  render();
  // If it's an AI's turn, kick off the fast AI loop
  if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
    aiTurn();
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   HUMAN INTERACTION
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function humanSelectCard(source, index) {
  if (G.phase === 'swap') {
    handleSwapClick(source, index);
    return;
  }
  if (G.phase !== 'play') return;
  if (G.currentPlayer !== 0) return;
  const player = G.players[0];
  const playSource = getPlayableSource(player);
  if (source !== playSource) return;

  if (source === 'faceDown') {
    const result = executePlay(0, [index], 'faceDown');
    if (result.blindFail) {
      showToast("Bad luck! Card can't be played â€” picked up the pile!");
      advanceTurnAfterPickup();
      render();
      if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
        delay(600).then(() => aiTurn());
      }
      return;
    }

    // Successful face-down play
    G.lastPlayedBy = 0;

    if (result.burned) {
      showToast("Pile burned! ğŸ”¥ Your turn again!");
    } else if (result.playAgain) {
      showToast("Played a 5 â€” play again!");
      G.playAgainPending = true;
    }
    render();
    if (result.playAgain && !isPlayerDone(G.players[0])) {
      // Don't advance, let player play again
    } else {
      advanceTurn(result.samePlayer || false);
    }
    return;
  }

  const cards = source === 'hand' ? player.hand : player.faceUp;
  const card = cards[index];

  const selIdx = G.selectedCards.findIndex(s => s.index === index && s.source === source);
  if (selIdx >= 0) {
    G.selectedCards.splice(selIdx, 1);
  } else {
    if (G.selectedCards.length > 0) {
      const firstCard = (G.selectedCards[0].source === 'hand' ? player.hand : player.faceUp)[G.selectedCards[0].index];
      if (card.rank !== firstCard.rank) {
        G.selectedCards = [];
      }
    }
    G.selectedCards.push({ index, source });
  }
  render();
}

function humanPlay() {
  if (G.phase !== 'play' || G.currentPlayer !== 0) return;
  if (G.selectedCards.length === 0) return;

  const player = G.players[0];
  const source = G.selectedCards[0].source;
  const indices = G.selectedCards.map(s => s.index);
  const srcArr = source === 'hand' ? player.hand : player.faceUp;
  const cards = indices.map(i => srcArr[i]);

  if (!canPlaySet(cards)) {
    showToast("Can't play that!");
    return;
  }

  const result = executePlay(0, indices, source);
  G.selectedCards = [];

  if (!result.blindFail) {
    G.lastPlayedBy = 0; // human successfully played
  }

  if (result.burned) {
    showToast("Pile burned! ğŸ”¥ Your turn again!");
  } else if (result.playAgain) {
    showToast("Play again! ğŸ¯");
    G.playAgainPending = true;
    render();
    // Don't advance turn â€” player plays again
    return;
  }

  render();
  advanceTurn(result.samePlayer);
}

function humanPickup() {
  if (G.phase !== 'play' || G.currentPlayer !== 0) return;
  if (G.discardPile.length === 0) {
    showToast("Nothing to pick up!");
    return;
  }
  doPickup(0);
  G.selectedCards = [];
  G.playAgainPending = false;
  showToast("Picked up the pile...");
  advanceTurnAfterPickup();
  render();

  if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
    delay(600).then(() => aiTurn());
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SWAP PHASE
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function handleSwapClick(source, index) {
  if (source !== 'hand' && source !== 'faceUp') return;
  if (!G.swapSource) {
    G.swapSource = { source, index };
    G.selectedCards = [{ source, index }];
  } else if (G.swapSource.source === source && G.swapSource.index === index) {
    G.swapSource = null;
    G.selectedCards = [];
  } else {
    const player = G.players[0];
    const src1 = G.swapSource.source === 'hand' ? player.hand : player.faceUp;
    const src2 = source === 'hand' ? player.hand : player.faceUp;
    const temp = src1[G.swapSource.index];
    src1[G.swapSource.index] = src2[index];
    src2[index] = temp;
    G.swapSource = null;
    G.selectedCards = [];
  }
  render();
}

function finishSwap() {
  // AI swap strategy: put highest value cards face-up
  for (let i = 1; i < G.players.length; i++) {
    const p = G.players[i];
    const all = [...p.hand, ...p.faceUp];
    // Prioritize keeping special cards (2, 10, JK) face up, then highest values
    all.sort((a, b) => {
      const aSpecial = (a.rank === '2' || a.rank === '10' || a.rank === 'JK') ? 100 : 0;
      const bSpecial = (b.rank === '2' || b.rank === '10' || b.rank === 'JK') ? 100 : 0;
      return (bSpecial + SORT_VALUE[b.rank]) - (aSpecial + SORT_VALUE[a.rank]);
    });
    p.faceUp = all.slice(0, 3);
    p.hand = all.slice(3);
    p.hand.sort((a, b) => SORT_VALUE[a.rank] - SORT_VALUE[b.rank]);
  }
  // Sort human hand too
  G.players[0].hand.sort((a, b) => SORT_VALUE[a.rank] - SORT_VALUE[b.rank]);

  G.phase = 'play';
  G.currentPlayer = findFirstPlayer();
  G.lastPlayedBy = G.currentPlayer;
  G.selectedCards = [];
  G.swapSource = null;
  render();

  if (G.currentPlayer !== 0) {
    delay(600).then(() => aiTurn());
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   RENDERING
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function getSpecialClass(rank) {
  if (rank === '2') return ' special-2';
  if (rank === '3') return ' special-3';
  if (rank === '5') return ' special-5';
  if (rank === '7') return ' special-7';
  if (rank === '10') return ' special-10';
  if (rank === 'JK') return ' special-joker';
  return '';
}

function getPowerLabel(rank) {
  if (rank === '2') return 'Reset';
  if (rank === '3') return 'Mirror';
  if (rank === '5') return 'Again';
  if (rank === '7') return 'Under';
  if (rank === '10') return 'Burn';
  if (rank === 'JK') return 'Burn';
  return '';
}

function displayRank(rank) {
  return rank === 'JK' ? 'â˜…' : rank;
}

function displaySuit(card) {
  if (card.rank === 'JK') return card.suit === 'â˜…' ? 'â˜…' : 'â˜†';
  return card.suit;
}

function cardHTML(card, opts = {}) {
  const { faceDown = false, selectable = false, selected = false, clickData = '' } = opts;
  if (faceDown) {
    return `<div class="card card-back ${selectable ? 'selectable' : ''}" ${clickData}></div>`;
  }
  const isJoker = card.rank === 'JK';
  const red = (!isJoker && isRed(card.suit)) ? ' red' : '';
  const specialCls = getSpecialClass(card.rank);
  const selClass = selected ? ' selected' : (selectable ? ' selectable' : '');
  const playable = (G.phase === 'play' && selectable && !canPlayCard(card) && getPlayableSource(G.players[0]) !== 'faceDown') ? ' not-playable' : '';
  const power = getPowerLabel(card.rank);
  const dr = displayRank(card.rank);
  const ds = displaySuit(card);
  return `<div class="card card-face${red}${specialCls}${selClass}${playable}" ${clickData}>
    <span class="card-corner tl">${dr}${isJoker ? '' : ds}</span>
    <span class="card-rank">${dr}</span>
    <span class="card-suit">${ds}</span>
    <span class="card-corner br">${dr}${isJoker ? '' : ds}</span>
    ${power ? `<span class="card-power">${power}</span>` : ''}
  </div>`;
}

function render() {
  renderOpponents();
  renderCenter();
  renderPlayer();
  renderActions();
  renderStatus();
  renderGameInfo();
}

function renderGameInfo() {
  const el = document.getElementById('game-info');
  if (!el) return;
  const deckLabel = G.numDecks === 1 ? '1 Deck' : `${G.numDecks} Decks`;
  el.textContent = `${deckLabel} Â· ${G.drawPile.length} left`;
}

function renderOpponents() {
  const row = document.getElementById('opponents-row');
  let html = '';
  for (let i = 1; i < G.players.length; i++) {
    const p = G.players[i];
    if (p.out) continue;
    const isActive = G.currentPlayer === i && G.phase === 'play';
    const handInfo = p.hand.length > 0 ? `<span class="hand-count">${p.hand.length} cards</span>` : '';
    html += `<div class="opponent-zone ${isActive ? 'is-turn' : ''}">
      <div class="opponent-name ${isActive ? 'active-turn' : ''}">${p.name} ${handInfo}</div>
      <div class="opponent-table-cards">`;
    for (let j = 0; j < 3; j++) {
      html += `<div class="opp-stack">`;
      if (j < p.faceDown.length) {
        html += `<div class="card card-back"></div>`;
      }
      if (j < p.faceUp.length) {
        html += cardHTML(p.faceUp[j]);
      }
      html += `</div>`;
    }
    html += `</div></div>`;
  }
  row.innerHTML = html;
}

function renderCenter() {
  const drawEl = document.getElementById('draw-pile');
  const drawCountEl = document.getElementById('draw-count');
  if (G.drawPile.length > 0) {
    drawEl.innerHTML = `<div class="card card-back"></div>`;
    drawCountEl.textContent = G.drawPile.length;
  } else {
    drawEl.innerHTML = `<div class="pile-placeholder">Empty</div>`;
    drawCountEl.textContent = '';
  }

  const discEl = document.getElementById('discard-pile');
  const discCountEl = document.getElementById('discard-count');
  const top = topDiscard();
  if (top) {
    let html = '';
    const showCount = Math.min(G.discardPile.length, 3);
    for (let i = G.discardPile.length - showCount; i < G.discardPile.length; i++) {
      const offset = (i - (G.discardPile.length - showCount)) * 2;
      const c = G.discardPile[i];
      const isJoker = c.rank === 'JK';
      const red = (!isJoker && isRed(c.suit)) ? ' red' : '';
      const specialCls = getSpecialClass(c.rank);
      const dr = displayRank(c.rank);
      const ds = displaySuit(c);
      html += `<div class="card card-face${red}${specialCls}" style="top:${offset}px;left:${offset}px;">
        <span class="card-corner tl">${dr}${isJoker ? '' : ds}</span>
        <span class="card-rank">${dr}</span>
        <span class="card-suit">${ds}</span>
        <span class="card-corner br">${dr}${isJoker ? '' : ds}</span>
      </div>`;
    }

    // Show effective value badge
    const eff = getEffectiveTop();
    if (top.rank === '3' && eff && eff.rank !== '3') {
      html += `<div class="effective-badge">= ${displayRank(eff.rank)}</div>`;
    }
    if (eff && eff.rank === '7') {
      html += `<div class="effective-badge seven-warning">Play â‰¤7</div>`;
    }

    discEl.innerHTML = html;
    discCountEl.textContent = G.discardPile.length;
  } else {
    discEl.innerHTML = `<div class="pile-placeholder">Empty</div>`;
    discCountEl.textContent = '';
  }
}

function renderPlayer() {
  const zone = document.getElementById('player-zone');
  const p = G.players[0];
  const isMyTurn = G.currentPlayer === 0 && G.phase === 'play';
  const playSource = getPlayableSource(p);
  const isSwap = G.phase === 'swap';
  const playAgain = G.playAgainPending && isMyTurn;

  let html = '';

  // Turn indicator
  html += `<div class="player-label ${isMyTurn ? 'active-turn' : ''}">${p.out ? 'You\'re out! ğŸ‰' : (isMyTurn ? (playAgain ? 'ğŸ¯ Play Again!' : 'âš” Your Turn') : 'Waiting...')}</div>`;

  // Table cards (face-down + face-up) â€” labeled clearly
  const hasTableCards = p.faceDown.length > 0 || p.faceUp.length > 0;
  if (hasTableCards) {
    html += `<div class="player-section">`;
    html += `<div class="section-label">Table Cards (Final Round)</div>`;
    html += `<div class="player-table-cards">`;
    for (let j = 0; j < 3; j++) {
      html += `<div class="player-stack">`;
      if (j < p.faceDown.length) {
        const canClick = (isMyTurn && playSource === 'faceDown') || false;
        html += `<div class="card card-back ${canClick ? 'selectable' : ''}"
          ${canClick ? `onclick="humanSelectCard('faceDown',${j})"` : ''}></div>`;
      }
      if (j < p.faceUp.length) {
        const canClick = (isMyTurn && playSource === 'faceUp') || isSwap;
        const sel = G.selectedCards.some(s => s.source === 'faceUp' && s.index === j);
        html += cardHTML(p.faceUp[j], {
          selectable: canClick,
          selected: sel,
          clickData: canClick ? `onclick="humanSelectCard('faceUp',${j})"` : '',
        });
      }
      html += `</div>`;
    }
    html += `</div></div>`;
  }

  // Hand â€” labeled and in distinct section
  if (p.hand.length > 0 || isSwap) {
    html += `<div class="player-hand-section ${playAgain ? 'play-again-indicator' : ''}">`;
    html += `<div class="section-label">Your Hand${p.hand.length > 0 ? ` (${p.hand.length})` : ''}</div>`;
    html += `<div class="player-hand">`;
    const canClickHand = (isMyTurn && playSource === 'hand') || isSwap;
    for (let i = 0; i < p.hand.length; i++) {
      const sel = G.selectedCards.some(s => s.source === 'hand' && s.index === i);
      html += cardHTML(p.hand[i], {
        selectable: canClickHand,
        selected: sel,
        clickData: canClickHand ? `onclick="humanSelectCard('hand',${i})"` : '',
      });
    }
    html += `</div></div>`;
  }

  zone.innerHTML = html;
}

function renderActions() {
  const bar = document.getElementById('action-bar');
  if (G.phase === 'swap') {
    bar.innerHTML = `
      <div class="swap-banner">Tap a card in your hand, then a face-up table card to swap them.<br>Place your best cards face-up â€” you'll need them in the final round!</div>
      <button class="action-btn btn-confirm-swap" onclick="finishSwap()">Ready â€” Deal!</button>`;
    return;
  }
  // Show quick finish button when human is out but game continues
  if (G.phase === 'play' && G.players[0].out && !G.quickFinish) {
    bar.innerHTML = `<button class="action-btn btn-quick-finish" onclick="startQuickFinish()">âš¡ Quick Finish</button>`;
    return;
  }
  if (G.phase !== 'play' || G.currentPlayer !== 0 || G.players[0].out) {
    bar.innerHTML = '';
    return;
  }
  const hasSelection = G.selectedCards.length > 0;
  const source = getPlayableSource(G.players[0]);
  bar.innerHTML = `
    ${source !== 'faceDown' ? `<button class="action-btn btn-play" ${hasSelection ? '' : 'disabled'} onclick="humanPlay()">Play</button>` : ''}
    <button class="action-btn btn-pickup" onclick="humanPickup()">Pick Up</button>`;
}

function renderStatus() {
  const bar = document.getElementById('status-bar');
  if (G.phase === 'swap') {
    bar.textContent = 'Swap Phase â€” arrange your cards before play begins';
    return;
  }
  if (G.phase === 'gameover') {
    bar.textContent = '';
    return;
  }
  const cp = G.players[G.currentPlayer];
  const src = getPlayableSource(cp);
  const srcLabel = src === 'faceDown' ? '(blind flip!)' : src === 'faceUp' ? '(table cards)' : '';
  if (cp.isHuman) {
    if (G.playAgainPending) {
      bar.textContent = 'You played a 5 â€” play another card!';
    } else {
      bar.textContent = `Your turn ${srcLabel}`;
    }
  } else {
    bar.textContent = G.quickFinish ? `${cp.name} is playing... âš¡` : `${cp.name} is thinking...`;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TOAST
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let toastTimer = null;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.classList.remove('show'), 2200);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   GAME OVER
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function showGameOver(loser) {
  document.getElementById('game-screen').classList.remove('active');
  const screen = document.getElementById('gameover-screen');
  screen.classList.add('active');

  if (loser.isHuman) {
    document.getElementById('go-title').textContent = 'BASTARD!';
    document.getElementById('go-title').style.color = 'var(--red)';
    document.getElementById('go-loser').textContent = "You're the Bastard!";
    document.getElementById('go-subtitle').textContent = 'Better luck next time... now go make the tea.';
  } else {
    document.getElementById('go-title').textContent = 'VICTORY!';
    document.getElementById('go-title').style.color = 'var(--gold)';
    document.getElementById('go-loser').textContent = `${loser.name} is the Bastard!`;
    document.getElementById('go-subtitle').textContent = 'They shuffle and deal next round.';
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   RULES MODAL
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function showRules() {
  document.getElementById('rules-modal').classList.add('show');
}
function hideRules() {
  document.getElementById('rules-modal').classList.remove('show');
}
document.getElementById('rules-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) hideRules();
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SCREEN MANAGEMENT
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function startGame() {
  const count = parseInt(document.querySelector('#player-select .option-btn.sel').dataset.count);
  const decks = parseInt(document.querySelector('#deck-select .option-btn.sel').dataset.decks);
  initState(count, decks);
  showScreen('game-screen');
  render();
}

function backToTitle() {
  showScreen('title-screen');
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   OPTION SELECT BUTTONS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.querySelectorAll('#player-select .option-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#player-select .option-btn').forEach(b => b.classList.remove('sel'));
    btn.classList.add('sel');
  });
});
document.querySelectorAll('#deck-select .option-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#deck-select .option-btn').forEach(b => b.classList.remove('sel'));
    btn.classList.add('sel');
  });
});
</script>
</body>
</html>
