<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Barstard</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CORE VARIABLES & RESET
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --bg: #0a0c12;
  --bg-panel: #12151e;
  --bg-card: #1a1e2a;
  --border: rgba(255,255,255,0.07);
  --border-hover: rgba(255,255,255,0.15);
  --gold: #d4a843;
  --gold-dim: rgba(212,168,67,0.15);
  --gold-glow: rgba(212,168,67,0.3);
  --red: #c0392b;
  --red-dim: rgba(192,57,43,0.2);
  --green: #2ecc71;
  --green-dim: rgba(46,204,113,0.15);
  --blue: #3498db;
  --text: #c8c2b8;
  --text-dim: rgba(255,255,255,0.35);
  --text-bright: #eee8dd;
  --card-w: 70px;
  --card-h: 100px;
  --card-radius: 8px;
}
*,*::before,*::after { margin:0; padding:0; box-sizing:border-box; }
html { scroll-behavior:smooth; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Outfit','Segoe UI',sans-serif;
  min-height: 100vh;
  overflow-x: hidden;
  user-select: none;
}
button {
  font-family: 'Outfit',sans-serif;
  cursor: pointer;
  transition: all .2s;
  border: none;
  outline: none;
}
button:hover:not(:disabled) { filter:brightness(1.15); transform:translateY(-1px); }
button:disabled { opacity:.4; cursor:not-allowed; }
::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:rgba(255,255,255,.08); border-radius:3px; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BACKGROUND TEXTURE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
body::before {
  content:'';
  position:fixed; inset:0;
  background:
    radial-gradient(ellipse 80% 60% at 20% 10%, rgba(212,168,67,0.03) 0%, transparent 60%),
    radial-gradient(ellipse 60% 50% at 80% 80%, rgba(59,130,246,0.02) 0%, transparent 60%);
  pointer-events:none; z-index:0;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SCREENS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.screen { display:none; min-height:100vh; flex-direction:column; align-items:center; justify-content:center; position:relative; z-index:1; }
.screen.active { display:flex; }

/* â”€â”€â”€ Title Screen â”€â”€â”€ */
#title-screen {
  background: radial-gradient(ellipse at 50% 30%, #151220 0%, #0a0c12 70%);
  gap: 8px;
  padding: 40px 24px;
}
#title-screen h1 {
  font-family:'Cinzel',serif;
  font-size: clamp(36px, 8vw, 56px);
  font-weight:900;
  background: linear-gradient(135deg, var(--gold), #f0d78c, var(--gold));
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  letter-spacing:8px;
  text-shadow:0 2px 20px var(--gold-glow);
  text-transform: uppercase;
}
.title-sub {
  color: var(--text-dim);
  font-size:13px;
  letter-spacing:4px;
  text-transform:uppercase;
  font-weight:300;
  margin-bottom:40px;
}
.title-label {
  color: var(--text-dim);
  font-size:12px;
  letter-spacing:2px;
  text-transform:uppercase;
  margin-bottom:10px;
}
.player-select {
  display:flex; gap:10px; margin-bottom:32px;
}
.player-btn {
  width:52px; height:52px; border-radius:12px;
  border:2px solid var(--border);
  background: rgba(255,255,255,0.03);
  color: var(--text-dim);
  font-size:20px; font-weight:700;
  font-family:'Cinzel',serif;
  transition: all .2s;
}
.player-btn.sel {
  border-color: var(--gold);
  background: var(--gold-dim);
  color: var(--gold);
}
.start-btn {
  padding:14px 52px;
  font-size:16px; font-weight:700;
  letter-spacing:4px;
  background:linear-gradient(135deg, #8b2020, var(--red));
  color:#fff;
  border-radius:12px;
  font-family:'Cinzel',serif;
  box-shadow:0 4px 24px rgba(192,57,43,.35);
  text-transform:uppercase;
}
.back-link {
  position:absolute; top:20px; left:20px;
  color: var(--text-dim);
  text-decoration:none;
  font-size:13px;
  letter-spacing:1px;
  transition: color .2s;
}
.back-link:hover { color: var(--gold); }

/* â”€â”€â”€ Game Screen â”€â”€â”€ */
#game-screen {
  justify-content: flex-start;
  padding: 8px 10px;
  gap: 0;
  min-height: 100vh;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PLAYING CARDS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.card {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-radius);
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: 'Cinzel', serif;
  font-weight: 700;
  position: relative;
  flex-shrink: 0;
  transition: transform .15s, box-shadow .15s, outline .15s;
}
.card-face {
  background: linear-gradient(145deg, #f5f2ea, #e8e2d4);
  border: 1px solid rgba(0,0,0,0.12);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8);
  color: #1a1a1a;
  cursor: pointer;
}
.card-face.red { color: #b22222; }
.card-face .card-rank { font-size:18px; line-height:1; }
.card-face .card-suit { font-size:22px; line-height:1; margin-top:2px; }
.card-face .card-corner {
  position:absolute; font-size:10px; line-height:1;
}
.card-face .card-corner.tl { top:4px; left:5px; }
.card-face .card-corner.br { bottom:4px; right:5px; transform:rotate(180deg); }

.card-back {
  background: linear-gradient(145deg, #1a3a6a, #0f2544);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
}
.card-back::after {
  content:'';
  width: 48px; height: 68px;
  border-radius: 4px;
  border: 1.5px solid rgba(212,168,67,0.3);
  background: repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(212,168,67,0.06) 3px, rgba(212,168,67,0.06) 6px);
}

.card.selectable:hover {
  transform: translateY(-8px);
  box-shadow: 0 8px 24px rgba(212,168,67,0.25);
  z-index: 10;
}
.card.selected {
  transform: translateY(-12px);
  outline: 2px solid var(--gold);
  box-shadow: 0 8px 20px var(--gold-glow);
  z-index: 10;
}
.card.not-playable { opacity: 0.5; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME TABLE LAYOUT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.opponents-row {
  display:flex;
  justify-content:center;
  gap: 20px;
  flex-wrap: wrap;
  width: 100%;
  padding: 4px 0;
}
.opponent-zone {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 8px 12px;
  text-align: center;
  min-width: 160px;
  max-width: 220px;
  flex: 1;
}
.opponent-name {
  font-family:'Cinzel',serif;
  font-size: 12px;
  color: var(--text-dim);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 6px;
}
.opponent-name.active-turn {
  color: var(--gold);
  text-shadow: 0 0 10px var(--gold-glow);
}
.opponent-name .hand-count {
  color: var(--text-dim);
  font-family: 'Outfit', sans-serif;
  font-size: 10px;
  font-weight: 400;
}
.opponent-table-cards {
  display:flex; gap:4px; justify-content:center;
}
.opp-stack {
  position: relative;
  width: 44px;
  height: 62px;
}
.opp-stack .card {
  --card-w: 44px;
  --card-h: 62px;
  --card-radius: 5px;
  position: absolute;
  top: 0; left: 0;
}
.opp-stack .card-face .card-rank { font-size:12px; }
.opp-stack .card-face .card-suit { font-size:14px; }
.opp-stack .card-face .card-corner { font-size:7px; }
.opp-stack .card-back::after { width:30px; height:42px; }

/* â”€â”€â”€ Center Play Area â”€â”€â”€ */
.center-area {
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 24px;
  padding: 12px 0;
  flex: 1;
  width: 100%;
  min-height: 140px;
}
.pile-zone {
  display:flex; flex-direction:column; align-items:center; gap:6px;
}
.pile-label {
  font-size:10px; color:var(--text-dim); letter-spacing:1.5px; text-transform:uppercase;
}
.pile-cards {
  position:relative;
  width: var(--card-w);
  height: var(--card-h);
}
.pile-cards .card {
  position:absolute; top:0; left:0;
}
.pile-placeholder {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-radius);
  border: 2px dashed rgba(255,255,255,0.08);
  display:flex; align-items:center; justify-content:center;
  font-size:10px; color:var(--text-dim); letter-spacing:1px;
}
.pile-count {
  font-size:11px; color:var(--text-dim); font-weight:500;
}

/* â”€â”€â”€ Action area â”€â”€â”€ */
.action-bar {
  display:flex; align-items:center; justify-content:center; gap:10px;
  padding: 6px 0;
  min-height: 42px;
}
.action-btn {
  padding: 8px 24px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.btn-play {
  background: linear-gradient(135deg, #1a6b3a, var(--green));
  color: #fff;
  box-shadow: 0 2px 12px rgba(46,204,113,0.3);
}
.btn-pickup {
  background: linear-gradient(135deg, #8b2020, var(--red));
  color: #fff;
  box-shadow: 0 2px 12px rgba(192,57,43,0.3);
}
.btn-confirm-swap {
  background: linear-gradient(135deg, #1a5a8b, var(--blue));
  color: #fff;
  box-shadow: 0 2px 12px rgba(52,152,219,0.3);
}

/* â”€â”€â”€ Player Zone â”€â”€â”€ */
.player-zone {
  width: 100%;
  padding: 4px 0 8px;
  text-align: center;
}
.player-label {
  font-family:'Cinzel',serif;
  font-size: 12px;
  color: var(--text-dim);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 4px;
}
.player-label.active-turn {
  color: var(--gold);
  text-shadow: 0 0 10px var(--gold-glow);
}
.player-table-cards {
  display:flex; gap:8px; justify-content:center; margin-bottom: 8px;
}
.player-stack {
  position:relative;
  width: var(--card-w);
  height: var(--card-h);
}
.player-stack .card {
  position:absolute; top:0; left:0;
}
.player-hand {
  display:flex;
  gap: 4px;
  justify-content:center;
  flex-wrap: wrap;
  padding: 4px 8px;
  min-height: calc(var(--card-h) + 16px);
}

/* â”€â”€â”€ Message overlay â”€â”€â”€ */
.game-message {
  position:fixed;
  top: 50%; left:50%;
  transform: translate(-50%,-50%);
  background: rgba(10,12,18,0.95);
  border: 1px solid var(--gold);
  border-radius: 16px;
  padding: 32px 48px;
  text-align:center;
  z-index:100;
  box-shadow: 0 0 60px rgba(212,168,67,0.15);
  display:none;
}
.game-message.show { display:block; animation: fadeIn .3s ease; }
.game-message h2 {
  font-family:'Cinzel',serif;
  font-size: 28px;
  color: var(--gold);
  letter-spacing: 4px;
  margin-bottom: 8px;
}
.game-message p { color: var(--text-dim); margin-bottom: 20px; font-size:14px; }
.game-message button {
  padding: 10px 36px;
  font-family:'Cinzel',serif;
  font-size:14px; font-weight:700;
  letter-spacing:3px;
  text-transform:uppercase;
  background:linear-gradient(135deg,#8b2020,var(--red));
  color:#fff; border-radius:10px;
  box-shadow:0 4px 20px rgba(192,57,43,.3);
}

/* â”€â”€â”€ Toast notification â”€â”€â”€ */
.toast {
  position:fixed;
  top: 16px; left:50%;
  transform: translateX(-50%) translateY(-60px);
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 10px 24px;
  font-size: 13px;
  color: var(--text-bright);
  letter-spacing: 0.5px;
  z-index: 200;
  opacity:0;
  transition: all .3s ease;
  pointer-events:none;
  white-space: nowrap;
}
.toast.show {
  transform: translateX(-50%) translateY(0);
  opacity:1;
}

/* â”€â”€â”€ Swap phase banner â”€â”€â”€ */
.swap-banner {
  background: var(--gold-dim);
  border: 1px solid rgba(212,168,67,0.25);
  border-radius: 10px;
  padding: 8px 16px;
  font-size: 12px;
  color: var(--gold);
  letter-spacing: 1px;
  text-align:center;
  width: 100%;
  max-width: 500px;
}

/* â”€â”€â”€ Status bar â”€â”€â”€ */
.status-bar {
  font-size: 11px;
  color: var(--text-dim);
  letter-spacing: 1px;
  padding: 4px 0;
  text-align: center;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME OVER SCREEN
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#gameover-screen {
  background: radial-gradient(ellipse at 50% 40%, #1a1520 0%, #0a0c12 70%);
  gap: 12px;
}
#gameover-screen h1 {
  font-family:'Cinzel',serif;
  font-size: 40px;
  font-weight:900;
  letter-spacing:6px;
}
#gameover-screen .loser-name {
  font-size: 20px;
  color: var(--text-dim);
  letter-spacing: 3px;
  margin-bottom: 8px;
}
#gameover-screen .subtitle {
  color: var(--text-dim);
  font-size: 13px;
  margin-bottom: 32px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ANIMATIONS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
@keyframes popIn { 0%{transform:scale(0.8);opacity:0} 100%{transform:scale(1);opacity:1} }
.card { animation: popIn .2s ease both; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESPONSIVE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@media (max-width:600px) {
  :root { --card-w:58px; --card-h:84px; }
  .opponent-zone { min-width:120px; padding:6px 8px; }
  .opp-stack { width:36px; height:52px; }
  .opp-stack .card { --card-w:36px; --card-h:52px; }
  .opp-stack .card-face .card-rank { font-size:10px; }
  .opp-stack .card-face .card-suit { font-size:11px; }
  .opp-stack .card-back::after { width:24px; height:34px; }
  .player-hand { gap:2px; }
  .center-area { gap:14px; min-height:110px; }
  .opponents-row { gap:8px; }
}
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     TITLE SCREEN
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="title-screen" class="screen active">
  <a href="../../index.html" class="back-link">â† Game Hub</a>
  <h1>Barstard</h1>
  <div class="title-sub">The Classic Shedding Game</div>
  <div class="title-label">Number of Players</div>
  <div class="player-select" id="player-select">
    <button class="player-btn" data-count="2">2</button>
    <button class="player-btn sel" data-count="3">3</button>
    <button class="player-btn" data-count="4">4</button>
    <button class="player-btn" data-count="5">5</button>
  </div>
  <button class="start-btn" onclick="startGame()">Deal</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME SCREEN
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="game-screen" class="screen">
  <div class="opponents-row" id="opponents-row"></div>
  <div class="status-bar" id="status-bar"></div>
  <div class="center-area">
    <div class="pile-zone">
      <div class="pile-label">Draw</div>
      <div class="pile-cards" id="draw-pile"></div>
      <div class="pile-count" id="draw-count"></div>
    </div>
    <div class="pile-zone">
      <div class="pile-label">Discard</div>
      <div class="pile-cards" id="discard-pile"></div>
      <div class="pile-count" id="discard-count"></div>
    </div>
  </div>
  <div class="action-bar" id="action-bar"></div>
  <div class="player-zone" id="player-zone"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME OVER SCREEN
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="gameover-screen" class="screen">
  <h1 id="go-title"></h1>
  <div class="loser-name" id="go-loser"></div>
  <div class="subtitle" id="go-subtitle"></div>
  <button class="start-btn" onclick="backToTitle()">Play Again</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     TOAST
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="toast" id="toast"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME LOGIC
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   CONSTANTS & UTILITY
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SUITS = ['â™ ','â™¥','â™¦','â™£'];
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const RANK_VALUE = {2:15, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, 10:14, J:11, Q:12, K:13, A:14};
// 2=15 (highest for play-on-anything), 10=14 (special), A=14
const AI_NAMES = ['Caesar','Brutus','Nero','Cleo'];
const isRed = s => s === 'â™¥' || s === 'â™¦';

function makeCard(rank, suit) { return { rank, suit, id: rank + suit }; }
function makeDeck() {
  const d = [];
  for (const s of SUITS) for (const r of RANKS) d.push(makeCard(r, s));
  return d;
}
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   GAME STATE
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let G = {}; // global game state

function initState(numPlayers) {
  const deck = shuffle(makeDeck());
  const players = [];
  for (let i = 0; i < numPlayers; i++) {
    players.push({
      name: i === 0 ? 'You' : AI_NAMES[i - 1],
      isHuman: i === 0,
      faceDown: [],
      faceUp: [],
      hand: [],
      out: false,
    });
  }
  // Deal: 3 face-down, 3 face-up, 3 hand
  for (let round = 0; round < 3; round++)
    for (const p of players) p.faceDown.push(deck.pop());
  for (let round = 0; round < 3; round++)
    for (const p of players) p.faceUp.push(deck.pop());
  for (let round = 0; round < 3; round++)
    for (const p of players) p.hand.push(deck.pop());

  G = {
    players,
    drawPile: deck,
    discardPile: [],
    burnPile: [],
    currentPlayer: 0,
    phase: 'swap', // swap | play | gameover
    selectedCards: [],
    swapSource: null, // {zone, index}
    direction: 1,
    activePlayers: players.length,
    turnOrder: [], // computed after swap
  };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   CARD PLAY RULES
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function topDiscard() {
  return G.discardPile.length > 0 ? G.discardPile[G.discardPile.length - 1] : null;
}

function canPlayCard(card) {
  if (card.rank === '2') return true;   // 2 plays on anything
  if (card.rank === '10') return true;  // 10 plays on anything
  const top = topDiscard();
  if (!top) return true;                // empty pile
  if (top.rank === '2') return true;    // anything plays on a 2
  return RANK_VALUE[card.rank] >= RANK_VALUE[top.rank];
}

function canPlaySet(cards) {
  if (cards.length === 0) return false;
  const rank = cards[0].rank;
  if (!cards.every(c => c.rank === rank)) return false;
  return canPlayCard(cards[0]);
}

function checkFourOfAKind() {
  if (G.discardPile.length < 4) return false;
  const top4 = G.discardPile.slice(-4);
  return top4.every(c => c.rank === top4[0].rank);
}

function burnPile() {
  G.burnPile.push(...G.discardPile);
  G.discardPile = [];
}

function replenishHand(player) {
  while (player.hand.length < 3 && G.drawPile.length > 0) {
    player.hand.push(G.drawPile.pop());
  }
}

function getPlayableSource(player) {
  // What source should this player play from?
  if (player.hand.length > 0) return 'hand';
  if (player.faceUp.length > 0) return 'faceUp';
  if (player.faceDown.length > 0) return 'faceDown';
  return null;
}

function isPlayerDone(player) {
  return player.hand.length === 0 && player.faceUp.length === 0 && player.faceDown.length === 0;
}

function findFirstPlayer() {
  // First 3 face-up, then first 3 in hand, then 4, etc.
  for (let r = 1; r < RANKS.length; r++) { // start from 3
    const rank = RANKS[r];
    // Check face-up
    for (let i = 0; i < G.players.length; i++) {
      if (G.players[i].faceUp.some(c => c.rank === rank)) return i;
    }
    // Check hand
    for (let i = 0; i < G.players.length; i++) {
      if (G.players[i].hand.some(c => c.rank === rank)) return i;
    }
  }
  return 0;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   AI LOGIC
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function aiChooseCards(player) {
  const source = getPlayableSource(player);
  if (!source) return null;

  if (source === 'faceDown') {
    // Blind play: just pick one randomly
    return { source: 'faceDown', indices: [0] };
  }

  const cards = source === 'hand' ? player.hand : player.faceUp;
  // Group by rank, find playable groups
  const byRank = {};
  cards.forEach((c, i) => {
    if (!byRank[c.rank]) byRank[c.rank] = [];
    byRank[c.rank].push(i);
  });

  // Find playable ranks, sorted by value (play lowest first)
  const playableRanks = Object.entries(byRank)
    .filter(([rank]) => canPlayCard(makeCard(rank, 'â™ ')))
    .sort((a, b) => RANK_VALUE[a[0]] - RANK_VALUE[b[0]]);

  if (playableRanks.length === 0) return null; // must pick up

  // Strategy: prefer to play lowest card, but play 10 to burn if pile is large
  if (G.discardPile.length >= 5) {
    const tenEntry = playableRanks.find(([r]) => r === '10');
    if (tenEntry) return { source, indices: [tenEntry[1][0]] };
  }

  // Try to complete four-of-a-kind if possible
  for (const [rank, indices] of playableRanks) {
    if (rank === '2' || rank === '10') continue; // save specials
    const topCount = G.discardPile.length > 0 ?
      [...G.discardPile].reverse().findIndex(c => c.rank !== rank) : 0;
    const onPile = topCount === -1 ? G.discardPile.length : topCount;
    if (onPile + indices.length >= 4) {
      return { source, indices };
    }
  }

  // Play lowest rank (skip 2s/10s if possible unless nothing else)
  for (const [rank, indices] of playableRanks) {
    if (rank !== '2' && rank !== '10') {
      return { source, indices };
    }
  }
  // Only specials left
  return { source, indices: [playableRanks[0][1][0]] };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   GAME FLOW
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function nextPlayer() {
  let next = G.currentPlayer;
  const total = G.players.length;
  for (let i = 0; i < total; i++) {
    next = (next + G.direction + total) % total;
    if (!G.players[next].out) return next;
  }
  return G.currentPlayer;
}

function checkGameOver() {
  const remaining = G.players.filter(p => !p.out);
  if (remaining.length <= 1) {
    G.phase = 'gameover';
    const loser = remaining[0] || G.players[G.currentPlayer];
    showGameOver(loser);
    return true;
  }
  return false;
}

function executePlay(playerIdx, cardIndices, source) {
  const player = G.players[playerIdx];
  const srcArr = source === 'hand' ? player.hand :
                 source === 'faceUp' ? player.faceUp : player.faceDown;

  // Get cards (sorted indices desc for safe splice)
  const sorted = [...cardIndices].sort((a, b) => b - a);
  const played = sorted.map(i => srcArr[i]);
  sorted.forEach(i => srcArr.splice(i, 1));

  // For face-down blind play, check if playable
  if (source === 'faceDown') {
    const card = played[0];
    if (!canPlayCard(card)) {
      // Not playable â€” card goes on pile, then pick up everything
      G.discardPile.push(card);
      player.hand.push(...G.discardPile);
      G.discardPile = [];
      replenishHand(player);
      return { burned: false, blindFail: true };
    }
  }

  // Add to discard
  G.discardPile.push(...played);
  replenishHand(player);

  // Check 10 â€” burn
  if (played[0].rank === '10') {
    burnPile();
    return { burned: true, samePlayer: true };
  }

  // Check four of a kind
  if (checkFourOfAKind()) {
    burnPile();
    return { burned: true, samePlayer: true };
  }

  return { burned: false, samePlayer: false };
}

function doPickup(playerIdx) {
  const player = G.players[playerIdx];
  player.hand.push(...G.discardPile);
  G.discardPile = [];
}

async function advanceTurn(samePlayer = false) {
  if (G.phase !== 'play') return;

  // Check if current player is done
  const cur = G.players[G.currentPlayer];
  if (isPlayerDone(cur)) {
    cur.out = true;
    G.activePlayers--;
    if (checkGameOver()) return;
  }

  if (!samePlayer) {
    G.currentPlayer = nextPlayer();
  } else {
    // Same player goes again, but check if they're out
    if (cur.out) {
      G.currentPlayer = nextPlayer();
    }
  }

  G.selectedCards = [];
  render();

  // If AI turn, play after delay
  if (!G.players[G.currentPlayer].isHuman && !G.players[G.currentPlayer].out) {
    await delay(800);
    await aiTurn();
  }
}

async function aiTurn() {
  if (G.phase !== 'play') return;
  const player = G.players[G.currentPlayer];
  const choice = aiChooseCards(player);

  if (!choice) {
    // Pick up pile
    doPickup(G.currentPlayer);
    showToast(`${player.name} picks up the pile!`);
    render();
    await delay(400);
    await advanceTurn(false);
    return;
  }

  const result = executePlay(G.currentPlayer, choice.indices, choice.source);

  if (result.blindFail) {
    showToast(`${player.name} flips blind â€” bad luck! Picks up!`);
    render();
    await delay(600);
    await advanceTurn(false);
    return;
  }

  const playedRank = choice.source === 'faceDown' ? '?' :
    (choice.source === 'hand' ? 'cards' : 'table cards');
  if (result.burned) {
    showToast(`${player.name} burns the pile! ğŸ”¥`);
  }

  render();
  await delay(400);
  await advanceTurn(result.samePlayer);
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   HUMAN INTERACTION
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function humanSelectCard(source, index) {
  if (G.phase === 'swap') {
    handleSwapClick(source, index);
    return;
  }
  if (G.phase !== 'play') return;
  if (G.currentPlayer !== 0) return;
  const player = G.players[0];
  const playSource = getPlayableSource(player);
  if (source !== playSource) return;

  if (source === 'faceDown') {
    // Blind play â€” just play it
    const result = executePlay(0, [index], 'faceDown');
    if (result.blindFail) {
      showToast("Bad luck! Card can't play â€” pick up the pile!");
    }
    render();
    advanceTurn(result.samePlayer || false);
    return;
  }

  const cards = source === 'hand' ? player.hand : player.faceUp;
  const card = cards[index];

  // Toggle selection
  const selIdx = G.selectedCards.findIndex(s => s.index === index);
  if (selIdx >= 0) {
    G.selectedCards.splice(selIdx, 1);
  } else {
    // Only allow same rank
    if (G.selectedCards.length > 0) {
      const firstCard = cards[G.selectedCards[0].index];
      if (card.rank !== firstCard.rank) {
        G.selectedCards = [];
      }
    }
    G.selectedCards.push({ index, source });
  }
  render();
}

function humanPlay() {
  if (G.phase !== 'play' || G.currentPlayer !== 0) return;
  if (G.selectedCards.length === 0) return;

  const player = G.players[0];
  const source = G.selectedCards[0].source;
  const indices = G.selectedCards.map(s => s.index);
  const srcArr = source === 'hand' ? player.hand : player.faceUp;
  const cards = indices.map(i => srcArr[i]);

  if (!canPlaySet(cards)) {
    showToast("Can't play that!");
    return;
  }

  const result = executePlay(0, indices, source);
  G.selectedCards = [];

  if (result.burned) {
    showToast("Pile burned! ğŸ”¥ Your turn again!");
  }

  render();
  advanceTurn(result.samePlayer);
}

function humanPickup() {
  if (G.phase !== 'play' || G.currentPlayer !== 0) return;
  if (G.discardPile.length === 0) {
    showToast("Nothing to pick up!");
    return;
  }
  doPickup(0);
  G.selectedCards = [];
  showToast("Picked up the pile...");
  render();
  advanceTurn(false);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SWAP PHASE
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function handleSwapClick(source, index) {
  if (source !== 'hand' && source !== 'faceUp') return;
  if (!G.swapSource) {
    G.swapSource = { source, index };
    G.selectedCards = [{ source, index }];
  } else if (G.swapSource.source === source && G.swapSource.index === index) {
    // Deselect
    G.swapSource = null;
    G.selectedCards = [];
  } else {
    // Swap the two cards
    const player = G.players[0];
    const src1 = G.swapSource.source === 'hand' ? player.hand : player.faceUp;
    const src2 = source === 'hand' ? player.hand : player.faceUp;
    const temp = src1[G.swapSource.index];
    src1[G.swapSource.index] = src2[index];
    src2[index] = temp;
    G.swapSource = null;
    G.selectedCards = [];
  }
  render();
}

function finishSwap() {
  // AI also "swaps" â€” simple: move lower cards from face-up to hand
  for (let i = 1; i < G.players.length; i++) {
    const p = G.players[i];
    // Swap hand cards with face-up if face-up is lower
    for (let h = 0; h < p.hand.length; h++) {
      for (let f = 0; f < p.faceUp.length; f++) {
        if (RANK_VALUE[p.hand[h].rank] > RANK_VALUE[p.faceUp[f].rank]) {
          // Swap: put higher card face-up, lower in hand (wait, we want high face-up)
          // Actually strategy: put HIGH cards face-up, low in hand to play first
          // Correction: you play hand first, so you want LOW cards in hand & HIGH face-up
          // No wait â€” you want to put good cards face-up since you play hand first
          // The standard strategy is to put LOW face-up cards INTO hand
          // so face-up has high cards (they're played later when you need them)
        }
      }
    }
    // Simple: sort combined, put 3 highest face-up, rest in hand
    const all = [...p.hand, ...p.faceUp];
    all.sort((a, b) => RANK_VALUE[b.rank] - RANK_VALUE[a.rank]);
    p.faceUp = all.slice(0, 3);
    p.hand = all.slice(3);
  }

  G.phase = 'play';
  G.currentPlayer = findFirstPlayer();
  G.selectedCards = [];
  G.swapSource = null;
  render();

  // If AI goes first
  if (G.currentPlayer !== 0) {
    delay(600).then(() => aiTurn());
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   RENDERING
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function cardHTML(card, opts = {}) {
  const { faceDown = false, selectable = false, selected = false, small = false, clickData = '' } = opts;
  if (faceDown) {
    return `<div class="card card-back ${selectable ? 'selectable' : ''}" ${clickData}></div>`;
  }
  const red = isRed(card.suit) ? ' red' : '';
  const selClass = selected ? ' selected' : (selectable ? ' selectable' : '');
  const playable = (G.phase === 'play' && selectable && !canPlayCard(card) && getPlayableSource(G.players[0]) !== 'faceDown') ? ' not-playable' : '';
  return `<div class="card card-face${red}${selClass}${playable}" ${clickData}>
    <span class="card-corner tl">${card.rank}${card.suit}</span>
    <span class="card-rank">${card.rank}</span>
    <span class="card-suit">${card.suit}</span>
    <span class="card-corner br">${card.rank}${card.suit}</span>
  </div>`;
}

function render() {
  renderOpponents();
  renderCenter();
  renderPlayer();
  renderActions();
  renderStatus();
}

function renderOpponents() {
  const row = document.getElementById('opponents-row');
  let html = '';
  for (let i = 1; i < G.players.length; i++) {
    const p = G.players[i];
    if (p.out) continue;
    const isActive = G.currentPlayer === i && G.phase === 'play';
    const handInfo = p.hand.length > 0 ? ` <span class="hand-count">(${p.hand.length} in hand)</span>` : '';
    html += `<div class="opponent-zone">
      <div class="opponent-name ${isActive ? 'active-turn' : ''}">${p.name}${handInfo}</div>
      <div class="opponent-table-cards">`;
    for (let j = 0; j < 3; j++) {
      html += `<div class="opp-stack">`;
      // Face-down
      if (j < p.faceDown.length) {
        html += `<div class="card card-back"></div>`;
      }
      // Face-up on top
      if (j < p.faceUp.length) {
        html += cardHTML(p.faceUp[j]);
      }
      html += `</div>`;
    }
    html += `</div></div>`;
  }
  row.innerHTML = html;
}

function renderCenter() {
  // Draw pile
  const drawEl = document.getElementById('draw-pile');
  const drawCountEl = document.getElementById('draw-count');
  if (G.drawPile.length > 0) {
    drawEl.innerHTML = `<div class="card card-back"></div>`;
    drawCountEl.textContent = G.drawPile.length;
  } else {
    drawEl.innerHTML = `<div class="pile-placeholder">Empty</div>`;
    drawCountEl.textContent = '';
  }

  // Discard pile
  const discEl = document.getElementById('discard-pile');
  const discCountEl = document.getElementById('discard-count');
  const top = topDiscard();
  if (top) {
    // Show top 1-2 cards for depth feel
    let html = '';
    const showCount = Math.min(G.discardPile.length, 3);
    for (let i = G.discardPile.length - showCount; i < G.discardPile.length; i++) {
      const offset = (i - (G.discardPile.length - showCount)) * 2;
      const c = G.discardPile[i];
      const red = isRed(c.suit) ? ' red' : '';
      html += `<div class="card card-face${red}" style="top:${offset}px;left:${offset}px;">
        <span class="card-corner tl">${c.rank}${c.suit}</span>
        <span class="card-rank">${c.rank}</span>
        <span class="card-suit">${c.suit}</span>
        <span class="card-corner br">${c.rank}${c.suit}</span>
      </div>`;
    }
    discEl.innerHTML = html;
    discCountEl.textContent = G.discardPile.length;
  } else {
    discEl.innerHTML = `<div class="pile-placeholder">Empty</div>`;
    discCountEl.textContent = '';
  }
}

function renderPlayer() {
  const zone = document.getElementById('player-zone');
  const p = G.players[0];
  const isMyTurn = G.currentPlayer === 0 && G.phase === 'play';
  const playSource = getPlayableSource(p);
  const isSwap = G.phase === 'swap';

  let html = `<div class="player-label ${isMyTurn ? 'active-turn' : ''}">${p.out ? 'You\'re out! ğŸ‰' : (isMyTurn ? 'âš” Your Turn' : 'You')}</div>`;

  // Table cards (face-down + face-up stacks)
  html += `<div class="player-table-cards">`;
  for (let j = 0; j < 3; j++) {
    html += `<div class="player-stack">`;
    if (j < p.faceDown.length) {
      const canClick = (isMyTurn && playSource === 'faceDown') || false;
      html += `<div class="card card-back ${canClick ? 'selectable' : ''}"
        ${canClick ? `onclick="humanSelectCard('faceDown',${j})"` : ''}></div>`;
    }
    if (j < p.faceUp.length) {
      const canClick = (isMyTurn && playSource === 'faceUp') || isSwap;
      const sel = G.selectedCards.some(s => s.source === 'faceUp' && s.index === j);
      html += cardHTML(p.faceUp[j], {
        selectable: canClick,
        selected: sel,
        clickData: canClick ? `onclick="humanSelectCard('faceUp',${j})"` : '',
      });
    }
    html += `</div>`;
  }
  html += `</div>`;

  // Hand
  html += `<div class="player-hand">`;
  const canClickHand = (isMyTurn && playSource === 'hand') || isSwap;
  for (let i = 0; i < p.hand.length; i++) {
    const sel = G.selectedCards.some(s => s.source === 'hand' && s.index === i);
    html += cardHTML(p.hand[i], {
      selectable: canClickHand,
      selected: sel,
      clickData: canClickHand ? `onclick="humanSelectCard('hand',${i})"` : '',
    });
  }
  html += `</div>`;

  zone.innerHTML = html;
}

function renderActions() {
  const bar = document.getElementById('action-bar');
  if (G.phase === 'swap') {
    bar.innerHTML = `
      <div class="swap-banner">Tap a hand card then a face-up card to swap them. Place your best cards face-up!</div>
      <button class="action-btn btn-confirm-swap" onclick="finishSwap()">Ready â€” Deal!</button>`;
    return;
  }
  if (G.phase !== 'play' || G.currentPlayer !== 0 || G.players[0].out) {
    bar.innerHTML = '';
    return;
  }
  const hasSelection = G.selectedCards.length > 0;
  const source = getPlayableSource(G.players[0]);
  bar.innerHTML = `
    ${source !== 'faceDown' ? `<button class="action-btn btn-play" ${hasSelection ? '' : 'disabled'} onclick="humanPlay()">Play</button>` : ''}
    <button class="action-btn btn-pickup" onclick="humanPickup()">Pick Up</button>`;
}

function renderStatus() {
  const bar = document.getElementById('status-bar');
  if (G.phase === 'swap') {
    bar.textContent = 'Swap Phase â€” arrange your cards before play begins';
    return;
  }
  if (G.phase === 'gameover') {
    bar.textContent = '';
    return;
  }
  const cp = G.players[G.currentPlayer];
  const src = getPlayableSource(cp);
  const srcLabel = src === 'faceDown' ? '(blind flip!)' : src === 'faceUp' ? '(table cards)' : '';
  if (cp.isHuman) {
    bar.textContent = `Your turn ${srcLabel}`;
  } else {
    bar.textContent = `${cp.name} is thinking...`;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TOAST
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let toastTimer = null;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.classList.remove('show'), 2000);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   GAME OVER
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function showGameOver(loser) {
  document.getElementById('game-screen').classList.remove('active');
  const screen = document.getElementById('gameover-screen');
  screen.classList.add('active');

  if (loser.isHuman) {
    document.getElementById('go-title').textContent = 'BARSTARD!';
    document.getElementById('go-title').style.color = 'var(--red)';
    document.getElementById('go-loser').textContent = "You're the Barstard!";
    document.getElementById('go-subtitle').textContent = 'Better luck next time... now go make the tea.';
  } else {
    document.getElementById('go-title').textContent = 'VICTORY!';
    document.getElementById('go-title').style.color = 'var(--gold)';
    document.getElementById('go-loser').textContent = `${loser.name} is the Barstard!`;
    document.getElementById('go-subtitle').textContent = 'They shuffle and deal next round.';
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SCREEN MANAGEMENT
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function startGame() {
  const count = parseInt(document.querySelector('.player-btn.sel').dataset.count);
  initState(count);
  showScreen('game-screen');
  render();
}

function backToTitle() {
  showScreen('title-screen');
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   PLAYER SELECT BUTTONS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.querySelectorAll('.player-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.player-btn').forEach(b => b.classList.remove('sel'));
    btn.classList.add('sel');
  });
});
</script>
</body>
</html>
