<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Glory to Rome</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Source+Sans+3:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0f1118;
  --panel: #171b24;
  --border: rgba(255,255,255,0.08);
  --gold: #c9a84c;
  --gold-dim: rgba(201,168,76,0.15);
  --cream: #f5f0e1;
  --text: #d4c9b8;
  --text-dim: rgba(255,255,255,0.4);
  --wood: #2d8a4e;
  --rubble: #d4952e;
  --brick: #c0392b;
  --concrete: #7a8087;
  --stone: #00a4c6;
  --marble: #862d86;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:'Cormorant Garamond',Georgia,serif; min-height:100vh; overflow-x:hidden; }
button { font-family:'Source Sans 3','Segoe UI',sans-serif; cursor:pointer; transition:all .15s; }
button:hover:not(:disabled) { filter:brightness(1.15); transform:translateY(-1px); }
button:disabled { opacity:.4; cursor:not-allowed; }
::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:rgba(255,255,255,.1); border-radius:3px; }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.4} }
@keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
.screen { display:none; min-height:100vh; }
.screen.active { display:flex; }

/* Title */
#title-screen { flex-direction:column; align-items:center; justify-content:center;
  background:radial-gradient(ellipse at 50% 30%, #1a1520 0%, #0d0b0e 70%); }
#title-screen h1 { font-family:'Cinzel',serif; font-size:52px; font-weight:900; color:var(--gold);
  letter-spacing:8px; text-shadow:0 2px 20px rgba(201,168,76,.3); margin-bottom:4px; }
#title-screen .sub { color:rgba(255,255,255,.35); font-size:14px; letter-spacing:4px; margin-bottom:48px; font-family:'Source Sans 3',sans-serif; }
.ai-select { display:flex; gap:12px; margin-bottom:36px; }
.ai-btn { width:56px; height:56px; border-radius:12px; border:2px solid rgba(255,255,255,.15);
  background:rgba(255,255,255,.04); color:#aaa; font-size:22px; font-weight:700; font-family:'Cinzel',serif; }
.ai-btn.sel { border-color:var(--gold); background:var(--gold-dim); color:var(--gold); }
.start-btn { padding:14px 56px; font-size:18px; font-weight:700; letter-spacing:4px;
  background:linear-gradient(135deg,#8b2020,#c0392b); color:#fff; border:none; border-radius:12px;
  font-family:'Cinzel',serif; box-shadow:0 4px 24px rgba(192,57,43,.4); }
.note { color:rgba(255,255,255,.25); font-size:11px; margin-top:28px; max-width:400px; text-align:center; line-height:1.6; }

/* Game Layout */
#game-screen { flex-direction:column; }
.game-header { background:rgba(0,0,0,.35); padding:8px 16px; display:flex; justify-content:space-between; align-items:center;
  border-bottom:1px solid rgba(201,168,76,.12); }
.game-header .title { display:flex; align-items:center; gap:10px; }
.game-header .title span:first-child { font-size:20px; }
.game-header .title .name { color:var(--gold); font-weight:700; font-size:14px; letter-spacing:2px; font-family:'Cinzel',serif; }
.game-header .title .turn { color:var(--text-dim); font-size:11px; }
.game-header .stats { display:flex; gap:14px; font-size:11px; color:rgba(255,255,255,.45); }
.game-body { display:flex; flex:1; overflow:hidden; height:calc(100vh - 40px); }

/* Left Panel */
.left-panel { width:280px; padding:8px; overflow-y:auto; border-right:1px solid var(--border); background:rgba(0,0,0,.15); }
.player-panel { background:rgba(255,255,255,.025); border:1px solid var(--border); border-radius:10px; padding:10px; margin-bottom:6px; }
.player-panel.leader { background:rgba(201,168,76,.06); border-color:rgba(201,168,76,.2); }
.player-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; }
.player-name { display:flex; align-items:center; gap:6px; font-weight:700; font-size:13px; color:#ddd; }
.leader-badge { background:rgba(201,168,76,.2); color:var(--gold); font-size:8px; padding:2px 6px; border-radius:4px;
  font-weight:700; letter-spacing:1px; font-family:'Source Sans 3',sans-serif; }
.player-stats { display:flex; gap:10px; font-size:10px; font-family:'Source Sans 3',sans-serif; }
.player-stats span { display:flex; align-items:center; gap:2px; }
.clients-row, .foundations-row, .completed-row { display:flex; gap:4px; flex-wrap:wrap; margin-bottom:4px; }
.client-chip { font-size:8px; padding:2px 5px; border-radius:3px; color:#fff; font-weight:600; font-family:'Source Sans 3',sans-serif; }
.completed-chip { font-size:8px; padding:2px 5px; border-radius:3px; background:rgba(39,174,96,.15);
  border:1px solid rgba(39,174,96,.4); color:#2ecc71; font-weight:600; font-family:'Source Sans 3',sans-serif; }
.empty-label { font-size:9px; color:rgba(255,255,255,.15); font-style:italic; }

/* Sites */
.sites-panel { margin-top:8px; padding:8px; background:rgba(255,255,255,.025); border-radius:8px; border:1px solid var(--border); }
.sites-title { font-size:9px; font-weight:700; color:var(--text-dim); letter-spacing:1.5px; margin-bottom:6px; font-family:'Source Sans 3',sans-serif; }
.sites-grid { display:flex; flex-wrap:wrap; gap:5px; }
.site-chip { font-size:9px; padding:3px 6px; border-radius:4px; font-weight:700; font-family:'Source Sans 3',sans-serif; }
.site-chip.depleted { opacity:.3; }

/* Center */
.center-panel { flex:1; display:flex; flex-direction:column; overflow:hidden; }
.pool-area { padding:8px 10px; background:rgba(255,255,255,.015); border-bottom:1px solid var(--border); }
.section-label { font-size:9px; font-weight:700; color:var(--text-dim); letter-spacing:1.5px; text-transform:uppercase;
  margin-bottom:5px; font-family:'Source Sans 3',sans-serif; }
.card-row { display:flex; gap:6px; flex-wrap:wrap; min-height:30px; align-items:flex-start; }

/* Action Panel */
.action-panel { flex:1; overflow-y:auto; padding:10px; }
.action-panel.active { background:rgba(201,168,76,.02); }
.action-title { font-size:14px; color:var(--gold); font-weight:700; margin-bottom:10px; font-family:'Cinzel',serif; }
.action-subtitle { font-size:11px; color:var(--text-dim); margin-bottom:6px; }
.action-btn { padding:8px 16px; border:none; border-radius:8px; font-size:12px; font-weight:600; color:#fff; margin-right:8px; margin-bottom:6px; }
.action-btn.skip { background:#555; }

/* Player area */
.player-area { padding:10px; background:rgba(0,0,0,.25); border-top:1px solid rgba(201,168,76,.1); }

/* Game Log */
.log-panel { width:220px; border-left:1px solid var(--border); display:flex; flex-direction:column; background:rgba(0,0,0,.1); }
.log-title { padding:8px 10px; font-size:9px; font-weight:700; color:var(--text-dim); letter-spacing:1.5px;
  border-bottom:1px solid var(--border); font-family:'Source Sans 3',sans-serif; }
.log-entries { flex:1; overflow-y:auto; padding:6px 8px; }
.log-entry { font-size:10px; line-height:1.5; padding:2px 0; color:rgba(255,255,255,.5); font-family:'Source Sans 3',sans-serif; }
.log-entry.turn { color:var(--gold); font-weight:700; border-bottom:1px solid rgba(201,168,76,.1); }
.log-entry.build { color:#2ecc71; }
.log-entry.end { color:#e74c3c; }

/* Foundation mini */
.foundation-mini { background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.1); border-radius:8px; padding:6px 8px; min-width:90px; }
.foundation-mini.clickable { cursor:pointer; }
.foundation-mini.clickable:hover { border-color:var(--gold); }
.foundation-mini .fname { font-size:10px; font-weight:700; }
.foundation-mini .finfo { font-size:9px; color:rgba(255,255,255,.4); }
.foundation-mini .fdots { display:flex; gap:2px; margin-top:3px; }
.foundation-mini .fdot { width:11px; height:11px; border-radius:3px; border:1px solid; }

/* Card Styling - matching the actual artwork */
.card {
  width:72px; height:100px; border-radius:6px; position:relative; overflow:hidden;
  flex-shrink:0; transition:all .15s; cursor:default;
  background:var(--cream); border:2px solid #d0c8b8;
  box-shadow:0 1px 4px rgba(0,0,0,.2);
}
.card.sm { width:56px; height:78px; }
.card.clickable { cursor:pointer; }
.card.clickable:hover { transform:translateY(-4px); box-shadow:0 4px 12px rgba(0,0,0,.3); }
.card.selected { transform:translateY(-4px); border-color:var(--gold); box-shadow:0 0 12px rgba(201,168,76,.5); }
.card.facedown {
  background:linear-gradient(135deg,#2c3e50,#34495e);
  border-color:#4a6785; display:flex; align-items:center; justify-content:center;
}
.card.facedown::after { content:'\1F3DB'; font-size:20px; opacity:.4; }

/* Card inner layout matching artwork */
.card-role-strip { position:absolute; left:0; top:0; bottom:0; width:16px;
  display:flex; flex-direction:column; align-items:center; padding-top:18px; gap:0; }
.card.sm .card-role-strip { width:12px; padding-top:14px; }
.card-role-letter { font-family:'Source Sans 3',sans-serif; font-weight:900; font-size:7px; line-height:8px; }
.card.sm .card-role-letter { font-size:5px; line-height:6px; }
.card-tool { position:absolute; top:3px; left:2px; font-size:10px; transform:rotate(-30deg); }
.card.sm .card-tool { font-size:7px; top:2px; left:1px; }
.card-name { position:absolute; top:4px; left:18px; right:16px; font-family:'Source Sans 3',sans-serif;
  font-weight:900; font-size:7px; color:#1a1a1a; text-transform:uppercase; letter-spacing:.5px; line-height:1.1; }
.card.sm .card-name { left:13px; right:12px; font-size:5.5px; top:3px; }
.card-dots { position:absolute; top:4px; right:3px; display:flex; flex-direction:column; gap:2px; }
.card.sm .card-dots { right:2px; top:3px; gap:1px; }
.card-dot { width:8px; height:8px; border-radius:50%; }
.card.sm .card-dot { width:5px; height:5px; }
.card-icon { position:absolute; top:50%; left:50%; transform:translate(-42%,-55%); font-size:22px; opacity:.7; }
.card.sm .card-icon { font-size:16px; }
.card-fn { position:absolute; bottom:14px; left:18px; right:4px; font-size:5.5px; color:#333;
  line-height:1.2; font-family:'Source Sans 3',sans-serif; }
.card.sm .card-fn { bottom:10px; left:13px; font-size:4.5px; }
.card-material { position:absolute; bottom:3px; right:4px; font-family:'Source Sans 3',sans-serif;
  font-weight:900; font-size:7px; letter-spacing:1px; }
.card.sm .card-material { font-size:5px; right:2px; bottom:2px; }
.card-coin { position:absolute; bottom:2px; left:18px; display:flex; gap:1px; }
.card.sm .card-coin { left:13px; }
.coin { width:9px; height:9px; border-radius:50%; border:1px solid #888; background:linear-gradient(135deg,#c9b87a,#a89050);
  display:flex; align-items:center; justify-content:center; font-size:4px; color:#6b5a30; }
.card.sm .coin { width:6px; height:6px; font-size:3px; }

/* Game Over */
.game-over { padding:24px; text-align:center; }
.game-over h2 { font-family:'Cinzel',serif; color:var(--gold); font-size:28px; margin-bottom:20px; }
.score-row { padding:12px; margin-bottom:6px; border-radius:8px; font-size:16px; }
.score-row.winner { background:rgba(201,168,76,.12); border:1px solid rgba(201,168,76,.3); color:var(--gold); font-weight:700; }
.score-row.other { background:rgba(255,255,255,.04); border:1px solid var(--border); color:#ccc; }
</style>
</head>
<body>

<!-- TITLE SCREEN -->
<div id="title-screen" class="screen active">
  <div style="font-size:64px;margin-bottom:8px">&#x1F985;</div>
  <h1>GLORY TO ROME</h1>
  <div class="sub">A STRATEGY CARD GAME</div>
  <p style="color:#aaa;font-size:15px;margin-bottom:16px">Number of opponents:</p>
  <div class="ai-select" id="ai-select"></div>
  <button class="start-btn" onclick="startGame()">BEGIN</button>
  <p class="note">Republic version &bull; Building powers noted but simplified for POC<br>All game logic from the original Glory to Rome card game</p>
</div>

<!-- GAME SCREEN -->
<div id="game-screen" class="screen">
  <div class="game-header">
    <div class="title">
      <a href="../../index.html" style="text-decoration:none;color:rgba(255,255,255,.4);font-size:13px;margin-right:8px;font-family:'Source Sans 3',sans-serif;padding:4px 10px;border:1px solid rgba(255,255,255,.1);border-radius:6px;transition:all .15s" onmouseover="this.style.borderColor='rgba(201,168,76,.4)';this.style.color='#c9a84c'" onmouseout="this.style.borderColor='rgba(255,255,255,.1)';this.style.color='rgba(255,255,255,.4)'">&larr; Hub</a>
      <span>&#x1F985;</span>
      <span class="name">GLORY TO ROME</span>
      <span class="turn" id="turn-label">Turn 1</span>
    </div>
    <div class="stats" id="header-stats"></div>
  </div>
  <div class="game-body">
    <div class="left-panel" id="left-panel"></div>
    <div class="center-panel">
      <div class="pool-area">
        <div class="section-label">POOL (<span id="pool-count">0</span>)</div>
        <div class="card-row" id="pool-cards"></div>
      </div>
      <div class="action-panel" id="action-panel"></div>
      <div class="player-area" id="player-area"></div>
    </div>
    <div class="log-panel">
      <div class="log-title">GAME LOG</div>
      <div class="log-entries" id="log-entries"></div>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════
// GAME DATA
// ═══════════════════════════════════════════
const MATERIALS = {
  Rubble: { color:'#d4952e', value:1, role:'Laborer' },
  Wood: { color:'#2d8a4e', value:1, role:'Craftsman' },
  Brick: { color:'#c0392b', value:2, role:'Legionary' },
  Concrete: { color:'#7a8087', value:2, role:'Architect' },
  Stone: { color:'#00a4c6', value:3, role:'Merchant' },
  Marble: { color:'#862d86', value:3, role:'Patron' },
};

const ROLES = ['Laborer','Craftsman','Legionary','Architect','Merchant','Patron'];
const ROLE_ICONS = { Laborer:'\u26CF', Craftsman:'\u2692', Legionary:'\u2694', Architect:'\u1F3DB', Merchant:'\u2696', Patron:'\u1F3C6' };
const TOOL_SVG = {
  Craftsman:'&#9986;', Laborer:'&#9935;', Legionary:'&#9876;',
  Architect:'&#9000;', Merchant:'&#9878;', Patron:'&#9878;'
};

const CARD_DEFS = [
  {name:'Academy',material:'Brick',value:2,count:3,role:'Legionary',fn:'Thinker after Craftsman turn'},
  {name:'Amphitheatre',material:'Concrete',value:2,count:3,role:'Architect',fn:'Craftsman \xd7Influence on complete'},
  {name:'Aqueduct',material:'Concrete',value:2,count:3,role:'Architect',fn:'Patron from hand; Clientele \xd72'},
  {name:'Archway',material:'Brick',value:2,count:3,role:'Legionary',fn:'Architect from Pool'},
  {name:'Atrium',material:'Brick',value:2,count:3,role:'Legionary',fn:'Merchant from Deck'},
  {name:'Bar',material:'Rubble',value:1,count:6,role:'Laborer',fn:'Patron from Deck'},
  {name:'Basilica',material:'Marble',value:3,count:3,role:'Patron',fn:'Merchant from Hand'},
  {name:'Bath',material:'Brick',value:2,count:3,role:'Legionary',fn:'New clients act immediately'},
  {name:'Bridge',material:'Concrete',value:2,count:3,role:'Architect',fn:'Legionary from Stockpile too'},
  {name:'Catacomb',material:'Stone',value:3,count:3,role:'Merchant',fn:'Game ends on complete'},
  {name:'Circus',material:'Wood',value:1,count:6,role:'Craftsman',fn:'2 same-role = Jack'},
  {name:'Circus Maximus',material:'Stone',value:3,count:3,role:'Merchant',fn:'Clients act twice'},
  {name:'Dock',material:'Wood',value:1,count:6,role:'Craftsman',fn:'Laborer from Hand too'},
  {name:'Forum',material:'Marble',value:3,count:3,role:'Patron',fn:'1 of each client = win'},
  {name:'Foundry',material:'Brick',value:2,count:3,role:'Legionary',fn:'Laborer \xd7Influence on complete'},
  {name:'Fountain',material:'Marble',value:3,count:3,role:'Patron',fn:'Craftsman from Deck'},
  {name:'Garden',material:'Stone',value:3,count:3,role:'Merchant',fn:'Patron \xd7Influence on complete'},
  {name:'Gate',material:'Brick',value:2,count:3,role:'Legionary',fn:'Marble foundations give function'},
  {name:'Insula',material:'Rubble',value:1,count:6,role:'Laborer',fn:'Max Clientele +2'},
  {name:'Latrine',material:'Rubble',value:1,count:6,role:'Laborer',fn:'Discard 1 before Think'},
  {name:'Ludus Magna',material:'Marble',value:3,count:3,role:'Patron',fn:'Merchants = any role'},
  {name:'Market',material:'Wood',value:1,count:6,role:'Craftsman',fn:'Max Vault +2'},
  {name:'Palace',material:'Marble',value:3,count:3,role:'Patron',fn:'Play multiple same-role cards'},
  {name:'Palisade',material:'Wood',value:1,count:6,role:'Craftsman',fn:'Immune to Legionary'},
  {name:'Prison',material:'Stone',value:3,count:3,role:'Merchant',fn:'Steal opponent structure'},
  {name:'Road',material:'Rubble',value:1,count:6,role:'Laborer',fn:'Any material for Stone'},
  {name:'School',material:'Brick',value:2,count:3,role:'Legionary',fn:'Thinker \xd7Influence on complete'},
  {name:'Scriptorium',material:'Stone',value:3,count:3,role:'Merchant',fn:'Marble completes anything'},
  {name:'Sewer',material:'Stone',value:3,count:3,role:'Merchant',fn:'Lead/follow cards \u2192 Stockpile'},
  {name:'Shrine',material:'Brick',value:2,count:3,role:'Legionary',fn:'Max Hand +2'},
  {name:'Stairway',material:'Marble',value:3,count:3,role:'Patron',fn:'Make opponent structure public'},
  {name:'Statue',material:'Marble',value:3,count:3,role:'Patron',fn:'+3 VP, any site'},
  {name:'Storeroom',material:'Concrete',value:2,count:3,role:'Architect',fn:'All clients = Laborers'},
  {name:'Temple',material:'Marble',value:3,count:3,role:'Patron',fn:'Max Hand +4'},
  {name:'Tower',material:'Concrete',value:2,count:3,role:'Architect',fn:'Rubble in any structure'},
  {name:'Villa',material:'Stone',value:3,count:3,role:'Merchant',fn:'Architect: 1 material completes'},
  {name:'Vomitorium',material:'Concrete',value:2,count:3,role:'Architect',fn:'Discard all before Think'},
  {name:'Wall',material:'Concrete',value:2,count:3,role:'Architect',fn:'Immune to Legionary; +VP/2 stockpile'},
];

// ═══════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════
let G = null; // game state
let numAI = 2;
let logMessages = [];
let cardIdCounter = 0;

// ═══════════════════════════════════════════
// UTILITY
// ═══════════════════════════════════════════
const makeCard = (def) => ({ ...def, id: cardIdCounter++ });
const shuffle = (arr) => { const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a; };
const getRoleForMaterial = (mat) => MATERIALS[mat]?.role || 'Laborer';
const getMatColor = (mat) => MATERIALS[mat]?.color || '#888';

function buildDeck() { const c=[]; for(const d of CARD_DEFS) for(let i=0;i<d.count;i++) c.push(makeCard(d)); return shuffle(c); }
function buildSites(n) { const s={}; for(const m of Object.keys(MATERIALS)) s[m]={inTown:n,outOfTown:6-n}; return s; }
function createPlayer(name,isHuman) { return {name,isHuman,hand:[],clientele:[],stockpile:[],vault:[],foundations:[],completed:[],influence:2,handRefill:5,maxClienteleBonus:0,maxVaultBonus:0}; }
function getMaxClientele(p) { let m=p.influence; if(p.completed.find(s=>s.name==='Insula'))m+=2; if(p.completed.find(s=>s.name==='Aqueduct'))m*=2; return m+p.maxClienteleBonus; }
function getMaxVault(p) { let m=p.influence; if(p.completed.find(s=>s.name==='Market'))m+=2; return m+p.maxVaultBonus; }
function getHandRefill(p) { let s=5; if(p.completed.find(x=>x.name==='Shrine'))s+=2; if(p.completed.find(x=>x.name==='Temple'))s+=4; return s; }
function countClientsOfRole(p,role) { return p.clientele.filter(c=>getRoleForMaterial(c.material)===role).length; }
function calcScore(p) { let s=p.influence; for(const c of p.vault)s+=(MATERIALS[c.material]?.value||0); if(p.completed.find(x=>x.name==='Statue'))s+=3; if(p.completed.find(x=>x.name==='Wall'))s+=Math.floor(p.stockpile.length/2); return s; }

const PHASE = {
  SETUP:'setup', LEADER_CHOICE:'leader_choice', FOLLOW_PHASE:'follow_phase',
  ACTION_PHASE:'action_phase', HUMAN_ACTION:'human_action',
  HUMAN_LEGIONARY_DEMAND:'human_legionary_demand', HUMAN_PATRON_PICK:'human_patron_pick',
  HUMAN_LABORER_PICK:'human_laborer_pick', HUMAN_MERCHANT_PICK:'human_merchant_pick',
  HUMAN_CRAFTSMAN_CHOICE:'human_craftsman_choice', HUMAN_CRAFTSMAN_LAY:'human_craftsman_lay',
  HUMAN_CRAFTSMAN_BUILD:'human_craftsman_build', HUMAN_ARCHITECT_CHOICE:'human_architect_choice',
  HUMAN_ARCHITECT_LAY:'human_architect_lay', HUMAN_ARCHITECT_BUILD:'human_architect_build',
  CLEANUP:'cleanup', GAME_OVER:'game_over',
};

// ═══════════════════════════════════════════
// AI
// ═══════════════════════════════════════════
function aiChooseLeadOrThink(player, g) {
  if(player.hand.length===0) return {action:'think'};
  for(const role of ROLES) {
    if(countClientsOfRole(player,role)>0) {
      const card=player.hand.find(c=>getRoleForMaterial(c.material)===role);
      if(card) return {action:'lead',cardId:card.id};
    }
  }
  if(player.hand.length>=4) {
    if(player.foundations.length>0) {
      const a=player.hand.find(c=>getRoleForMaterial(c.material)==='Architect');
      const cr=player.hand.find(c=>getRoleForMaterial(c.material)==='Craftsman');
      if(a&&player.stockpile.length>0) return {action:'lead',cardId:a.id};
      if(cr) return {action:'lead',cardId:cr.id};
    }
    if(g.pool.length>0) { const l=player.hand.find(c=>getRoleForMaterial(c.material)==='Laborer'); if(l) return {action:'lead',cardId:l.id}; }
    if(g.pool.length>0&&player.clientele.length<getMaxClientele(player)) { const p=player.hand.find(c=>getRoleForMaterial(c.material)==='Patron'); if(p) return {action:'lead',cardId:p.id}; }
    if(player.stockpile.length>0&&player.vault.length<getMaxVault(player)) { const m=player.hand.find(c=>getRoleForMaterial(c.material)==='Merchant'); if(m) return {action:'lead',cardId:m.id}; }
    return {action:'lead',cardId:player.hand[0].id};
  }
  return {action:'think'};
}

function aiChooseFollowOrThink(player,role) {
  const card=player.hand.find(c=>getRoleForMaterial(c.material)===role);
  if(card&&player.hand.length>2) return {action:'follow',cardId:card.id};
  return {action:'think'};
}

function aiPerformAction(player,role,g) {
  const actions=[];
  switch(role) {
    case 'Patron': if(g.pool.length>0&&player.clientele.length<getMaxClientele(player)) actions.push({type:'patron'}); break;
    case 'Laborer': if(g.pool.length>0) actions.push({type:'laborer'}); break;
    case 'Merchant': if(player.stockpile.length>0&&player.vault.length<getMaxVault(player)) actions.push({type:'merchant'}); break;
    case 'Craftsman':
      for(const f of player.foundations) { if(f.materials.length<f.value) { const mat=player.hand.find(c=>c.material===f.material); if(mat){actions.push({type:'craftsman_build',foundationIdx:player.foundations.indexOf(f),cardId:mat.id});return actions;} } }
      if(player.hand.length>1) { const card=player.hand.find(c=>{const hs=(g.sites[c.material]?.inTown||0)>0;const ah=player.foundations.find(f=>f.name===c.name)||player.completed.find(f=>f.name===c.name);return hs&&!ah;}); if(card) actions.push({type:'craftsman_lay',cardId:card.id}); }
      break;
    case 'Architect':
      for(const f of player.foundations) { if(f.materials.length<f.value) { const mat=player.stockpile.find(c=>c.material===f.material); if(mat){actions.push({type:'architect_build',foundationIdx:player.foundations.indexOf(f),cardId:mat.id});return actions;} } }
      if(player.hand.length>1) { const card=player.hand.find(c=>{const hs=(g.sites[c.material]?.inTown||0)>0;const ah=player.foundations.find(f=>f.name===c.name)||player.completed.find(f=>f.name===c.name);return hs&&!ah;}); if(card) actions.push({type:'architect_lay',cardId:card.id}); }
      break;
    case 'Legionary': if(player.hand.length>0) actions.push({type:'legionary',cardId:player.hand[0].id}); break;
  }
  return actions;
}

// ═══════════════════════════════════════════
// GAME ACTIONS
// ═══════════════════════════════════════════
function addLog(msg) { logMessages.push(msg); if(logMessages.length>100) logMessages=logMessages.slice(-80); }

function doThink(g,pIdx) {
  const p=g.players[pIdx]; const refill=getHandRefill(p);
  if(p.hand.length<refill) { const draw=refill-p.hand.length; const drawn=g.deck.splice(0,Math.min(draw,g.deck.length)); p.hand.push(...drawn); addLog(p.name+' thinks and draws '+drawn.length+' card(s)'); }
  else if(g.deck.length>0) { p.hand.push(g.deck.shift()); addLog(p.name+' thinks and draws 1 card'); }
  else if(g.jacks>0) { g.jacks--; addLog(p.name+' takes a Jack'); }
  else addLog(p.name+' thinks but nothing to draw!');
}

function layFoundation(g,pIdx,cardId,fromStockpile) {
  const p=g.players[pIdx]; const src=fromStockpile?p.stockpile:p.hand; const idx=src.findIndex(c=>c.id===cardId);
  if(idx===-1) return false; const card=src[idx];
  if((g.sites[card.material]?.inTown||0)<=0) return false;
  if(p.foundations.find(f=>f.name===card.name)||p.completed.find(f=>f.name===card.name)) return false;
  src.splice(idx,1); g.sites[card.material].inTown--;
  p.foundations.push({...card,materials:[],siteValue:MATERIALS[card.material].value});
  addLog(p.name+' lays foundation for '+card.name+' ('+card.material+')'); return true;
}

function addMaterial(g,pIdx,foundIdx,cardId,fromStockpile) {
  const p=g.players[pIdx]; const src=fromStockpile?p.stockpile:p.hand; const ci=src.findIndex(c=>c.id===cardId);
  if(ci===-1) return false; const card=src[ci]; const f=p.foundations[foundIdx]; if(!f) return false;
  if(card.material!==f.material) return false; if(f.materials.length>=f.value) return false;
  src.splice(ci,1); f.materials.push(card);
  addLog(p.name+' adds '+card.material+' to '+f.name+' ('+f.materials.length+'/'+f.value+')');
  if(f.materials.length>=f.value) completeStructure(g,pIdx,foundIdx); return true;
}

function completeStructure(g,pIdx,foundIdx) {
  const p=g.players[pIdx]; const f=p.foundations.splice(foundIdx,1)[0]; p.completed.push(f);
  const sv=MATERIALS[f.material]?.value||1; p.influence+=sv;
  addLog('\u{1F3D7} '+p.name+' completes '+f.name+'! (+'+sv+' Influence, now '+p.influence+')');
  if(f.name==='Catacomb') { g.phase=PHASE.GAME_OVER; addLog('\u{1F480} '+p.name+' completed Catacomb! Game over!'); }
}

function doLegionary(g,pIdx,demandCardId) {
  const p=g.players[pIdx]; const dc=p.hand.find(c=>c.id===demandCardId); if(!dc) return;
  const dm=dc.material; addLog(p.name+' demands '+dm+'!');
  const pi=g.pool.findIndex(c=>c.material===dm);
  if(pi!==-1) { p.stockpile.push(g.pool.splice(pi,1)[0]); addLog('  \u2192 Takes '+dm+' from Pool'); }
  const total=g.players.length; const li=(pIdx+total-1)%total; const ri=(pIdx+1)%total;
  for(const nIdx of [li,ri]) { if(nIdx===pIdx) continue; const nb=g.players[nIdx];
    if(nb.completed.find(s=>s.name==='Palisade'||s.name==='Wall')) { addLog('  \u2192 '+nb.name+' is protected!'); continue; }
    const ni=nb.hand.findIndex(c=>c.material===dm);
    if(ni!==-1) { p.stockpile.push(nb.hand.splice(ni,1)[0]); addLog('  \u2192 Takes '+dm+' from '+nb.name); }
    else addLog('  \u2192 '+nb.name+': "Glory to Rome!"');
  }
}

function processAIActions(g,pIdx,role,numActions) {
  const p=g.players[pIdx];
  for(let i=0;i<numActions;i++) {
    const actions=aiPerformAction(p,role,g); if(actions.length===0) break; const a=actions[0];
    switch(a.type) {
      case 'patron': if(g.pool.length>0&&p.clientele.length<getMaxClientele(p)){const c=g.pool.shift();p.clientele.push(c);addLog(p.name+' hires '+getRoleForMaterial(c.material)+' client');} break;
      case 'laborer': if(g.pool.length>0){const c=g.pool.shift();p.stockpile.push(c);addLog(p.name+' takes '+c.material+' from Pool');} break;
      case 'merchant': if(p.stockpile.length>0&&p.vault.length<getMaxVault(p)){const c=p.stockpile.shift();p.vault.push(c);addLog(p.name+' vaults '+c.material);} break;
      case 'craftsman_lay': layFoundation(g,pIdx,a.cardId); break;
      case 'craftsman_build': addMaterial(g,pIdx,a.foundationIdx,a.cardId,false); break;
      case 'architect_lay': layFoundation(g,pIdx,a.cardId); break;
      case 'architect_build': addMaterial(g,pIdx,a.foundationIdx,a.cardId,true); break;
      case 'legionary': doLegionary(g,pIdx,a.cardId); break;
    }
  }
}

// ═══════════════════════════════════════════
// PHASE MANAGEMENT
// ═══════════════════════════════════════════
function processFollowPhase(g) {
  const total=g.players.length;
  for(let i=1;i<total;i++) {
    const pIdx=(g.leaderIdx+i)%total; const p=g.players[pIdx];
    if(p.isHuman) { g.phase=PHASE.FOLLOW_PHASE; g.currentActionPlayer=pIdx; return; }
    const d=aiChooseFollowOrThink(p,g.currentRole);
    if(d.action==='follow') { const ci=p.hand.findIndex(c=>c.id===d.cardId); if(ci!==-1){const card=p.hand.splice(ci,1)[0];g.turnCards.push({pIdx,card});g.followDecisions[pIdx]='follow';addLog(p.name+' follows '+g.currentRole);} }
    else { g.followDecisions[pIdx]='think'; doThink(g,pIdx); }
  }
  startActionPhase(g);
}

function startActionPhase(g) {
  const queue=[]; const total=g.players.length;
  for(let i=0;i<total;i++) {
    const pIdx=(g.leaderIdx+i)%total; const isLeader=i===0; const followed=g.followDecisions[pIdx]==='follow';
    const numClientActions=countClientsOfRole(g.players[pIdx],g.currentRole);
    const numActions=(isLeader||followed?1:0)+numClientActions;
    if(numActions>0) queue.push({pIdx,numActions});
  }
  g.actionQueue=queue; processNextAction(g);
}

function processNextAction(g) {
  if(g.phase===PHASE.GAME_OVER) return;
  if(g.actionQueue.length===0) {
    for(const tc of g.turnCards) g.pool.push(tc.card);
    g.turnCards=[]; g.currentRole=null; g.leaderIdx=(g.leaderIdx+1)%g.players.length; g.turnNumber++;
    if(g.deck.length===0) { g.phase=PHASE.GAME_OVER; addLog('\u{1F4DC} The deck is exhausted! Game over!'); render(); return; }
    const totalInTown=Object.values(g.sites).reduce((s,v)=>s+v.inTown,0);
    if(totalInTown===0) { g.phase=PHASE.GAME_OVER; addLog('\u{1F3DB} All sites claimed! Game over!'); render(); return; }
    g.phase=PHASE.LEADER_CHOICE;
    addLog('\u2500\u2500\u2500 Turn '+g.turnNumber+': '+g.players[g.leaderIdx].name+' is Leader \u2500\u2500\u2500');
    render(); scheduleAI(); return;
  }
  const current=g.actionQueue[0]; const p=g.players[current.pIdx];
  if(p.isHuman) { g.currentActionPlayer=current.pIdx; g.actionsRemaining=current.numActions; g.phase=PHASE.HUMAN_ACTION; render(); return; }
  processAIActions(g,current.pIdx,g.currentRole,current.numActions);
  g.actionQueue.shift();
  if(g.phase!==PHASE.GAME_OVER) processNextAction(g); else render();
}

function scheduleAI() {
  if(!G||G.phase===PHASE.GAME_OVER) return;
  if(G.phase===PHASE.LEADER_CHOICE&&!G.players[G.leaderIdx].isHuman) {
    setTimeout(()=>{
      if(!G) return;
      const l=G.players[G.leaderIdx]; const d=aiChooseLeadOrThink(l,G);
      if(d.action==='think') { doThink(G,G.leaderIdx); G.leaderIdx=(G.leaderIdx+1)%G.players.length; G.turnNumber++; G.phase=PHASE.LEADER_CHOICE; addLog('\u2500\u2500\u2500 Turn '+G.turnNumber+': '+G.players[G.leaderIdx].name+' is Leader \u2500\u2500\u2500'); render(); scheduleAI(); }
      else { const idx=l.hand.findIndex(c=>c.id===d.cardId); if(idx!==-1){const card=l.hand.splice(idx,1)[0]; G.currentRole=getRoleForMaterial(card.material); G.turnCards=[{pIdx:G.leaderIdx,card}]; addLog(l.name+' leads '+G.currentRole+'!'); G.followDecisions={}; processFollowPhase(G); render(); scheduleAI();} }
    },500);
  }
}

function finishOneAction() {
  G.actionsRemaining--;
  if(G.actionsRemaining<=0) { G.actionQueue.shift(); processNextAction(G); }
  else { G.phase=PHASE.HUMAN_ACTION; render(); }
}

// ═══════════════════════════════════════════
// HUMAN ACTION HANDLERS
// ═══════════════════════════════════════════
function handleLeaderChoice(choice,cardId) {
  const leader=G.players[G.leaderIdx];
  if(choice==='think') { doThink(G,G.leaderIdx); G.leaderIdx=(G.leaderIdx+1)%G.players.length; G.turnNumber++; G.phase=PHASE.LEADER_CHOICE; addLog('\u2500\u2500\u2500 Turn '+G.turnNumber+': '+G.players[G.leaderIdx].name+' is Leader \u2500\u2500\u2500'); }
  else { const idx=leader.hand.findIndex(c=>c.id===cardId); if(idx===-1) return; const card=leader.hand.splice(idx,1)[0]; G.currentRole=getRoleForMaterial(card.material); G.turnCards=[{pIdx:G.leaderIdx,card}]; addLog(leader.name+' leads '+G.currentRole+'!'); G.followDecisions={}; processFollowPhase(G); }
  render(); scheduleAI();
}

function handleFollowChoice(choice,cardId) {
  const pIdx=G.currentActionPlayer; const p=G.players[pIdx];
  if(choice==='think') { G.followDecisions[pIdx]='think'; doThink(G,pIdx); }
  else { const idx=p.hand.findIndex(c=>c.id===cardId); if(idx===-1) return; const card=p.hand.splice(idx,1)[0]; G.turnCards.push({pIdx,card}); G.followDecisions[pIdx]='follow'; addLog(p.name+' follows '+G.currentRole); }
  const total=G.players.length; const leaderOrder=[];
  for(let i=1;i<total;i++) leaderOrder.push((G.leaderIdx+i)%total);
  const myOI=leaderOrder.indexOf(pIdx);
  for(let i=myOI+1;i<leaderOrder.length;i++) {
    const nI=leaderOrder[i]; const np=G.players[nI];
    if(np.isHuman) { G.currentActionPlayer=nI; G.phase=PHASE.FOLLOW_PHASE; render(); return; }
    const d=aiChooseFollowOrThink(np,G.currentRole);
    if(d.action==='follow') { const ci=np.hand.findIndex(c=>c.id===d.cardId); if(ci!==-1){const card=np.hand.splice(ci,1)[0];G.turnCards.push({pIdx:nI,card});G.followDecisions[nI]='follow';addLog(np.name+' follows '+G.currentRole);} }
    else { G.followDecisions[nI]='think'; doThink(G,nI); }
  }
  startActionPhase(G); render(); scheduleAI();
}

function handleHumanAction(actionType,params) {
  params=params||{};
  const pIdx=G.currentActionPlayer; const p=G.players[pIdx];
  switch(actionType) {
    case 'patron_pool': if(G.pool.length>0&&p.clientele.length<getMaxClientele(p)) G.phase=PHASE.HUMAN_PATRON_PICK; break;
    case 'patron_pick': { const c=G.pool.find(x=>x.id===params.cardId); if(c&&p.clientele.length<getMaxClientele(p)){G.pool=G.pool.filter(x=>x.id!==params.cardId);p.clientele.push(c);addLog(p.name+' hires '+getRoleForMaterial(c.material)+' client ('+c.name+')');finishOneAction();} break; }
    case 'laborer_pool': if(G.pool.length>0) G.phase=PHASE.HUMAN_LABORER_PICK; break;
    case 'laborer_pick': { const c=G.pool.find(x=>x.id===params.cardId); if(c){G.pool=G.pool.filter(x=>x.id!==params.cardId);p.stockpile.push(c);addLog(p.name+' takes '+c.material+' from Pool');finishOneAction();} break; }
    case 'merchant': if(p.stockpile.length>0&&p.vault.length<getMaxVault(p)) G.phase=PHASE.HUMAN_MERCHANT_PICK; break;
    case 'merchant_pick': { const c=p.stockpile.find(x=>x.id===params.cardId); if(c&&p.vault.length<getMaxVault(p)){p.stockpile=p.stockpile.filter(x=>x.id!==params.cardId);p.vault.push(c);addLog(p.name+' vaults '+c.material+' ('+c.name+')');finishOneAction();} break; }
    case 'craftsman_choose': G.phase=PHASE.HUMAN_CRAFTSMAN_CHOICE; break;
    case 'craftsman_lay': G.phase=PHASE.HUMAN_CRAFTSMAN_LAY; break;
    case 'craftsman_do_lay': if(layFoundation(G,pIdx,params.cardId,false)) finishOneAction(); break;
    case 'craftsman_build': G.phase=PHASE.HUMAN_CRAFTSMAN_BUILD; break;
    case 'craftsman_do_build': if(addMaterial(G,pIdx,params.foundIdx,params.cardId,false)) finishOneAction(); break;
    case 'architect_choose': G.phase=PHASE.HUMAN_ARCHITECT_CHOICE; break;
    case 'architect_lay': G.phase=PHASE.HUMAN_ARCHITECT_LAY; break;
    case 'architect_do_lay': if(layFoundation(G,pIdx,params.cardId,false)) finishOneAction(); break;
    case 'architect_build': G.phase=PHASE.HUMAN_ARCHITECT_BUILD; break;
    case 'architect_do_build': if(addMaterial(G,pIdx,params.foundIdx,params.cardId,true)) finishOneAction(); break;
    case 'legionary': if(p.hand.length>0) G.phase=PHASE.HUMAN_LEGIONARY_DEMAND; break;
    case 'legionary_demand': doLegionary(G,pIdx,params.cardId); finishOneAction(); break;
    case 'skip': addLog(p.name+' skips action'); finishOneAction(); break;
  }
  render();
}

// ═══════════════════════════════════════════
// RENDERING
// ═══════════════════════════════════════════
function renderCard(card,opts) {
  opts=opts||{};
  const small=opts.small; const faceDown=opts.faceDown; const clickable=opts.onClick;
  const selected=opts.selected;
  if(faceDown) return '<div class="card'+(small?' sm':'')+' facedown" '+(clickable?'onclick="'+opts.onClick+'"':'')+'></div>';
  const col=getMatColor(card.material);
  const roleLetters=card.role.toUpperCase().split('');
  let roleStrip='<div class="card-role-strip">'+roleLetters.map(l=>'<span class="card-role-letter" style="color:'+col+'">'+l+'</span>').join('')+'</div>';
  let dots='<div class="card-dots">';
  for(let i=0;i<card.value;i++) dots+='<div class="card-dot" style="background:'+col+'"></div>';
  dots+='</div>';
  let coins='<div class="card-coin">';
  for(let i=0;i<card.value;i++) coins+='<div class="coin">R</div>';
  coins+='</div>';
  return '<div class="card'+(small?' sm':'')+(clickable?' clickable':'')+(selected?' selected':'')+'" '
    +(clickable?'onclick="'+opts.onClick+'"':'')+'>'
    +roleStrip
    +'<div class="card-name" style="color:#1a1a1a">'+card.name+'</div>'
    +dots
    +'<div class="card-fn">'+card.fn+'</div>'
    +'<div class="card-material" style="color:'+col+'">'+card.material.toUpperCase()+'</div>'
    +coins
    +'</div>';
}

function renderCardRow(cards,opts) {
  opts=opts||{};
  let h='';
  if(opts.label) h+='<div class="section-label">'+opts.label+' ('+cards.length+')</div>';
  h+='<div class="card-row">';
  if(cards.length===0) h+='<span class="empty-label">empty</span>';
  else cards.forEach(c=>{ h+=renderCard(c,{small:opts.small,faceDown:opts.faceDown,onClick:opts.onClickFn?opts.onClickFn(c):null,selected:opts.selectedId===c.id}); });
  h+='</div>';
  return h;
}

function renderFoundation(f,onClick) {
  const col=getMatColor(f.material);
  let dots='<div class="fdots">';
  for(let i=0;i<f.value;i++) dots+='<div class="fdot" style="background:'+(i<f.materials.length?col:'rgba(255,255,255,.08)')+';border-color:'+col+'"></div>';
  dots+='</div>';
  return '<div class="foundation-mini'+(onClick?' clickable':'')+'" '+(onClick?'onclick="'+onClick+'"':'')+'>'
    +'<div class="fname" style="color:'+col+'">'+f.name+'</div>'
    +'<div class="finfo">'+f.material+' \u2022 '+f.materials.length+'/'+f.value+'</div>'
    +dots+'</div>';
}

function renderPlayerPanel(player,idx,compact) {
  const isLeader=idx===G.leaderIdx; const score=calcScore(player);
  let h='<div class="player-panel'+(isLeader?' leader':'')+'">';
  h+='<div class="player-header"><div class="player-name">';
  h+='<span>'+(player.isHuman?'\u{1F464}':'\u{1F916}')+'</span>';
  h+='<span>'+player.name+'</span>';
  if(isLeader) h+='<span class="leader-badge">LEADER</span>';
  h+='</div><div class="player-stats">';
  h+='<span style="color:#c9a84c">\u2B50'+player.influence+'</span>';
  h+='<span style="color:#3498db">\u{1F0CF}'+player.hand.length+'</span>';
  h+='<span style="color:#e67e22">\u{1F4E6}'+player.stockpile.length+'</span>';
  h+='<span style="color:#9b59b6">\u{1F512}'+player.vault.length+'</span>';
  h+='<span style="color:#2ecc71">\u{1F3D7}'+player.completed.length+'</span>';
  h+='<span style="color:#ecf0f1;font-weight:700">VP:'+score+'</span>';
  h+='</div></div>';
  if(!compact) {
    h+='<div class="clients-row">';
    if(player.clientele.length===0) h+='<span class="empty-label">No clients</span>';
    else player.clientele.forEach(c=>{ h+='<span class="client-chip" style="background:'+getMatColor(c.material)+'">'+getRoleForMaterial(c.material)+'</span>'; });
    h+='</div>';
    h+='<div class="foundations-row">';
    player.foundations.forEach((f,i)=>{ h+=renderFoundation(f); });
    h+='</div>';
    h+='<div class="completed-row">';
    player.completed.forEach(f=>{ h+='<span class="completed-chip">\u2713 '+f.name+'</span>'; });
    h+='</div>';
  }
  h+='</div>';
  return h;
}

function renderActionPanel() {
  const phase=G.phase; const role=G.currentRole; const human=G.players[0];
  let h='';

  if(phase===PHASE.GAME_OVER) {
    const scores=G.players.map((p,i)=>({name:p.name,score:calcScore(p),idx:i})).sort((a,b)=>b.score-a.score);
    h+='<div class="game-over"><h2>\u{1F3DB} Game Over!</h2>';
    scores.forEach((s,i)=>{ h+='<div class="score-row '+(i===0?'winner':'other')+'">'+(i===0?'\u{1F451} ':''+(i+1)+'. ')+s.name+': '+s.score+' VP</div>'; });
    h+='<button class="start-btn" style="margin-top:20px;font-size:14px;padding:10px 32px" onclick="backToMenu()">Play Again</button></div>';
    return h;
  }

  const isHumanLeader=G.leaderIdx===0;
  if(phase===PHASE.LEADER_CHOICE&&isHumanLeader) {
    h+='<div class="action-title">\u{1F3DB} You are the Leader!</div>';
    h+='<button class="action-btn" style="background:#2c3e50" onclick="handleLeaderChoice(\'think\')">\u{1F9E0} Think (Draw cards)</button>';
    h+='<div class="action-subtitle">Or click a card from your hand to Lead that role:</div>';
    h+=renderCardRow(human.hand,{onClickFn:c=>"handleLeaderChoice('lead',"+c.id+")"});
    return h;
  }

  if(phase===PHASE.FOLLOW_PHASE&&G.currentActionPlayer===0) {
    const matchCards=human.hand.filter(c=>getRoleForMaterial(c.material)===role);
    h+='<div class="action-title">'+G.players[G.leaderIdx].name+' led '+role+'! Follow or Think?</div>';
    h+='<button class="action-btn" style="background:#2c3e50" onclick="handleFollowChoice(\'think\')">\u{1F9E0} Think</button>';
    if(matchCards.length>0) { h+='<div class="action-subtitle">Play a '+role+' card to follow:</div>'; h+=renderCardRow(matchCards,{onClickFn:c=>"handleFollowChoice('follow',"+c.id+")"}); }
    else h+='<div class="action-subtitle">No matching '+role+' cards to follow.</div>';
    return h;
  }

  if(phase===PHASE.HUMAN_ACTION) {
    h+='<div class="action-title">Perform '+role+' action ('+G.actionsRemaining+' remaining)</div>';
    h+=renderRoleButton(role);
    h+='<button class="action-btn skip" onclick="handleHumanAction(\'skip\')">\u23ED Skip</button>';
    return h;
  }

  if(phase===PHASE.HUMAN_PATRON_PICK) {
    h+='<div class="action-title">\u{1F451} Choose a client from the Pool:</div>';
    h+=renderCardRow(G.pool,{onClickFn:c=>"handleHumanAction('patron_pick',{cardId:"+c.id+"})"});
    return h;
  }
  if(phase===PHASE.HUMAN_LABORER_PICK) {
    h+='<div class="action-title">\u26CF Choose a material from the Pool:</div>';
    h+=renderCardRow(G.pool,{onClickFn:c=>"handleHumanAction('laborer_pick',{cardId:"+c.id+"})"});
    return h;
  }
  if(phase===PHASE.HUMAN_MERCHANT_PICK) {
    h+='<div class="action-title">\u2696 Choose material from Stockpile to vault:</div>';
    h+=renderCardRow(human.stockpile,{onClickFn:c=>"handleHumanAction('merchant_pick',{cardId:"+c.id+"})"});
    return h;
  }
  if(phase===PHASE.HUMAN_LEGIONARY_DEMAND) {
    h+='<div class="action-title">\u2694 Choose a card to reveal and demand its material:</div>';
    h+=renderCardRow(human.hand,{onClickFn:c=>"handleHumanAction('legionary_demand',{cardId:"+c.id+"})"});
    return h;
  }

  if(phase===PHASE.HUMAN_CRAFTSMAN_CHOICE) {
    const canLay=human.hand.some(c=>{const hs=(G.sites[c.material]?.inTown||0)>0;const ah=human.foundations.find(f=>f.name===c.name)||human.completed.find(f=>f.name===c.name);return hs&&!ah;});
    const canBuild=human.foundations.some(f=>f.materials.length<f.value&&human.hand.some(c=>c.material===f.material));
    h+='<div class="action-title">\u2692 Craftsman: Lay Foundation or Add Material from Hand</div>';
    if(canLay) h+='<button class="action-btn" style="background:#27ae60" onclick="handleHumanAction(\'craftsman_lay\')">\u{1F3D7} Lay New Foundation</button>';
    if(canBuild) h+='<button class="action-btn" style="background:#2980b9" onclick="handleHumanAction(\'craftsman_build\')">\u{1F9F1} Add Material to Foundation</button>';
    h+='<button class="action-btn skip" onclick="handleHumanAction(\'skip\')">\u23ED Skip</button>';
    return h;
  }
  if(phase===PHASE.HUMAN_CRAFTSMAN_LAY) {
    const validCards=human.hand.filter(c=>{const hs=(G.sites[c.material]?.inTown||0)>0;const ah=human.foundations.find(f=>f.name===c.name)||human.completed.find(f=>f.name===c.name);return hs&&!ah;});
    h+='<div class="action-title">\u{1F3D7} Choose a card to lay as Foundation:</div>';
    h+=renderCardRow(validCards,{onClickFn:c=>"handleHumanAction('craftsman_do_lay',{cardId:"+c.id+"})"});
    h+='<button class="action-btn skip" onclick="G.phase=\'human_craftsman_choice\';render()">\u2190 Back</button>';
    return h;
  }
  if(phase===PHASE.HUMAN_CRAFTSMAN_BUILD) {
    const bfs=human.foundations.filter(f=>f.materials.length<f.value&&human.hand.some(c=>c.material===f.material));
    h+='<div class="action-title">\u{1F9F1} Choose foundation then card:</div>';
    bfs.forEach((f,fi)=>{
      const ri=human.foundations.indexOf(f); const mc=human.hand.filter(c=>c.material===f.material);
      h+=renderFoundation(f);
      h+=renderCardRow(mc,{small:true,onClickFn:c=>"handleHumanAction('craftsman_do_build',{foundIdx:"+ri+",cardId:"+c.id+"})"});
    });
    h+='<button class="action-btn skip" onclick="G.phase=\'human_craftsman_choice\';render()">\u2190 Back</button>';
    return h;
  }
  if(phase===PHASE.HUMAN_ARCHITECT_CHOICE) {
    const canLay=human.hand.some(c=>{const hs=(G.sites[c.material]?.inTown||0)>0;const ah=human.foundations.find(f=>f.name===c.name)||human.completed.find(f=>f.name===c.name);return hs&&!ah;});
    const canBuild=human.foundations.some(f=>f.materials.length<f.value&&human.stockpile.some(c=>c.material===f.material));
    h+='<div class="action-title">\u{1F3DB} Architect: Lay Foundation or Add from Stockpile</div>';
    if(canLay) h+='<button class="action-btn" style="background:#27ae60" onclick="handleHumanAction(\'architect_lay\')">\u{1F3D7} Lay New Foundation</button>';
    if(canBuild) h+='<button class="action-btn" style="background:#2980b9" onclick="handleHumanAction(\'architect_build\')">\u{1F9F1} Add Material from Stockpile</button>';
    h+='<button class="action-btn skip" onclick="handleHumanAction(\'skip\')">\u23ED Skip</button>';
    return h;
  }
  if(phase===PHASE.HUMAN_ARCHITECT_LAY) {
    const validCards=human.hand.filter(c=>{const hs=(G.sites[c.material]?.inTown||0)>0;const ah=human.foundations.find(f=>f.name===c.name)||human.completed.find(f=>f.name===c.name);return hs&&!ah;});
    h+='<div class="action-title">\u{1F3D7} Choose card from Hand to lay as Foundation:</div>';
    h+=renderCardRow(validCards,{onClickFn:c=>"handleHumanAction('architect_do_lay',{cardId:"+c.id+"})"});
    h+='<button class="action-btn skip" onclick="G.phase=\'human_architect_choice\';render()">\u2190 Back</button>';
    return h;
  }
  if(phase===PHASE.HUMAN_ARCHITECT_BUILD) {
    const bfs=human.foundations.filter(f=>f.materials.length<f.value&&human.stockpile.some(c=>c.material===f.material));
    h+='<div class="action-title">\u{1F9F1} Choose foundation, then stockpile material:</div>';
    bfs.forEach(f=>{
      const ri=human.foundations.indexOf(f); const mc=human.stockpile.filter(c=>c.material===f.material);
      h+=renderFoundation(f);
      h+=renderCardRow(mc,{small:true,onClickFn:c=>"handleHumanAction('architect_do_build',{foundIdx:"+ri+",cardId:"+c.id+"})"});
    });
    h+='<button class="action-btn skip" onclick="G.phase=\'human_architect_choice\';render()">\u2190 Back</button>';
    return h;
  }

  h+='<div style="padding:16px;text-align:center;color:rgba(255,255,255,.35)">';
  h+='<div style="font-size:24px;animation:pulse 1.5s infinite">\u23F3</div>';
  h+='<div>Waiting...</div></div>';
  return h;
}

function renderRoleButton(role) {
  const human=G.players[0];
  switch(role) {
    case 'Patron': return '<button class="action-btn" style="background:#862d86" onclick="handleHumanAction(\'patron_pool\')" '+(G.pool.length===0||human.clientele.length>=getMaxClientele(human)?'disabled':'')+'>\u{1F451} Hire Client ('+G.pool.length+' in pool)</button>';
    case 'Laborer': return '<button class="action-btn" style="background:#d4952e" onclick="handleHumanAction(\'laborer_pool\')" '+(G.pool.length===0?'disabled':'')+'>\u26CF Take Material ('+G.pool.length+' in pool)</button>';
    case 'Merchant': return '<button class="action-btn" style="background:#00a4c6" onclick="handleHumanAction(\'merchant\')" '+(human.stockpile.length===0||human.vault.length>=getMaxVault(human)?'disabled':'')+'>\u2696 Vault Material ('+human.stockpile.length+' in stockpile)</button>';
    case 'Craftsman': return '<button class="action-btn" style="background:#2d8a4e" onclick="handleHumanAction(\'craftsman_choose\')">\u2692 Craftsman Action</button>';
    case 'Architect': return '<button class="action-btn" style="background:#7a8087" onclick="handleHumanAction(\'architect_choose\')">\u{1F3DB} Architect Action</button>';
    case 'Legionary': return '<button class="action-btn" style="background:#c0392b" onclick="handleHumanAction(\'legionary\')" '+(human.hand.length===0?'disabled':'')+'>\u2694 Demand Material</button>';
    default: return '';
  }
}

function render() {
  if(!G) return;
  const human=G.players[0]; const isHumanTurn=G.phase.startsWith('human')||(G.phase===PHASE.LEADER_CHOICE&&G.leaderIdx===0)||(G.phase===PHASE.FOLLOW_PHASE&&G.currentActionPlayer===0);

  // Header
  document.getElementById('turn-label').textContent='Turn '+G.turnNumber;
  let statsH='<span>\u{1F0CF} Deck: '+G.deck.length+'</span><span>\u{1F3B4} Pool: '+G.pool.length+'</span><span>Jacks: '+G.jacks+'</span>';
  if(G.currentRole) statsH+='<span style="color:#c9a84c">'+G.currentRole+'</span>';
  document.getElementById('header-stats').innerHTML=statsH;

  // Left panel - opponents + sites
  let leftH='';
  G.players.forEach((p,i)=>{ if(i>0) leftH+=renderPlayerPanel(p,i,false); });
  leftH+='<div class="sites-panel"><div class="sites-title">SITES REMAINING</div><div class="sites-grid">';
  Object.entries(G.sites).forEach(([mat,s])=>{
    leftH+='<div class="site-chip'+(s.inTown===0?' depleted':'')+'" style="background:'+getMatColor(mat)+'20;color:'+getMatColor(mat)+';border:1px solid '+getMatColor(mat)+'60">'+mat+': '+s.inTown+'</div>';
  });
  leftH+='</div></div>';
  document.getElementById('left-panel').innerHTML=leftH;

  // Pool
  document.getElementById('pool-count').textContent=G.pool.length;
  document.getElementById('pool-cards').innerHTML=G.pool.map(c=>renderCard(c,{small:true})).join('');

  // Action panel
  const ap=document.getElementById('action-panel');
  ap.className='action-panel'+(isHumanTurn?' active':'');
  ap.innerHTML=renderActionPanel();

  // Player area
  let paH=renderPlayerPanel(human,0,false);
  paH+=renderCardRow(human.hand,{label:'YOUR HAND'});
  if(human.stockpile.length>0) paH+=renderCardRow(human.stockpile,{small:true,label:'YOUR STOCKPILE'});
  if(human.vault.length>0) {
    paH+='<div class="section-label">VAULT ('+human.vault.length+'/'+getMaxVault(human)+')</div>';
    paH+='<div class="card-row">'+human.vault.map(c=>renderCard(c,{small:true,faceDown:true})).join('')+'</div>';
  }
  document.getElementById('player-area').innerHTML=paH;

  // Log
  const logEl=document.getElementById('log-entries');
  logEl.innerHTML=logMessages.map(msg=>{
    let cls='log-entry';
    if(msg.includes('\u2500\u2500\u2500')) cls+=' turn';
    else if(msg.includes('\u{1F3D7}')) cls+=' build';
    else if(msg.includes('\u{1F480}')) cls+=' end';
    return '<div class="'+cls+'">'+msg+'</div>';
  }).join('');
  logEl.scrollTop=logEl.scrollHeight;
}

// ═══════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════
function initMenu() {
  const sel=document.getElementById('ai-select');
  sel.innerHTML=[1,2,3,4].map(n=>'<button class="ai-btn'+(numAI===n?' sel':'')+'" onclick="setAI('+n+')">'+n+'</button>').join('');
}

function setAI(n) { numAI=n; initMenu(); }

function startGame() {
  cardIdCounter=0; logMessages=[];
  const deck=buildDeck(); const totalPlayers=numAI+1; const sites=buildSites(totalPlayers);
  const players=[createPlayer('You',true)];
  const aiNames=['Caesar','Brutus','Nero','Augustus'];
  for(let i=0;i<numAI;i++) players.push(createPlayer(aiNames[i],false));
  for(const p of players) p.hand=deck.splice(0,5);
  const startPool=deck.splice(0,totalPlayers);
  let startIdx=0; let startName=startPool[0]?.name||'';
  for(let i=1;i<startPool.length;i++) if(startPool[i].name<startName){startName=startPool[i].name;startIdx=i;}
  G={deck,pool:startPool,sites,jacks:6,players,leaderIdx:startIdx%totalPlayers,phase:PHASE.LEADER_CHOICE,currentRole:null,turnCards:[],followDecisions:{},actionQueue:[],currentActionPlayer:-1,actionsRemaining:0,turnNumber:1};
  addLog('\u{1F3DB} Game started with '+totalPlayers+' players. '+players[startIdx%totalPlayers].name+' leads first.');
  addLog('\u2500\u2500\u2500 Turn 1: '+players[G.leaderIdx].name+' is Leader \u2500\u2500\u2500');
  document.getElementById('title-screen').classList.remove('active');
  document.getElementById('game-screen').classList.add('active');
  render(); scheduleAI();
}

function backToMenu() {
  G=null; logMessages=[];
  document.getElementById('game-screen').classList.remove('active');
  document.getElementById('title-screen').classList.add('active');
  initMenu();
}

initMenu();
</script>
</body>
</html>
