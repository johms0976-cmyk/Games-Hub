<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flip 7: With a Vengeance</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg-primary: #0a0a0f;
    --bg-secondary: #12121a;
    --bg-card: #1a1a2e;
    --bg-elevated: #222236;
    --gold: #d4a843;
    --gold-light: #f0d078;
    --gold-dark: #a07830;
    --crimson: #c0392b;
    --crimson-light: #e74c3c;
    --emerald: #27ae60;
    --emerald-light: #2ecc71;
    --blue: #2980b9;
    --blue-light: #3498db;
    --purple: #8e44ad;
    --purple-light: #9b59b6;
    --orange: #e67e22;
    --text-primary: #e8e0d0;
    --text-secondary: #a09880;
    --text-muted: #6a6050;
    --border: #2a2a3e;
    --border-gold: rgba(212, 168, 67, 0.3);
    --shadow: 0 4px 20px rgba(0,0,0,0.5);
    --glow-gold: 0 0 15px rgba(212, 168, 67, 0.3);
}

body {
    font-family: 'Outfit', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
}

h1, h2, h3, .card-rank { font-family: 'Cinzel', serif; }

/* ── SETUP SCREEN ── */
#setup-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 2rem;
    background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 70%);
}

.setup-title {
    font-family: 'Cinzel', serif;
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 900;
    color: var(--gold);
    text-align: center;
    margin-bottom: 0.25rem;
    text-shadow: 0 0 30px rgba(212, 168, 67, 0.4);
    letter-spacing: 2px;
}

.setup-subtitle {
    font-family: 'Cinzel', serif;
    font-size: clamp(0.9rem, 2vw, 1.3rem);
    color: var(--crimson-light);
    text-align: center;
    margin-bottom: 2rem;
    font-weight: 600;
    letter-spacing: 3px;
    text-transform: uppercase;
}

.setup-box {
    background: var(--bg-secondary);
    border: 1px solid var(--border-gold);
    border-radius: 16px;
    padding: 2rem;
    max-width: 500px;
    width: 100%;
    box-shadow: var(--shadow);
}

.setup-label {
    font-family: 'Cinzel', serif;
    font-size: 1rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
    display: block;
}

.setup-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.setup-input {
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: 'Outfit', sans-serif;
    font-size: 1rem;
    padding: 0.6rem 1rem;
    border-radius: 8px;
    width: 100%;
}

.setup-input:focus { outline: none; border-color: var(--gold); }

.player-count-btns {
    display: flex;
    gap: 0.5rem;
}

.count-btn {
    width: 48px;
    height: 48px;
    border-radius: 10px;
    border: 2px solid var(--border);
    background: var(--bg-card);
    color: var(--text-secondary);
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
}

.count-btn.active, .count-btn:hover {
    border-color: var(--gold);
    color: var(--gold);
    background: rgba(212, 168, 67, 0.1);
    box-shadow: var(--glow-gold);
}

.mode-btns {
    display: flex;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
}

.mode-btn {
    flex: 1;
    padding: 0.75rem;
    border-radius: 10px;
    border: 2px solid var(--border);
    background: var(--bg-card);
    color: var(--text-secondary);
    font-family: 'Outfit', sans-serif;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
}

.mode-btn.active {
    border-color: var(--gold);
    color: var(--gold);
    background: rgba(212, 168, 67, 0.1);
}

.mode-btn small {
    display: block;
    font-size: 0.7rem;
    color: var(--text-muted);
    margin-top: 4px;
}

.btn-start {
    width: 100%;
    padding: 1rem;
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--gold-dark), var(--gold));
    color: var(--bg-primary);
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    font-weight: 700;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.3s;
    text-transform: uppercase;
}

.btn-start:hover {
    background: linear-gradient(135deg, var(--gold), var(--gold-light));
    box-shadow: var(--glow-gold);
    transform: translateY(-2px);
}

/* ── GAME SCREEN ── */
#game-screen { display: none; }

.game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.25rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
}

.game-title {
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    color: var(--gold);
    font-weight: 700;
}

.game-info {
    display: flex;
    gap: 1.5rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.game-info span { display: flex; align-items: center; gap: 0.3rem; }
.game-info .val { color: var(--gold); font-weight: 600; }

/* ── SCOREBOARD ── */
.scoreboard {
    display: flex;
    gap: 0.5rem;
    padding: 0.75rem 1.25rem;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
    overflow-x: auto;
}

.score-chip {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.75rem;
    border-radius: 8px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    font-size: 0.8rem;
    white-space: nowrap;
    transition: all 0.3s;
}

.score-chip.active-player {
    border-color: var(--gold);
    box-shadow: var(--glow-gold);
}

.score-chip.busted { opacity: 0.4; border-color: var(--crimson); }
.score-chip.stayed { border-color: var(--emerald); }

.score-chip .name { color: var(--text-secondary); font-weight: 500; }
.score-chip .score { color: var(--gold); font-weight: 700; font-family: 'Cinzel', serif; }
.score-chip .round-score { color: var(--emerald-light); font-size: 0.7rem; }
.score-chip .bust-label { color: var(--crimson-light); font-size: 0.7rem; font-weight: 600; }
.score-chip .stay-label { color: var(--emerald); font-size: 0.7rem; font-weight: 600; }

/* ── PLAY AREA ── */
.play-area {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 1rem 1.25rem;
    min-height: calc(100vh - 200px);
}

.player-zone {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 0.75rem;
    transition: all 0.3s;
}

.player-zone.is-current {
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(212, 168, 67, 0.15);
}

.player-zone.is-busted { opacity: 0.4; }
.player-zone.is-stayed { border-color: var(--emerald); opacity: 0.85; }

.zone-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.zone-name {
    font-family: 'Cinzel', serif;
    font-size: 0.9rem;
    color: var(--text-primary);
    font-weight: 600;
}

.zone-name.you { color: var(--gold); }

.zone-status {
    font-size: 0.75rem;
    font-weight: 600;
    padding: 0.15rem 0.5rem;
    border-radius: 4px;
}

.zone-status.active { color: var(--emerald); background: rgba(39, 174, 96, 0.15); }
.zone-status.busted { color: var(--crimson-light); background: rgba(231, 76, 60, 0.15); }
.zone-status.stayed { color: var(--blue-light); background: rgba(52, 152, 219, 0.15); }

.zone-cards {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    min-height: 60px;
    align-items: flex-start;
}

/* ── CARDS ── */
.game-card {
    width: 52px;
    height: 72px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Cinzel', serif;
    font-weight: 700;
    position: relative;
    transition: all 0.3s;
    animation: cardFlip 0.4s ease-out;
    flex-shrink: 0;
}

@keyframes cardFlip {
    0% { transform: rotateY(90deg) scale(0.8); opacity: 0; }
    100% { transform: rotateY(0deg) scale(1); opacity: 1; }
}

.game-card.number-card {
    background: linear-gradient(145deg, #1e2a4a, #162040);
    border: 2px solid #3a4a6a;
    color: var(--text-primary);
}

.game-card.number-card .card-rank { font-size: 1.4rem; line-height: 1; }
.game-card.number-card .card-label { font-size: 0.5rem; color: var(--text-muted); font-family: 'Outfit', sans-serif; }

.game-card.special-card {
    border: 2px solid var(--purple-light);
    color: var(--purple-light);
}

.game-card.special-zero {
    background: linear-gradient(145deg, #1a1025, #120a20);
    border-color: #6a3a8a;
}

.game-card.special-seven {
    background: linear-gradient(145deg, #2a1020, #200a18);
    border-color: var(--crimson);
    color: var(--crimson-light);
}

.game-card.special-thirteen {
    background: linear-gradient(145deg, #1a2a10, #122008);
    border-color: var(--emerald);
    color: var(--emerald-light);
}

.game-card.modifier-card {
    background: linear-gradient(145deg, #2a2010, #201808);
    border: 2px solid var(--orange);
    color: var(--orange);
}

.game-card.action-card {
    background: linear-gradient(145deg, #0a1a2a, #081420);
    border: 2px solid var(--blue-light);
    color: var(--blue-light);
}

.game-card .card-rank { font-size: 1.1rem; line-height: 1; }
.game-card .card-label {
    font-size: 0.42rem;
    font-family: 'Outfit', sans-serif;
    text-align: center;
    line-height: 1.1;
    padding: 0 2px;
    max-width: 100%;
    font-weight: 400;
}

.game-card.face-down {
    background: linear-gradient(145deg, #1a1a2e, #12121a);
    border: 2px solid var(--border);
}

.game-card.face-down::after {
    content: '?';
    font-size: 1.5rem;
    color: var(--text-muted);
}

.modifier-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: var(--orange);
    color: var(--bg-primary);
    font-size: 0.55rem;
    font-weight: 700;
    padding: 1px 4px;
    border-radius: 4px;
    font-family: 'Outfit', sans-serif;
}

/* ── DECK AREA ── */
.deck-area {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
    padding: 1rem;
    margin: 0.5rem 0;
}

.deck-pile {
    width: 64px;
    height: 88px;
    background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
    border: 2px solid var(--gold-dark);
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: 3px 3px 10px rgba(0,0,0,0.5);
}

.deck-pile .deck-count {
    font-family: 'Cinzel', serif;
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--gold);
}

.deck-pile .deck-label {
    font-size: 0.6rem;
    color: var(--text-muted);
    margin-top: 2px;
}

.last-flipped {
    text-align: center;
}

.last-flipped .lf-label {
    font-size: 0.65rem;
    color: var(--text-muted);
    margin-bottom: 4px;
}

/* ── CONTROLS ── */
.controls {
    display: flex;
    gap: 0.75rem;
    justify-content: center;
    padding: 0.75rem 1.25rem;
    flex-wrap: wrap;
}

.ctrl-btn {
    padding: 0.7rem 1.5rem;
    border-radius: 10px;
    border: 2px solid var(--border);
    background: var(--bg-card);
    color: var(--text-primary);
    font-family: 'Outfit', sans-serif;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 100px;
    text-align: center;
}

.ctrl-btn:hover:not(:disabled) { border-color: var(--gold); color: var(--gold); transform: translateY(-1px); }
.ctrl-btn:disabled { opacity: 0.3; cursor: default; }

.ctrl-btn.hit-btn { border-color: var(--emerald); color: var(--emerald); }
.ctrl-btn.hit-btn:hover:not(:disabled) { background: rgba(39, 174, 96, 0.15); box-shadow: 0 0 15px rgba(39, 174, 96, 0.2); }

.ctrl-btn.stay-btn { border-color: var(--blue); color: var(--blue-light); }
.ctrl-btn.stay-btn:hover:not(:disabled) { background: rgba(52, 152, 219, 0.15); box-shadow: 0 0 15px rgba(52, 152, 219, 0.2); }

/* ── ACTION MODAL ── */
.modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    z-index: 100;
    align-items: center;
    justify-content: center;
    padding: 1rem;
}

.modal-overlay.active { display: flex; }

.modal-box {
    background: var(--bg-secondary);
    border: 1px solid var(--gold-dark);
    border-radius: 16px;
    padding: 1.5rem;
    max-width: 480px;
    width: 100%;
    box-shadow: 0 0 40px rgba(212, 168, 67, 0.2);
    max-height: 80vh;
    overflow-y: auto;
}

.modal-title {
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    color: var(--gold);
    margin-bottom: 0.75rem;
    text-align: center;
}

.modal-text {
    font-size: 0.9rem;
    color: var(--text-secondary);
    margin-bottom: 1rem;
    text-align: center;
    line-height: 1.5;
}

.modal-choices {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.modal-choice {
    padding: 0.75rem 1rem;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--bg-card);
    color: var(--text-primary);
    font-family: 'Outfit', sans-serif;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
}

.modal-choice:hover {
    border-color: var(--gold);
    color: var(--gold);
    background: rgba(212, 168, 67, 0.08);
}

.modal-choice.disabled { opacity: 0.3; cursor: default; pointer-events: none; }

/* ── LOG ── */
.game-log {
    max-height: 120px;
    overflow-y: auto;
    padding: 0.5rem 1.25rem;
    background: var(--bg-primary);
    border-top: 1px solid var(--border);
    font-size: 0.75rem;
    color: var(--text-muted);
    line-height: 1.6;
}

.game-log .log-entry { padding: 1px 0; }
.game-log .log-entry.important { color: var(--gold); font-weight: 500; }
.game-log .log-entry.bust { color: var(--crimson-light); }
.game-log .log-entry.action { color: var(--blue-light); }
.game-log .log-entry.score { color: var(--emerald-light); }

/* ── ROUND SUMMARY ── */
.round-summary {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 200;
    align-items: center;
    justify-content: center;
    padding: 1rem;
}

.round-summary.active { display: flex; }

.summary-box {
    background: var(--bg-secondary);
    border: 1px solid var(--gold-dark);
    border-radius: 16px;
    padding: 2rem;
    max-width: 500px;
    width: 100%;
    text-align: center;
    box-shadow: 0 0 40px rgba(212, 168, 67, 0.2);
}

.summary-title {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.summary-scores {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
}

.summary-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    background: var(--bg-card);
}

.summary-row .s-name { color: var(--text-secondary); font-weight: 500; }
.summary-row .s-round { color: var(--emerald-light); font-weight: 600; }
.summary-row .s-total { color: var(--gold); font-weight: 700; font-family: 'Cinzel', serif; }
.summary-row .s-bust { color: var(--crimson-light); font-style: italic; }
.summary-row.winner { border: 1px solid var(--gold); background: rgba(212, 168, 67, 0.08); }

/* ── GAME OVER ── */
.game-over-screen {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    z-index: 300;
    align-items: center;
    justify-content: center;
    padding: 1rem;
}

.game-over-screen.active { display: flex; }

.go-box {
    text-align: center;
    max-width: 500px;
}

.go-title {
    font-family: 'Cinzel', serif;
    font-size: 2.5rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
    text-shadow: 0 0 30px rgba(212, 168, 67, 0.5);
}

.go-winner {
    font-size: 1.2rem;
    color: var(--text-primary);
    margin-bottom: 2rem;
}

.go-final-scores {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 2rem;
}

.go-score-row {
    display: flex;
    justify-content: space-between;
    padding: 0.6rem 1rem;
    border-radius: 8px;
    background: var(--bg-card);
    border: 1px solid var(--border);
}

.go-score-row.winner-row { border-color: var(--gold); box-shadow: var(--glow-gold); }
.go-score-row .gs-name { color: var(--text-secondary); }
.go-score-row .gs-score { color: var(--gold); font-family: 'Cinzel', serif; font-weight: 700; }

/* ── TOAST ── */
.toast {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: var(--bg-secondary);
    border: 2px solid var(--gold);
    border-radius: 16px;
    padding: 1.25rem 2rem;
    font-family: 'Cinzel', serif;
    font-size: 1.3rem;
    color: var(--gold);
    text-align: center;
    z-index: 500;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s;
    box-shadow: 0 0 40px rgba(212, 168, 67, 0.4);
}

.toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
.toast.bust-toast { border-color: var(--crimson); color: var(--crimson-light); box-shadow: 0 0 40px rgba(231, 76, 60, 0.4); }
.toast.flip7-toast { border-color: var(--emerald); color: var(--emerald-light); box-shadow: 0 0 40px rgba(46, 204, 113, 0.4); }

/* ── RESPONSIVE ── */
@media (max-width: 600px) {
    .game-card { width: 44px; height: 62px; }
    .game-card .card-rank { font-size: 1rem; }
    .game-card .card-label { font-size: 0.38rem; }
    .controls { padding: 0.5rem; }
    .ctrl-btn { padding: 0.6rem 1rem; font-size: 0.85rem; min-width: 80px; }
}

/* ── HELP OVERLAY ── */
.help-btn {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-muted);
    width: 32px;
    height: 32px;
    border-radius: 50%;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 0.9rem;
    transition: all 0.2s;
}

.help-btn:hover { border-color: var(--gold); color: var(--gold); }

.help-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    z-index: 400;
    overflow-y: auto;
    padding: 2rem;
}

.help-overlay.active { display: block; }

.help-content {
    max-width: 600px;
    margin: 0 auto;
    background: var(--bg-secondary);
    border-radius: 16px;
    padding: 2rem;
    border: 1px solid var(--border-gold);
}

.help-content h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.3rem;
    margin: 1.25rem 0 0.5rem;
}

.help-content h2:first-child { margin-top: 0; }

.help-content p, .help-content li {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 0.5rem;
}

.help-content ul { padding-left: 1.2rem; }

.help-close {
    display: block;
    margin: 1.5rem auto 0;
    padding: 0.6rem 2rem;
    border-radius: 8px;
    border: 1px solid var(--gold);
    background: none;
    color: var(--gold);
    font-family: 'Outfit', sans-serif;
    font-size: 0.9rem;
    cursor: pointer;
}
</style>
</head>
<body>

<!-- SETUP -->
<div id="setup-screen">
    <div class="setup-title">Flip 7</div>
    <div class="setup-subtitle">With a Vengeance</div>
    <div class="setup-box">
        <label class="setup-label">Your Name</label>
        <div class="setup-row">
            <input type="text" class="setup-input" id="player-name" value="You" maxlength="16">
        </div>

        <label class="setup-label">Players</label>
        <div class="setup-row">
            <div class="player-count-btns" id="count-btns">
                <button class="count-btn" data-count="3">3</button>
                <button class="count-btn active" data-count="4">4</button>
                <button class="count-btn" data-count="5">5</button>
                <button class="count-btn" data-count="6">6</button>
            </div>
        </div>

        <label class="setup-label">Mode</label>
        <div class="mode-btns">
            <button class="mode-btn active" data-mode="normal">Normal<small>Score ≥ 0</small></button>
            <button class="mode-btn" data-mode="brutal">Brutal<small>Score can go negative</small></button>
        </div>

        <button class="btn-start" id="btn-start">Deal Me In</button>
    </div>
</div>

<!-- GAME -->
<div id="game-screen">
    <div class="game-header">
        <div class="game-title">Flip 7: With a Vengeance</div>
        <div class="game-info">
            <span>Round <span class="val" id="round-num">1</span></span>
            <span>Target <span class="val">200</span></span>
            <button class="help-btn" id="help-btn">?</button>
        </div>
    </div>

    <div class="scoreboard" id="scoreboard"></div>

    <div class="deck-area">
        <div class="deck-pile" id="deck-pile">
            <div class="deck-count" id="deck-count">108</div>
            <div class="deck-label">DECK</div>
        </div>
        <div class="last-flipped" id="last-flipped">
            <div class="lf-label">Last Flipped</div>
        </div>
    </div>

    <div class="play-area" id="play-area"></div>

    <div class="controls" id="controls">
        <button class="ctrl-btn hit-btn" id="btn-hit" disabled>Hit</button>
        <button class="ctrl-btn stay-btn" id="btn-stay" disabled>Stay</button>
    </div>

    <div class="game-log" id="game-log"></div>
</div>

<!-- ACTION MODAL -->
<div class="modal-overlay" id="action-modal">
    <div class="modal-box">
        <div class="modal-title" id="modal-title">Action</div>
        <div class="modal-text" id="modal-text"></div>
        <div class="modal-choices" id="modal-choices"></div>
    </div>
</div>

<!-- ROUND SUMMARY -->
<div class="round-summary" id="round-summary">
    <div class="summary-box">
        <div class="summary-title" id="summary-title">Round Complete</div>
        <div class="summary-scores" id="summary-scores"></div>
        <button class="ctrl-btn" id="btn-next-round" style="margin:0 auto;">Next Round</button>
    </div>
</div>

<!-- GAME OVER -->
<div class="game-over-screen" id="game-over">
    <div class="go-box">
        <div class="go-title">Game Over</div>
        <div class="go-winner" id="go-winner"></div>
        <div class="go-final-scores" id="go-final-scores"></div>
        <button class="btn-start" id="btn-new-game" style="max-width:300px;margin:0 auto;">Play Again</button>
    </div>
</div>

<!-- HELP -->
<div class="help-overlay" id="help-overlay">
    <div class="help-content">
        <h2>How to Play</h2>
        <p>Flip 7 is a press-your-luck game. Be the first to score <strong>200 points</strong>.</p>

        <h2>Each Round</h2>
        <p>Cards are flipped one at a time for each active player. On your turn, choose to <strong>Hit</strong> (take a card) or <strong>Stay</strong> (stop and lock in your cards).</p>

        <h2>Number Cards</h2>
        <p>Your score is the sum of your number cards. But if you flip a duplicate number, you <strong>bust</strong> and score nothing!</p>

        <h2>Flip 7</h2>
        <p>Get 7 different number cards to <strong>Flip 7</strong> — this ends the round immediately and earns you 15 bonus points.</p>

        <h2>Special Cards</h2>
        <ul>
            <li><strong>The Zero:</strong> Your score becomes 0 unless you Flip 7. You must keep hitting.</li>
            <li><strong>Unlucky 7:</strong> Discard all other cards. Can't bust on it.</li>
            <li><strong>Lucky 13:</strong> Allows you to have a second 13 without busting.</li>
        </ul>

        <h2>Action Cards</h2>
        <ul>
            <li><strong>Steal:</strong> Take any face-up card from another player.</li>
            <li><strong>Swap:</strong> Exchange any two face-up cards between players.</li>
            <li><strong>Discard:</strong> Force a player to remove one card.</li>
            <li><strong>Just One More:</strong> Force a player to take one more card and then stay.</li>
            <li><strong>Flip Four:</strong> Force a player to take 4 cards in a row.</li>
        </ul>

        <h2>Modifier Cards</h2>
        <p>Played on any non-busted player. Subtract from (or halve) their number total.</p>

        <h2>Brutal Mode</h2>
        <p>Scores can go negative. Modifiers can target busted players. Flip 7 lets you subtract 15 from another player instead.</p>

        <button class="help-close" id="help-close">Got It</button>
    </div>
</div>

<!-- TOAST -->
<div class="toast" id="toast"></div>

<script>
// ═══════════════════════════════════════════
//  FLIP 7: WITH A VENGEANCE
// ═══════════════════════════════════════════

const AI_NAMES = ['Raven', 'Blaze', 'Frost', 'Viper', 'Storm', 'Nyx', 'Jinx', 'Ace'];

// ── State ──
let G = {};

function initState(playerName, numPlayers, mode) {
    const names = [playerName];
    const shuffled = [...AI_NAMES].sort(() => Math.random() - 0.5);
    for (let i = 1; i < numPlayers; i++) names.push(shuffled[i - 1]);

    G = {
        players: names.map((n, i) => ({
            name: n,
            isHuman: i === 0,
            totalScore: 0,
            cards: [],         // {type, value, label, ...}
            modifiers: [],     // modifier cards played ON this player
            busted: false,
            stayed: false,
            hasZero: false,
            hasLucky13: false,
            forcedStay: false,
        })),
        deck: [],
        discard: [],
        round: 1,
        dealerIndex: 0,
        currentPlayerIndex: 0,
        mode: mode, // 'normal' or 'brutal'
        phase: 'dealing', // 'dealing', 'turns', 'roundEnd', 'gameOver'
        actionQueue: [],
        turnOrder: [],
        turnIndex: 0,
        waitingForAction: false,
        lastFlippedCard: null,
    };

    buildDeck();
    shuffleDeck();
}

function buildDeck() {
    G.deck = [];
    // Number cards: N copies of value N (1-13)
    for (let v = 1; v <= 13; v++) {
        for (let c = 0; c < v; c++) {
            G.deck.push({ type: 'number', value: v, label: String(v) });
        }
    }
    // Special number cards
    G.deck.push({ type: 'special', subtype: 'zero', value: 0, label: '0', desc: 'Score zero unless Flip 7' });
    G.deck.push({ type: 'special', subtype: 'unlucky7', value: 7, label: '7!', desc: 'Discard all other cards' });
    G.deck.push({ type: 'special', subtype: 'lucky13', value: 13, label: '13★', desc: 'May have one other 13' });

    // Modifier cards
    [-2, -4, -6, -8, -10].forEach(v => {
        for (let i = 0; i < 2; i++) G.deck.push({ type: 'modifier', value: v, label: String(v) });
    });
    for (let i = 0; i < 2; i++) G.deck.push({ type: 'modifier', value: 0.5, label: '÷2', isDivide: true });

    // Action cards
    G.deck.push({ type: 'action', subtype: 'steal', label: 'STEAL', desc: 'Steal any face-up card' });
    G.deck.push({ type: 'action', subtype: 'swap', label: 'SWAP', desc: 'Swap any two face-up cards' });
    G.deck.push({ type: 'action', subtype: 'discard', label: 'TOSS', desc: 'Force a player to discard a card' });
    G.deck.push({ type: 'action', subtype: 'justonemore', label: '+1!', desc: 'Force a player to hit then stay' });
    G.deck.push({ type: 'action', subtype: 'flipfour', label: 'FLIP4', desc: 'Force a player to take 4 cards' });
}

function shuffleDeck() {
    for (let i = G.deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [G.deck[i], G.deck[j]] = [G.deck[j], G.deck[i]];
    }
}

function drawCard() {
    if (G.deck.length === 0) {
        G.deck = [...G.discard];
        G.discard = [];
        shuffleDeck();
        addLog('Deck reshuffled from discard pile.', 'important');
    }
    if (G.deck.length === 0) return null;
    return G.deck.pop();
}

// ── Scoring ──
function calcPlayerRoundScore(p) {
    if (p.busted) return 0;

    let numCards = p.cards.filter(c => c.type === 'number' || c.type === 'special');
    let isFlip7 = getNumberCardCount(p) >= 7;

    if (p.hasZero && !isFlip7) return 0;

    let sum = 0;
    for (const c of numCards) sum += c.value;

    // Apply ÷2 first
    let hasDivide = p.modifiers.some(m => m.isDivide);
    if (hasDivide) sum = Math.floor(sum / 2);

    // Subtract modifiers
    for (const m of p.modifiers) {
        if (!m.isDivide) sum += m.value; // value is negative
    }

    if (G.mode !== 'brutal' && sum < 0) sum = 0;

    if (isFlip7) sum += 15;

    return sum;
}

function getNumberCardCount(p) {
    return p.cards.filter(c => c.type === 'number' || c.type === 'special').length;
}

function getUniqueNumberCount(p) {
    let nums = new Set();
    for (const c of p.cards) {
        if (c.type === 'number' || c.type === 'special') nums.add(c.value);
    }
    return nums.size;
}

function checkFlip7(p) {
    // Flip 7 = 7 number/special cards in your line
    // Normally impossible to have dupes (bust), but Lucky 13 allows two 13s
    return getNumberCardCount(p) >= 7;
}

function getNumberValues(p) {
    return p.cards.filter(c => c.type === 'number' || c.type === 'special').map(c => c.value);
}

function wouldBust(p, card) {
    if (card.type !== 'number' && card.type !== 'special') return false;
    if (card.type === 'special' && card.subtype === 'unlucky7') return false;

    const vals = getNumberValues(p);
    const incomingVal = card.value;

    if (incomingVal === 13 && p.hasLucky13 && vals.filter(v => v === 13).length <= 1) return false;

    return vals.includes(incomingVal);
}

function isPlayerActive(p) {
    return !p.busted && !p.stayed;
}

function anyActivePlayer() {
    return G.players.some(p => isPlayerActive(p));
}

function getNonBustedPlayers() {
    return G.players.filter(p => !p.busted);
}

function getActivePlayers() {
    return G.players.filter(p => isPlayerActive(p));
}

// ── Card Application ──
function giveCardToPlayer(p, card) {
    if (card.type === 'number') {
        if (wouldBust(p, card)) {
            p.cards.push(card);
            p.busted = true;
            addLog(`${p.name} flipped ${card.label} — BUST! (duplicate)`, 'bust');
            showToast(`${p.name} BUSTED!`, 'bust');
            return 'bust';
        }
        p.cards.push(card);
        if (checkFlip7(p)) {
            addLog(`${p.name} achieved FLIP 7!`, 'important');
            showToast(`${p.name} — FLIP 7!`, 'flip7');
            return 'flip7';
        }
        return 'ok';
    }

    if (card.type === 'special') {
        return applySpecialCard(p, card);
    }

    if (card.type === 'modifier') {
        // Modifier dealt to active player — they choose target
        return 'modifier';
    }

    if (card.type === 'action') {
        return 'action';
    }

    return 'ok';
}

function applySpecialCard(p, card) {
    if (card.subtype === 'zero') {
        if (wouldBust(p, card)) {
            p.cards.push(card);
            p.busted = true;
            addLog(`${p.name} flipped The Zero — BUST! (duplicate 0)`, 'bust');
            showToast(`${p.name} BUSTED!`, 'bust');
            return 'bust';
        }
        p.cards.push(card);
        p.hasZero = true;
        addLog(`${p.name} flipped The Zero! Score is 0 unless Flip 7. Must keep hitting.`, 'action');
        return 'ok';
    }

    if (card.subtype === 'unlucky7') {
        // Discard all other cards, keep only this 7
        const oldCards = [...p.cards];
        const oldMods = [...p.modifiers];
        p.cards = [card];
        p.modifiers = [];
        p.hasZero = false;
        p.hasLucky13 = false;
        for (const c of oldCards) G.discard.push(c);
        for (const m of oldMods) G.discard.push(m);
        addLog(`${p.name} flipped Unlucky 7! All other cards discarded.`, 'action');
        return 'ok';
    }

    if (card.subtype === 'lucky13') {
        // Lucky 13 allows holding TWO 13s total. Only bust on a THIRD 13.
        const existing13s = getNumberValues(p).filter(v => v === 13).length;
        if (existing13s >= 2) {
            // Already have 2 thirteens — a third busts
            p.cards.push(card);
            p.busted = true;
            addLog(`${p.name} flipped Lucky 13 — BUST! (third 13)`, 'bust');
            showToast(`${p.name} BUSTED!`, 'bust');
            return 'bust';
        }
        // Safe — set flag BEFORE adding card
        p.hasLucky13 = true;
        p.cards.push(card);
        addLog(`${p.name} flipped Lucky 13! May hold a second 13.`, 'action');
        if (checkFlip7(p)) {
            addLog(`${p.name} achieved FLIP 7!`, 'important');
            showToast(`${p.name} — FLIP 7!`, 'flip7');
            return 'flip7';
        }
        return 'ok';
    }

    return 'ok';
}

// ── UI Rendering ──
function render() {
    renderScoreboard();
    renderPlayArea();
    renderDeck();
    renderControls();
}

function renderScoreboard() {
    const sb = document.getElementById('scoreboard');
    sb.innerHTML = G.players.map((p, i) => {
        let cls = 'score-chip';
        if (i === G.currentPlayerIndex && G.phase === 'turns') cls += ' active-player';
        if (p.busted) cls += ' busted';
        else if (p.stayed) cls += ' stayed';

        let statusHtml = '';
        if (p.busted) statusHtml = '<span class="bust-label">BUST</span>';
        else if (p.stayed) statusHtml = '<span class="stay-label">STAYED</span>';
        else {
            const rs = calcPlayerRoundScore(p);
            if (p.cards.length > 0) statusHtml = `<span class="round-score">+${rs}</span>`;
        }

        return `<div class="${cls}">
            <span class="name">${p.isHuman ? '★ ' : ''}${p.name}</span>
            <span class="score">${p.totalScore}</span>
            ${statusHtml}
        </div>`;
    }).join('');
}

function renderPlayArea() {
    const area = document.getElementById('play-area');
    area.innerHTML = G.players.map((p, i) => {
        let cls = 'player-zone';
        if (i === G.currentPlayerIndex && G.phase === 'turns') cls += ' is-current';
        if (p.busted) cls += ' is-busted';
        else if (p.stayed) cls += ' is-stayed';

        let statusCls = p.busted ? 'busted' : (p.stayed ? 'stayed' : 'active');
        let statusText = p.busted ? 'BUST' : (p.stayed ? 'STAYED' : 'ACTIVE');

        let cardsHtml = p.cards.map(c => renderCard(c, false)).join('');
        let modsHtml = p.modifiers.map(m => renderCard(m, false)).join('');

        let scorePreview = '';
        if (!p.busted && p.cards.length > 0) {
            scorePreview = `<span style="font-size:0.75rem;color:var(--gold);font-weight:600;">${calcPlayerRoundScore(p)} pts</span>`;
        }

        return `<div class="${cls}" id="zone-${i}">
            <div class="zone-header">
                <span class="zone-name ${p.isHuman ? 'you' : ''}">${p.isHuman ? '★ ' : ''}${p.name} ${p.isHuman ? '(You)' : ''}</span>
                <span>${scorePreview}</span>
                <span class="zone-status ${statusCls}">${statusText}</span>
            </div>
            <div class="zone-cards" id="cards-${i}">${modsHtml}${cardsHtml}</div>
        </div>`;
    }).join('');
}

function renderCard(c, small) {
    if (c.type === 'number') {
        return `<div class="game-card number-card">
            <div class="card-rank">${c.value}</div>
        </div>`;
    }
    if (c.type === 'special') {
        let cls = 'game-card special-card';
        if (c.subtype === 'zero') cls = 'game-card special-zero';
        if (c.subtype === 'unlucky7') cls = 'game-card special-seven';
        if (c.subtype === 'lucky13') cls = 'game-card special-thirteen';
        return `<div class="${cls}">
            <div class="card-rank">${c.label}</div>
            <div class="card-label">${c.subtype === 'zero' ? 'ZERO' : c.subtype === 'unlucky7' ? 'UNLUCKY' : 'LUCKY'}</div>
        </div>`;
    }
    if (c.type === 'modifier') {
        return `<div class="game-card modifier-card">
            <div class="card-rank">${c.label}</div>
            <div class="card-label">MOD</div>
        </div>`;
    }
    if (c.type === 'action') {
        return `<div class="game-card action-card">
            <div class="card-rank">${c.label}</div>
            <div class="card-label">${c.desc ? c.desc.substring(0, 20) : ''}</div>
        </div>`;
    }
    return '';
}

function renderDeck() {
    document.getElementById('deck-count').textContent = G.deck.length;
    const lf = document.getElementById('last-flipped');
    if (G.lastFlippedCard) {
        lf.innerHTML = `<div class="lf-label">Last Flipped</div>${renderCard(G.lastFlippedCard)}`;
    } else {
        lf.innerHTML = `<div class="lf-label">Last Flipped</div><div class="game-card face-down"></div>`;
    }
}

function renderControls() {
    const hitBtn = document.getElementById('btn-hit');
    const stayBtn = document.getElementById('btn-stay');

    if (G.phase === 'turns' && G.players[G.currentPlayerIndex].isHuman && !G.waitingForAction) {
        const p = G.players[G.currentPlayerIndex];
        const canHit = isPlayerActive(p);
        const canStay = isPlayerActive(p) && !p.hasZero;
        hitBtn.disabled = !canHit;
        stayBtn.disabled = !canStay;
        if (p.hasZero && isPlayerActive(p)) {
            stayBtn.textContent = 'Must Hit (Zero)';
        } else {
            stayBtn.textContent = 'Stay';
        }
    } else {
        hitBtn.disabled = true;
        stayBtn.disabled = true;
        stayBtn.textContent = 'Stay';
    }
}

function addLog(text, cls = '') {
    const log = document.getElementById('game-log');
    const entry = document.createElement('div');
    entry.className = 'log-entry' + (cls ? ` ${cls}` : '');
    entry.textContent = text;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

function showToast(text, type = '') {
    const toast = document.getElementById('toast');
    toast.textContent = text;
    toast.className = 'toast show' + (type === 'bust' ? ' bust-toast' : type === 'flip7' ? ' flip7-toast' : '');
    setTimeout(() => { toast.className = 'toast'; }, 1500);
}

// ── Game Flow ──
function startRound() {
    G.phase = 'dealing';
    for (const p of G.players) {
        p.cards = [];
        p.modifiers = [];
        p.busted = false;
        p.stayed = false;
        p.hasZero = false;
        p.hasLucky13 = false;
        p.forcedStay = false;
    }
    G.lastFlippedCard = null;
    document.getElementById('round-num').textContent = G.round;
    addLog(`── Round ${G.round} ──`, 'important');
    render();

    // Initial deal: one card to each player clockwise from dealer
    dealInitialCards(0);
}

async function dealInitialCards(idx) {
    const order = [];
    for (let i = 1; i <= G.players.length; i++) {
        order.push((G.dealerIndex + i) % G.players.length);
    }

    for (let i = idx; i < order.length; i++) {
        const pi = order[i];
        const p = G.players[pi];
        await delay(400);
        const card = drawCard();
        if (!card) break;
        G.lastFlippedCard = card;

        addLog(`${p.name} flipped: ${cardName(card)}`);

        if (card.type === 'action' || card.type === 'modifier') {
            // Resolve action/modifier for this player
            const result = await resolveFlippedCard(pi, card);
            if (result === 'flip7') { endRound(); return; }
            render();
            continue;
        }

        const result = giveCardToPlayer(p, card);
        render();
        if (result === 'flip7') { endRound(); return; }
    }

    // Begin turn-based phase
    startTurnPhase();
}

async function resolveFlippedCard(playerIndex, card) {
    const p = G.players[playerIndex];

    if (card.type === 'modifier') {
        // Player who flipped it chooses a target
        const target = await chooseModifierTarget(playerIndex, card);
        if (target !== null) {
            G.players[target].modifiers.push(card);
            addLog(`${p.name} played ${card.label} modifier on ${G.players[target].name}`, 'action');
        } else {
            G.discard.push(card);
        }
        return 'ok';
    }

    if (card.type === 'action') {
        return await resolveAction(playerIndex, card);
    }

    return 'ok';
}

async function resolveAction(playerIndex, card) {
    const p = G.players[playerIndex];
    const sub = card.subtype;

    if (sub === 'steal') {
        const result = await resolveSteal(playerIndex);
        G.discard.push(card);
        return result;
    }
    if (sub === 'swap') {
        await resolveSwap(playerIndex);
        G.discard.push(card);
        return 'ok';
    }
    if (sub === 'discard') {
        await resolveDiscard(playerIndex);
        G.discard.push(card);
        return 'ok';
    }
    if (sub === 'justonemore') {
        const result = await resolveJustOneMore(playerIndex);
        G.discard.push(card);
        return result;
    }
    if (sub === 'flipfour') {
        const result = await resolveFlipFour(playerIndex);
        G.discard.push(card);
        return result;
    }

    G.discard.push(card);
    return 'ok';
}

// ── Action Resolvers ──
function getAllFaceUpCards() {
    // Returns [{playerIndex, cardIndex, card}]
    let results = [];
    for (let pi = 0; pi < G.players.length; pi++) {
        const p = G.players[pi];
        if (p.busted) continue;
        for (let ci = 0; ci < p.cards.length; ci++) {
            results.push({ playerIndex: pi, cardIndex: ci, card: p.cards[ci] });
        }
        for (let mi = 0; mi < p.modifiers.length; mi++) {
            results.push({ playerIndex: pi, cardIndex: mi, card: p.modifiers[mi], isMod: true });
        }
    }
    return results;
}

async function resolveSteal(playerIndex) {
    const p = G.players[playerIndex];
    const targets = getAllFaceUpCards().filter(t => t.playerIndex !== playerIndex);
    if (targets.length === 0) {
        addLog('No cards to steal. Action discarded.', 'action');
        return 'ok';
    }

    if (p.isHuman) {
        const choice = await showActionModal('Steal', 'Choose a card to steal:',
            targets.map(t => `${G.players[t.playerIndex].name}'s ${cardName(t.card)}`)
        );
        if (choice >= 0) {
            const t = targets[choice];
            return executeSteal(playerIndex, t);
        }
    } else {
        // AI: steal highest value card from opponents
        const best = targets.filter(t => t.card.type === 'number' || t.card.type === 'special')
            .sort((a, b) => b.card.value - a.card.value)[0];
        if (best) {
            return executeSteal(playerIndex, best);
        }
    }
    return 'ok';
}

function executeSteal(playerIndex, target) {
    const p = G.players[playerIndex];
    const tp = G.players[target.playerIndex];
    const card = target.card;

    if (target.isMod) {
        tp.modifiers.splice(target.cardIndex, 1);
        p.modifiers.push(card);
    } else {
        tp.cards.splice(target.cardIndex, 1);
        // Check if giving to this player causes bust
        if (wouldBust(p, card)) {
            p.cards.push(card);
            p.busted = true;
            addLog(`${p.name} stole ${cardName(card)} from ${tp.name} — BUST!`, 'bust');
            showToast(`${p.name} BUSTED!`, 'bust');
            return 'bust';
        }
        p.cards.push(card);
        if (card.type === 'special' && card.subtype === 'zero') p.hasZero = true;
        if (card.type === 'special' && card.subtype === 'lucky13') p.hasLucky13 = true;
    }
    // Clean up stolen-from player
    recalcSpecialFlags(tp);

    addLog(`${p.name} stole ${cardName(card)} from ${tp.name}`, 'action');
    if (checkFlip7(p)) {
        showToast(`${p.name} — FLIP 7!`, 'flip7');
        return 'flip7';
    }
    return 'ok';
}

async function resolveSwap(playerIndex) {
    const p = G.players[playerIndex];
    const allCards = getAllFaceUpCards();
    if (allCards.length < 2) {
        addLog('Not enough cards to swap. Action discarded.', 'action');
        return;
    }

    if (p.isHuman) {
        const c1 = await showActionModal('Swap — Pick First Card', 'Choose the first card to swap:',
            allCards.map(t => `${G.players[t.playerIndex].name}'s ${cardName(t.card)}`)
        );
        if (c1 < 0) return;
        const remaining = allCards.filter((_, i) => i !== c1);
        const c2 = await showActionModal('Swap — Pick Second Card', 'Choose the second card to swap:',
            remaining.map(t => `${G.players[t.playerIndex].name}'s ${cardName(t.card)}`)
        );
        if (c2 < 0) return;
        executeSwap(allCards[c1], remaining[c2]);
    } else {
        // AI: swap its lowest card with opponent's highest
        const myCards = allCards.filter(t => t.playerIndex === playerIndex && !t.isMod && (t.card.type === 'number' || t.card.type === 'special'));
        const otherCards = allCards.filter(t => t.playerIndex !== playerIndex && !t.isMod && (t.card.type === 'number' || t.card.type === 'special'));
        if (myCards.length > 0 && otherCards.length > 0) {
            const myWorst = myCards.sort((a, b) => a.card.value - b.card.value)[0];
            const theirBest = otherCards.sort((a, b) => b.card.value - a.card.value)[0];
            if (theirBest.card.value > myWorst.card.value) {
                executeSwap(myWorst, theirBest);
                return;
            }
        }
        // Otherwise swap modifier onto opponent
        addLog(`${p.name} couldn't find a good swap.`, 'action');
    }
}

function executeSwap(t1, t2) {
    const p1 = G.players[t1.playerIndex];
    const p2 = G.players[t2.playerIndex];
    const card1 = t1.isMod ? p1.modifiers[t1.cardIndex] : p1.cards[t1.cardIndex];
    const card2 = t2.isMod ? p2.modifiers[t2.cardIndex] : p2.cards[t2.cardIndex];

    // Remove
    if (t1.isMod) p1.modifiers.splice(t1.cardIndex, 1);
    else p1.cards.splice(t1.cardIndex, 1);

    if (t2.isMod) p2.modifiers.splice(t2.cardIndex, 1);
    else p2.cards.splice(t2.cardIndex, 1);

    // Give card2 to p1, card1 to p2
    if (t1.isMod) p2.modifiers.push(card1);
    else {
        // Check bust
        if (wouldBust(p2, card1)) { p2.cards.push(card1); p2.busted = true; showToast(`${p2.name} BUSTED!`, 'bust'); }
        else p2.cards.push(card1);
    }

    if (t2.isMod) p1.modifiers.push(card2);
    else {
        if (wouldBust(p1, card2)) { p1.cards.push(card2); p1.busted = true; showToast(`${p1.name} BUSTED!`, 'bust'); }
        else p1.cards.push(card2);
    }

    recalcSpecialFlags(p1);
    recalcSpecialFlags(p2);

    addLog(`Swapped ${cardName(card1)} (${p1.name}) ↔ ${cardName(card2)} (${p2.name})`, 'action');
}

async function resolveDiscard(playerIndex) {
    const p = G.players[playerIndex];
    const targets = getAllFaceUpCards().filter(t => t.playerIndex !== playerIndex);
    if (targets.length === 0) {
        addLog('No cards to discard. Action discarded.', 'action');
        return;
    }

    if (p.isHuman) {
        const choice = await showActionModal('Discard', 'Choose a card to force discard:',
            targets.map(t => `${G.players[t.playerIndex].name}'s ${cardName(t.card)}`)
        );
        if (choice >= 0) executeDiscard(targets[choice]);
    } else {
        // AI: discard opponent's highest value card
        const best = targets.filter(t => !t.isMod && (t.card.type === 'number' || t.card.type === 'special'))
            .sort((a, b) => b.card.value - a.card.value)[0];
        if (best) executeDiscard(best);
        else {
            // Remove a modifier from an opponent (if it helps them)
            const modTarget = targets.filter(t => t.isMod).sort((a, b) => a.card.value - b.card.value)[0];
            if (modTarget) executeDiscard(modTarget);
        }
    }
}

function executeDiscard(target) {
    const tp = G.players[target.playerIndex];
    const card = target.card;
    if (target.isMod) {
        tp.modifiers.splice(target.cardIndex, 1);
    } else {
        tp.cards.splice(target.cardIndex, 1);
    }
    G.discard.push(card);
    recalcSpecialFlags(tp);
    addLog(`${tp.name} was forced to discard ${cardName(card)}`, 'action');
}

async function resolveJustOneMore(playerIndex) {
    const p = G.players[playerIndex];
    const targets = G.players.map((pl, i) => ({ player: pl, index: i }))
        .filter(t => !t.player.busted && t.index !== playerIndex);

    if (targets.length === 0) {
        addLog('No valid targets. Action discarded.', 'action');
        return 'ok';
    }

    let targetIndex;
    if (p.isHuman) {
        const choice = await showActionModal('Just One More!', 'Force a player to take one more card:',
            targets.map(t => t.player.name)
        );
        if (choice < 0) return 'ok';
        targetIndex = targets[choice].index;
    } else {
        // AI: target the player with most points who isn't busted
        const sorted = targets.sort((a, b) => {
            const sa = calcPlayerRoundScore(b.player) + b.player.totalScore;
            const sb = calcPlayerRoundScore(a.player) + a.player.totalScore;
            return sa - sb;
        });
        targetIndex = sorted[0].index;
    }

    const target = G.players[targetIndex];
    addLog(`${p.name} forces ${target.name} to take one more card!`, 'action');

    const card = drawCard();
    if (!card) return 'ok';
    G.lastFlippedCard = card;
    addLog(`${target.name} flipped: ${cardName(card)}`);

    if (card.type === 'action' || card.type === 'modifier') {
        const result = await resolveFlippedCard(targetIndex, card);
        target.stayed = true;
        target.forcedStay = true;
        render();
        return result;
    }

    const result = giveCardToPlayer(target, card);
    if (result !== 'bust') {
        target.stayed = true;
        target.forcedStay = true;
    }
    render();
    return result;
}

async function resolveFlipFour(playerIndex) {
    const p = G.players[playerIndex];
    const targets = G.players.map((pl, i) => ({ player: pl, index: i }))
        .filter(t => !t.player.busted && t.index !== playerIndex);

    if (targets.length === 0) {
        addLog('No valid targets. Action discarded.', 'action');
        return 'ok';
    }

    let targetIndex;
    if (p.isHuman) {
        const choice = await showActionModal('Flip Four!', 'Force a player to take 4 cards:',
            targets.map(t => t.player.name)
        );
        if (choice < 0) return 'ok';
        targetIndex = targets[choice].index;
    } else {
        const sorted = targets.sort((a, b) => {
            return (calcPlayerRoundScore(b.player) + b.player.totalScore)
                 - (calcPlayerRoundScore(a.player) + a.player.totalScore);
        });
        targetIndex = sorted[0].index;
    }

    const target = G.players[targetIndex];
    addLog(`${p.name} forces ${target.name} to flip 4 cards!`, 'action');

    // Flip 4 cards, collecting action/modifier to resolve after
    let pendingActions = [];
    for (let i = 0; i < 4; i++) {
        if (target.busted) break;
        if (checkFlip7(target)) break;

        const card = drawCard();
        if (!card) break;
        G.lastFlippedCard = card;
        await delay(500);

        addLog(`${target.name} flipped: ${cardName(card)}`);

        if (card.type === 'action' || card.type === 'modifier') {
            pendingActions.push(card);
            render();
            continue;
        }

        const result = giveCardToPlayer(target, card);
        render();
        if (result === 'bust') break;
        if (result === 'flip7') {
            // Resolve pending actions won't matter
            for (const pa of pendingActions) G.discard.push(pa);
            return 'flip7';
        }
    }

    // Resolve pending actions if not busted
    if (!target.busted) {
        for (const pa of pendingActions) {
            if (target.busted) { G.discard.push(pa); continue; }
            if (pa.type === 'action') {
                const result = await resolveAction(targetIndex, pa);
                if (result === 'flip7') return 'flip7';
            } else if (pa.type === 'modifier') {
                const modTarget = await chooseModifierTarget(targetIndex, pa);
                if (modTarget !== null) {
                    G.players[modTarget].modifiers.push(pa);
                    addLog(`${target.name} played ${pa.label} on ${G.players[modTarget].name}`, 'action');
                } else {
                    G.discard.push(pa);
                }
            }
            render();
        }
    } else {
        for (const pa of pendingActions) G.discard.push(pa);
    }

    return target.busted ? 'bust' : (checkFlip7(target) ? 'flip7' : 'ok');
}

async function chooseModifierTarget(playerIndex, card) {
    const p = G.players[playerIndex];
    let validTargets;
    if (G.mode === 'brutal') {
        validTargets = G.players.map((pl, i) => ({ player: pl, index: i }));
    } else {
        validTargets = G.players.map((pl, i) => ({ player: pl, index: i }))
            .filter(t => !t.player.busted);
    }

    // If only self is not busted, must keep it
    const nonBustedActive = validTargets.filter(t => !t.player.busted);
    if (nonBustedActive.length === 1 && nonBustedActive[0].index === playerIndex) {
        return playerIndex;
    }

    if (p.isHuman) {
        const choice = await showActionModal(`Play ${card.label} Modifier`, 'Choose a player to receive this modifier:',
            validTargets.map(t => `${t.player.name}${t.index === playerIndex ? ' (You)' : ''}`)
        );
        if (choice >= 0) return validTargets[choice].index;
        return playerIndex; // default to self if no choice
    } else {
        // AI: play negative modifiers on opponents (preferably the leader)
        const opponents = validTargets.filter(t => t.index !== playerIndex && !t.player.busted);
        if (opponents.length > 0) {
            opponents.sort((a, b) => (calcPlayerRoundScore(b.player) + b.player.totalScore) - (calcPlayerRoundScore(a.player) + a.player.totalScore));
            return opponents[0].index;
        }
        return playerIndex;
    }
}

function recalcSpecialFlags(p) {
    p.hasZero = p.cards.some(c => c.type === 'special' && c.subtype === 'zero');
    p.hasLucky13 = p.cards.some(c => c.type === 'special' && c.subtype === 'lucky13');
}

// ── Turn Phase ──
function startTurnPhase() {
    G.phase = 'turns';
    // Order: clockwise from dealer
    G.turnOrder = [];
    for (let i = 1; i <= G.players.length; i++) {
        G.turnOrder.push((G.dealerIndex + i) % G.players.length);
    }
    G.turnIndex = 0;
    advanceToNextActivePlayer();
}

function advanceToNextActivePlayer() {
    // Find next active player in turn order
    while (G.turnIndex < G.turnOrder.length) {
        const pi = G.turnOrder[G.turnIndex];
        if (isPlayerActive(G.players[pi])) {
            G.currentPlayerIndex = pi;
            render();

            if (!G.players[pi].isHuman) {
                setTimeout(() => aiTurn(pi), 600);
            }
            return;
        }
        G.turnIndex++;
    }

    // All players in this cycle have gone, start new cycle
    if (anyActivePlayer()) {
        G.turnIndex = 0;
        advanceToNextActivePlayer();
    } else {
        endRound();
    }
}

async function aiTurn(pi) {
    const p = G.players[pi];
    if (!isPlayerActive(p)) { nextTurn(); return; }

    const decision = aiDecision(p);
    if (decision === 'hit') {
        await doHit(pi);
    } else {
        doStay(pi);
    }
}

function aiDecision(p) {
    if (p.hasZero) return 'hit'; // Must hit with zero

    const totalCards = getNumberCardCount(p);
    const currentScore = calcPlayerRoundScore(p);

    // If close to flip 7, keep going
    if (totalCards >= 5) return 'hit';

    // Risk assessment based on cards remaining that could bust
    const vals = getNumberValues(p);
    let totalRemainingOfMyVals = 0;
    for (const v of vals) {
        // Approximate: value V has V copies total, minus 1 we already have
        totalRemainingOfMyVals += Math.max(0, v - 1);
    }

    // Very rough bust probability
    const deckSize = G.deck.length;
    const bustChance = deckSize > 0 ? totalRemainingOfMyVals / deckSize : 1;

    // Be more aggressive when behind
    const maxOpponentScore = Math.max(...G.players.filter(pl => pl !== p).map(pl => pl.totalScore));
    const behind = maxOpponentScore - p.totalScore;

    if (totalCards <= 2) return 'hit'; // Always hit with 0-2 cards
    if (totalCards === 3 && bustChance < 0.45) return 'hit';
    if (totalCards === 4 && bustChance < 0.35) return 'hit';
    if (totalCards === 5 && bustChance < 0.25) return 'hit';
    if (totalCards === 6) return bustChance < 0.4 ? 'hit' : 'stay'; // Go for flip 7!

    if (behind > 50 && bustChance < 0.5) return 'hit'; // Aggressive when behind
    if (currentScore >= 30) return 'stay';
    if (currentScore >= 20 && bustChance > 0.3) return 'stay';

    return bustChance < 0.35 ? 'hit' : 'stay';
}

async function doHit(pi) {
    const p = G.players[pi];
    const card = drawCard();
    if (!card) { endRound(); return; }

    G.lastFlippedCard = card;
    addLog(`${p.name} hits — flipped: ${cardName(card)}`);

    if (card.type === 'action' || card.type === 'modifier') {
        const result = await resolveFlippedCard(pi, card);
        render();
        if (result === 'flip7') { endRound(); return; }
        nextTurn();
        return;
    }

    const result = giveCardToPlayer(p, card);
    render();

    if (result === 'flip7') { endRound(); return; }
    nextTurn();
}

function doStay(pi) {
    const p = G.players[pi];
    p.stayed = true;
    addLog(`${p.name} stays.`);
    render();
    nextTurn();
}

function nextTurn() {
    G.turnIndex++;
    if (!anyActivePlayer()) {
        endRound();
        return;
    }

    // Check if we need to wrap around
    if (G.turnIndex >= G.turnOrder.length) {
        G.turnIndex = 0;
    }
    advanceToNextActivePlayer();
}

// ── Human Controls ──
document.getElementById('btn-hit').addEventListener('click', async () => {
    const pi = G.currentPlayerIndex;
    if (!G.players[pi].isHuman) return;
    document.getElementById('btn-hit').disabled = true;
    document.getElementById('btn-stay').disabled = true;
    await doHit(pi);
});

document.getElementById('btn-stay').addEventListener('click', () => {
    const pi = G.currentPlayerIndex;
    if (!G.players[pi].isHuman) return;
    doStay(pi);
});

// ── Round End ──
function endRound() {
    G.phase = 'roundEnd';
    render();

    // Calculate and apply scores
    const summaryEl = document.getElementById('summary-scores');
    let html = '';

    for (const p of G.players) {
        const rs = calcPlayerRoundScore(p);
        p.totalScore += rs;

        const isFlip7 = !p.busted && checkFlip7(p);

        html += `<div class="summary-row${isFlip7 ? ' winner' : ''}">
            <span class="s-name">${p.isHuman ? '★ ' : ''}${p.name}</span>
            ${p.busted ? '<span class="s-bust">BUST</span>' : `<span class="s-round">+${rs}${isFlip7 ? ' (Flip 7!)' : ''}</span>`}
            <span class="s-total">${p.totalScore}</span>
        </div>`;
    }

    summaryEl.innerHTML = html;

    // Check game over
    const winners = G.players.filter(p => p.totalScore >= 200);
    if (winners.length > 0) {
        document.getElementById('summary-title').textContent = 'Final Round Complete!';
        document.getElementById('btn-next-round').textContent = 'See Results';
        document.getElementById('btn-next-round').onclick = showGameOver;
    } else {
        document.getElementById('summary-title').textContent = `Round ${G.round} Complete`;
        document.getElementById('btn-next-round').textContent = 'Next Round';
        document.getElementById('btn-next-round').onclick = () => {
            document.getElementById('round-summary').classList.remove('active');
            // Discard all cards from this round
            for (const p of G.players) {
                for (const c of p.cards) G.discard.push(c);
                for (const m of p.modifiers) G.discard.push(m);
            }
            G.round++;
            G.dealerIndex = (G.dealerIndex + 1) % G.players.length;
            startRound();
        };
    }

    document.getElementById('round-summary').classList.add('active');
}

function showGameOver() {
    document.getElementById('round-summary').classList.remove('active');

    const sorted = [...G.players].sort((a, b) => b.totalScore - a.totalScore);
    const winner = sorted[0];

    document.getElementById('go-winner').textContent = `${winner.name} wins with ${winner.totalScore} points!`;
    document.getElementById('go-final-scores').innerHTML = sorted.map(p =>
        `<div class="go-score-row${p === winner ? ' winner-row' : ''}">
            <span class="gs-name">${p.isHuman ? '★ ' : ''}${p.name}</span>
            <span class="gs-score">${p.totalScore}</span>
        </div>`
    ).join('');

    document.getElementById('game-over').classList.add('active');
}

// ── Modal for human choices ──
function showActionModal(title, text, options) {
    return new Promise(resolve => {
        const modal = document.getElementById('action-modal');
        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-text').textContent = text;
        const choices = document.getElementById('modal-choices');
        choices.innerHTML = options.map((opt, i) =>
            `<button class="modal-choice" data-idx="${i}">${opt}</button>`
        ).join('');

        choices.querySelectorAll('.modal-choice').forEach(btn => {
            btn.addEventListener('click', () => {
                modal.classList.remove('active');
                G.waitingForAction = false;
                render();
                resolve(parseInt(btn.dataset.idx));
            });
        });

        G.waitingForAction = true;
        render();
        modal.classList.add('active');
    });
}

// ── Helpers ──
function cardName(c) {
    if (c.type === 'number') return `${c.value}`;
    if (c.type === 'special') {
        if (c.subtype === 'zero') return 'The Zero';
        if (c.subtype === 'unlucky7') return 'Unlucky 7';
        if (c.subtype === 'lucky13') return 'Lucky 13';
    }
    if (c.type === 'modifier') return `${c.label} Modifier`;
    if (c.type === 'action') return c.label;
    return c.label || '?';
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ── Setup UI ──
document.querySelectorAll('.count-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.count-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    });
});

document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    });
});

document.getElementById('btn-start').addEventListener('click', () => {
    const name = document.getElementById('player-name').value.trim() || 'You';
    const count = parseInt(document.querySelector('.count-btn.active').dataset.count);
    const mode = document.querySelector('.mode-btn.active').dataset.mode;

    initState(name, count, mode);

    document.getElementById('setup-screen').style.display = 'none';
    document.getElementById('game-screen').style.display = 'block';

    startRound();
});

document.getElementById('btn-new-game').addEventListener('click', () => {
    document.getElementById('game-over').classList.remove('active');
    document.getElementById('game-screen').style.display = 'none';
    document.getElementById('setup-screen').style.display = 'flex';
    document.getElementById('game-log').innerHTML = '';
});

// Help
document.getElementById('help-btn').addEventListener('click', () => {
    document.getElementById('help-overlay').classList.add('active');
});
document.getElementById('help-close').addEventListener('click', () => {
    document.getElementById('help-overlay').classList.remove('active');
});

</script>
</body>
</html>
