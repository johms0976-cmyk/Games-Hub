<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Five Crowns</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0e0818;
  --bg-panel: #16102a;
  --bg-card: #1e1636;
  --border: rgba(212,168,67,0.1);
  --border-hover: rgba(212,168,67,0.25);
  --gold: #d4a843;
  --gold-dim: rgba(212,168,67,0.15);
  --gold-glow: rgba(212,168,67,0.3);
  --red: #c0392b;
  --red-dim: rgba(192,57,43,0.2);
  --green: #27ae60;
  --green-dim: rgba(46,204,113,0.15);
  --blue: #3498db;
  --purple: #9b59b6;
  --purple-bright: #c77dff;
  --purple-deep: #3d1a6e;
  --text: #d4ccbe;
  --text-dim: rgba(255,255,255,0.4);
  --text-bright: #f0e8d8;
  --card-w: 58px;
  --card-h: 84px;
  --card-radius: 7px;
}
*,*::before,*::after { margin:0; padding:0; box-sizing:border-box; }
html { scroll-behavior:smooth; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Outfit','Segoe UI',sans-serif;
  min-height: 100vh;
  min-height: 100dvh;
  overflow-x: hidden;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}
button {
  font-family: 'Outfit',sans-serif;
  cursor: pointer;
  transition: all .2s;
  border: none;
  outline: none;
}
button:hover:not(:disabled) { filter:brightness(1.15); transform:translateY(-1px); }
button:active:not(:disabled) { transform:translateY(0) scale(0.97); }
button:disabled { opacity:.4; cursor:not-allowed; }
::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:rgba(255,255,255,.08); border-radius:3px; }

body::before {
  content:'';
  position:fixed; inset:0;
  background:
    radial-gradient(ellipse 80% 60% at 20% 10%, rgba(155,89,182,0.06) 0%, transparent 60%),
    radial-gradient(ellipse 60% 50% at 80% 80%, rgba(212,168,67,0.04) 0%, transparent 60%);
  pointer-events:none; z-index:0;
}

/* â•â•â• SCREENS â•â•â• */
.screen { display:none; min-height:100vh; min-height:100dvh; flex-direction:column; align-items:center; justify-content:center; position:relative; z-index:1; }
.screen.active { display:flex; }

/* â”€â”€â”€ Title Screen â”€â”€â”€ */
#title-screen {
  background: radial-gradient(ellipse at 50% 30%, #2a1548 0%, #0e0818 70%);
  gap: 8px;
  padding: 40px 24px;
}
#title-screen h1 {
  font-family:'Cinzel',serif;
  font-size: clamp(32px, 7vw, 52px);
  font-weight:900;
  background: linear-gradient(135deg, var(--gold), #f0d78c, var(--gold));
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  letter-spacing:6px;
  text-shadow:0 2px 20px var(--gold-glow);
  text-transform: uppercase;
}
.title-sub {
  color: var(--text-dim);
  font-size:12px;
  letter-spacing:4px;
  text-transform:uppercase;
  font-weight:300;
  margin-bottom:28px;
}
.crown-icon { font-size: 40px; margin-bottom: 8px; }
.setup-section { margin-bottom: 20px; text-align: center; }
.setup-label {
  color: var(--text-dim);
  font-size:11px; letter-spacing:2.5px;
  text-transform:uppercase; margin-bottom:10px; font-weight:500;
}
.option-row { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
.option-btn {
  min-width:48px; height:48px; border-radius:12px;
  border:2px solid var(--border);
  background: rgba(255,255,255,0.03);
  color: var(--text-dim);
  font-size:15px; font-weight:600;
  font-family:'Outfit',sans-serif;
  transition: all .2s;
  padding: 0 14px;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap: 2px;
}
.option-btn .opt-sub { font-size:8px; letter-spacing:1px; text-transform:uppercase; opacity:0.6; }
.option-btn.sel {
  border-color: var(--gold);
  background: var(--gold-dim);
  color: var(--gold);
}
.player-num-btn { width:48px; height:48px; font-family:'Cinzel',serif; font-size:18px; font-weight:700; }
.start-btn {
  padding:14px 48px;
  font-size:15px; font-weight:700; letter-spacing:4px;
  background:linear-gradient(135deg, #5a2d82, #7b3fa0);
  color:#f0d78c; border-radius:12px;
  font-family:'Cinzel',serif;
  box-shadow:0 4px 24px rgba(123,63,160,.35);
  text-transform:uppercase;
  margin-top: 8px;
  border: 1px solid rgba(212,168,67,0.3);
}
.rules-link {
  margin-top: 16px;
  color: var(--text-dim);
  font-size:12px; letter-spacing:1.5px;
  text-transform:uppercase;
  cursor:pointer; transition: color .2s;
  text-decoration: underline;
  text-underline-offset: 3px;
  background:none; border:none;
  font-family:'Outfit',sans-serif;
}
.rules-link:hover { color: var(--gold); transform:none; }
.hub-link {
  margin-top: 20px;
  color: var(--text-dim);
  font-size: 12px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  text-decoration: none;
  font-family: 'Outfit', sans-serif;
  transition: color .2s;
  padding: 6px 16px;
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px;
}
.hub-link:hover { color: var(--gold); border-color: rgba(212,168,67,0.3); }

/* â”€â”€â”€ Game Screen â”€â”€â”€ */
#game-screen {
  justify-content: flex-start;
  padding: 4px 6px 0;
  gap: 0;
  min-height: 100vh;
  min-height: 100dvh;
}

/* â•â•â• PLAYING CARDS â•â•â• */
.card {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-radius);
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: 'Cinzel', serif;
  font-weight: 700;
  position: relative;
  flex-shrink: 0;
  transition: transform .15s, box-shadow .15s, outline .15s;
}
.card-face {
  background: linear-gradient(145deg, #f5f2ea, #e8e2d4);
  border: 1px solid rgba(0,0,0,0.12);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8);
  color: #1a1a1a;
  cursor: default;
}
.card-face.suit-hearts { color: #c0392b; }
.card-face.suit-diamonds { color: #e67e22; }
.card-face.suit-clubs { color: #1a8a3e; }
.card-face.suit-spades { color: #2c3e50; }
.card-face.suit-stars { color: #d4a843; }
.card-face .card-rank { font-size:15px; line-height:1; }
.card-face .card-suit { font-size:17px; line-height:1; margin-top:1px; }
.card-face .card-corner {
  position:absolute; font-size:8px; line-height:1;
  display:flex; flex-direction:column; align-items:center; gap:0;
}
.card-face .card-corner.tl { top:3px; left:4px; }
.card-face .card-corner.br { bottom:3px; right:4px; transform:rotate(180deg); }

/* Wild card glow */
.card-face.is-wild {
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8), 0 0 0 2px rgba(199,125,255,0.6);
  background: linear-gradient(145deg, #f5f0ff, #ede2f8);
}
.card-face.is-joker {
  background: linear-gradient(145deg, #3d1a6e, #2a0e48);
  color: #f0d78c;
  border: 1.5px solid rgba(212,168,67,0.4);
  box-shadow: 0 2px 12px rgba(212,168,67,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
}
.card-face.is-joker .card-corner { color: #f0d78c; }

.card-back {
  background:
    radial-gradient(circle 1px at 15% 20%, rgba(212,168,67,0.5) 0%, transparent 100%),
    radial-gradient(circle 1px at 70% 15%, rgba(240,215,140,0.4) 0%, transparent 100%),
    radial-gradient(circle 1px at 40% 75%, rgba(212,168,67,0.5) 0%, transparent 100%),
    radial-gradient(circle 1px at 85% 60%, rgba(240,215,140,0.35) 0%, transparent 100%),
    radial-gradient(circle 1px at 25% 50%, rgba(212,168,67,0.4) 0%, transparent 100%),
    radial-gradient(circle 1px at 55% 35%, rgba(240,215,140,0.3) 0%, transparent 100%),
    radial-gradient(circle 1px at 10% 85%, rgba(212,168,67,0.45) 0%, transparent 100%),
    radial-gradient(circle 1px at 90% 30%, rgba(240,215,140,0.35) 0%, transparent 100%),
    radial-gradient(circle 1px at 50% 90%, rgba(212,168,67,0.4) 0%, transparent 100%),
    radial-gradient(circle 1px at 35% 10%, rgba(240,215,140,0.3) 0%, transparent 100%),
    radial-gradient(circle 1px at 75% 80%, rgba(212,168,67,0.35) 0%, transparent 100%),
    radial-gradient(circle 1px at 60% 55%, rgba(240,215,140,0.25) 0%, transparent 100%),
    linear-gradient(145deg, #5a2380, #3a1560, #2a0e48);
  border: 1.5px solid rgba(212,168,67,0.3);
  box-shadow: 0 2px 8px rgba(0,0,0,0.4), inset 0 0 12px rgba(155,89,182,0.15);
}
.card-back::after {
  content:'â™›';
  font-size: 20px;
  color: rgba(212,168,67,0.4);
  text-shadow: 0 0 6px rgba(212,168,67,0.15);
}
.card.selectable { cursor:pointer; }
.card.selectable:hover {
  transform: translateY(-8px);
  box-shadow: 0 8px 24px rgba(212,168,67,0.25);
  z-index: 10;
}
.card.selected {
  transform: translateY(-12px);
  outline: 2.5px solid var(--gold);
  box-shadow: 0 8px 20px var(--gold-glow);
  z-index: 10;
}

/* â•â•â• GAME TABLE LAYOUT â•â•â• */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 2px 4px 4px;
  flex-shrink: 0;
}
.top-bar-left { display: flex; align-items: center; gap: 6px; }
.menu-btn {
  background: none;
  color: var(--text-dim);
  font-size: 11px;
  letter-spacing: 1px;
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid var(--border);
  font-family: 'Outfit', sans-serif;
}
.menu-btn:hover { color: var(--gold); border-color: rgba(212,168,67,0.3); transform:none; }
.game-info {
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 1px;
  text-align: right;
}

/* Round info bar */
.round-bar {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  padding: 6px 8px;
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  margin-bottom: 4px;
  flex-shrink: 0;
}
.round-label {
  font-family: 'Cinzel', serif;
  font-size: 13px;
  color: var(--gold);
  letter-spacing: 2px;
  font-weight: 700;
}
.wild-label {
  font-size: 11px;
  color: var(--purple-bright);
  letter-spacing: 1px;
  font-weight: 500;
}
.wild-label span { font-weight: 700; }

/* Opponents */
.opponents-row {
  display:flex;
  justify-content:center;
  gap: 8px;
  flex-wrap: wrap;
  width: 100%;
  padding: 4px 0;
}
.opponent-zone {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 6px 10px;
  text-align: center;
  min-width: 90px;
  max-width: 160px;
  flex: 1;
  transition: border-color .3s, box-shadow .3s;
}
.opponent-zone.is-turn {
  border-color: rgba(212,168,67,0.3);
  box-shadow: 0 0 20px rgba(212,168,67,0.08);
}
.opponent-zone.went-out {
  border-color: rgba(46,204,113,0.3);
  box-shadow: 0 0 20px rgba(46,204,113,0.08);
}
.opponent-name {
  font-family:'Cinzel',serif;
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 1.5px;
  text-transform: uppercase;
  margin-bottom: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}
.opponent-name.active-turn {
  color: var(--gold);
  text-shadow: 0 0 10px var(--gold-glow);
}
.hand-count {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,0.06);
  border-radius: 10px;
  padding: 1px 5px;
  font-family: 'Outfit', sans-serif;
  font-size: 9px;
  font-weight: 500;
  color: var(--text-dim);
}
.opp-score {
  font-size: 9px;
  color: var(--text-dim);
  font-weight: 500;
  margin-top: 2px;
}
.opp-cards {
  display: flex;
  gap: 2px;
  justify-content: center;
  margin-top: 3px;
}
.opp-cards .card {
  --card-w: 28px;
  --card-h: 38px;
  --card-radius: 4px;
}
.opp-cards .card-back::after { font-size: 10px; }

/* Center area */
.center-area {
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 24px;
  padding: 8px 0;
  flex-shrink: 0;
  width: 100%;
  min-height: 130px;
}
.pile-zone {
  display:flex; flex-direction:column; align-items:center; gap:4px;
}
.pile-label {
  font-size:10px; color:var(--text-dim); letter-spacing:1.5px; text-transform:uppercase; font-weight:500;
}
.pile-cards {
  position:relative;
  width: var(--card-w);
  height: var(--card-h);
  cursor: pointer;
}
.pile-cards .card {
  position:absolute; top:0; left:0;
}
.pile-placeholder {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-radius);
  border: 2px dashed rgba(255,255,255,0.08);
  display:flex; align-items:center; justify-content:center;
  font-size:9px; color:var(--text-dim); letter-spacing:1px;
}
.pile-count {
  font-size:10px; color:var(--text-dim); font-weight:500; min-height: 14px;
}
.pile-cards.clickable { cursor: pointer; }
.pile-cards.clickable:hover .card { transform: translateY(-3px); }

/* Status bar */
.status-bar {
  font-size: 11px;
  color: var(--text-dim);
  letter-spacing: 1px;
  padding: 3px 0;
  text-align: center;
  flex-shrink: 0;
  min-height: 22px;
}

/* Action bar */
.action-bar {
  display:flex; align-items:center; justify-content:center; gap:8px;
  padding: 4px 0;
  min-height: 42px;
  flex-shrink: 0;
  flex-wrap: wrap;
}
.action-btn {
  padding: 9px 24px;
  border-radius: 10px;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 1.5px;
  text-transform: uppercase;
}
.btn-draw {
  background: linear-gradient(135deg, #1a5a8b, var(--blue));
  color: #fff;
  box-shadow: 0 2px 12px rgba(52,152,219,0.3);
}
.btn-discard {
  background: linear-gradient(135deg, #5a2380, #7b3fa0);
  color: #fff;
  box-shadow: 0 2px 12px rgba(123,63,160,0.3);
}
.btn-go-out {
  background: linear-gradient(135deg, #1a6b3a, var(--green));
  color: #fff;
  box-shadow: 0 2px 12px rgba(46,204,113,0.3);
}
.btn-sort {
  background: rgba(255,255,255,0.06);
  color: var(--text-dim);
  box-shadow: none;
  border: 1px solid var(--border);
  padding: 9px 16px;
}

/* Player zone */
.player-zone {
  width: 100%;
  padding: 0 0 8px;
  text-align: center;
}
.player-label {
  font-family:'Cinzel',serif;
  font-size: 11px;
  color: var(--text-dim);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 2px;
}
.player-label.active-turn {
  color: var(--gold);
  text-shadow: 0 0 10px var(--gold-glow);
}
.player-hand-section {
  background: rgba(255,255,255,0.02);
  border-top: 1px solid var(--border);
  border-radius: 0 0 16px 16px;
  padding: 6px 4px 8px;
  margin: 0 -6px;
}
.section-label {
  font-size: 9px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 4px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}
.section-label::before, .section-label::after {
  content: '';
  height: 1px;
  width: 30px;
  background: var(--border);
}
.player-hand {
  display:flex;
  gap: 3px;
  justify-content:center;
  flex-wrap: wrap;
  padding: 2px 4px;
  min-height: calc(var(--card-h) + 16px);
}
.player-score-bar {
  font-size: 11px;
  color: var(--text-dim);
  letter-spacing: 1px;
  padding: 4px 0 0;
}
.player-score-bar span { color: var(--gold); font-weight: 600; }

/* â•â•â• MELDS DISPLAY â•â•â• */
.melds-area {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  padding: 6px 0;
}
.meld-group {
  display: flex;
  gap: 2px;
  padding: 4px 6px;
  background: rgba(46,204,113,0.08);
  border: 1px solid rgba(46,204,113,0.2);
  border-radius: 8px;
}
.meld-group .card {
  --card-w: 40px;
  --card-h: 58px;
  --card-radius: 5px;
}
.meld-group .card-face .card-rank { font-size: 11px; }
.meld-group .card-face .card-suit { font-size: 13px; }
.meld-group .card-face .card-corner { font-size: 6px; }
.deadwood-group {
  background: rgba(192,57,43,0.08);
  border-color: rgba(192,57,43,0.2);
}

/* â•â•â• TOAST â•â•â• */
.toast {
  position:fixed;
  top: 16px; left:50%;
  transform: translateX(-50%) translateY(-60px);
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 10px 24px;
  font-size: 13px;
  color: var(--text-bright);
  letter-spacing: 0.5px;
  z-index: 200;
  opacity:0;
  transition: all .3s ease;
  pointer-events:none;
  white-space: nowrap;
  max-width: 90vw;
  text-align: center;
}
.toast.show { transform: translateX(-50%) translateY(0); opacity:1; }

/* â•â•â• MODALS â•â•â• */
.modal-overlay {
  position: fixed; inset:0;
  background: rgba(0,0,0,0.85);
  z-index: 300;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.modal-overlay.show { display:flex; }
.modal-content {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 24px;
  max-width: 500px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
  position:relative;
}
.modal-content h2 {
  font-family:'Cinzel',serif;
  font-size: 18px;
  color: var(--gold);
  letter-spacing: 3px;
  margin-bottom: 14px;
  text-align: center;
}
.modal-close {
  position: absolute;
  top: 12px; right: 16px;
  background: none; color: var(--text-dim);
  font-size: 20px; cursor: pointer;
  border: none; font-family: sans-serif;
}
.modal-close:hover { color: var(--text-bright); transform:none; }
.rule-section {
  padding: 8px 0;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  line-height: 1.6;
  color: var(--text);
}
.rule-section:last-child { border-bottom: none; }
.rule-section strong { color: var(--text-bright); font-weight: 600; }
.rule-section .rule-title {
  color: var(--gold);
  font-family: 'Cinzel', serif;
  font-size: 12px;
  letter-spacing: 1.5px;
  margin-bottom: 4px;
  text-transform: uppercase;
}

/* â•â•â• ROUND END MODAL â•â•â• */
.round-results {
  text-align: center;
}
.round-results h2 { margin-bottom: 16px; }
.score-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
  font-size: 12px;
}
.score-table th {
  font-family: 'Cinzel', serif;
  color: var(--gold);
  font-size: 10px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  padding: 6px 8px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
}
.score-table td {
  padding: 6px 8px;
  border-bottom: 1px solid var(--border);
  color: var(--text);
}
.score-table .player-row { color: var(--gold); font-weight: 600; }
.score-table .went-out-cell { color: var(--green); }
.score-table .total-col { font-weight: 700; color: var(--text-bright); }

/* â•â•â• GAME OVER SCREEN â•â•â• */
#gameover-screen {
  background: radial-gradient(ellipse at 50% 40%, #2a1548 0%, #0e0818 70%);
  gap: 12px;
  padding: 40px 24px;
}
#gameover-screen h1 {
  font-family:'Cinzel',serif;
  font-size: 36px;
  font-weight:900;
  letter-spacing:6px;
}
#gameover-screen .winner-name {
  font-size: 18px;
  color: var(--text-dim);
  letter-spacing: 3px;
  margin-bottom: 8px;
}
#gameover-screen .subtitle {
  color: var(--text-dim);
  font-size: 13px;
  margin-bottom: 16px;
}
.final-scores {
  width: 100%;
  max-width: 400px;
  margin-bottom: 24px;
}

/* â•â•â• ANIMATIONS â•â•â• */
@keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
@keyframes popIn { 0%{transform:scale(0.85);opacity:0} 100%{transform:scale(1);opacity:1} }
.card { animation: popIn .15s ease both; }

@keyframes glowPulse {
  0%,100% { box-shadow: 0 0 0 0 rgba(46,204,113,0.4); }
  50% { box-shadow: 0 0 0 6px rgba(46,204,113,0); }
}
.go-out-ready { animation: glowPulse 1.2s infinite; border-color: rgba(46,204,113,0.4) !important; }

/* â•â•â• RESPONSIVE â•â•â• */
@media (max-width:600px) {
  :root { --card-w:50px; --card-h:72px; }
  .opponent-zone { min-width:80px; padding:5px 6px; }
  .opp-cards .card { --card-w:24px; --card-h:32px; }
  .opp-cards .card-back::after { font-size: 8px; }
  .player-hand { gap:2px; }
  .center-area { gap:14px; min-height:110px; }
  .opponents-row { gap:5px; }
  .round-bar { gap:10px; padding:5px 6px; }
  .round-label { font-size: 11px; }
  .meld-group .card { --card-w:34px; --card-h:50px; }
  .meld-group .card-face .card-rank { font-size: 9px; }
  .meld-group .card-face .card-suit { font-size: 11px; }
}
@media (max-width:380px) {
  :root { --card-w:44px; --card-h:64px; }
  .player-hand { gap:1px; }
}
</style>
</head>
<body>

<!-- â•â•â• TITLE SCREEN â•â•â• -->
<div id="title-screen" class="screen active">
  <div class="crown-icon">â™›</div>
  <h1>Five Crowns</h1>
  <div class="title-sub">The Card Game That Isn't Over 'Til The Kings Go Wild</div>

  <div class="setup-section">
    <div class="setup-label">Players</div>
    <div class="option-row" id="player-select">
      <button class="option-btn player-num-btn" data-count="2">2</button>
      <button class="option-btn player-num-btn sel" data-count="3">3</button>
      <button class="option-btn player-num-btn" data-count="4">4</button>
      <button class="option-btn player-num-btn" data-count="5">5</button>
    </div>
  </div>

  <button class="start-btn" onclick="startGame()">Deal</button>
  <button class="rules-link" onclick="showRules()">How to Play</button>
  <a href="../index.html" class="hub-link">â† Back to Game Hub</a>
</div>

<!-- â•â•â• GAME SCREEN â•â•â• -->
<div id="game-screen" class="screen">
  <div class="top-bar">
    <div class="top-bar-left">
      <button class="menu-btn" onclick="confirmQuit()">âœ• Quit</button>
      <button class="menu-btn" onclick="showRules()">? Rules</button>
    </div>
    <div class="game-info" id="game-info"></div>
  </div>
  <div class="round-bar" id="round-bar"></div>
  <div class="opponents-row" id="opponents-row"></div>
  <div class="status-bar" id="status-bar"></div>
  <div class="center-area">
    <div class="pile-zone">
      <div class="pile-label">Draw</div>
      <div class="pile-cards" id="draw-pile" onclick="humanDrawFromDeck()"></div>
      <div class="pile-count" id="draw-count"></div>
    </div>
    <div class="pile-zone">
      <div class="pile-label">Discard</div>
      <div class="pile-cards" id="discard-pile" onclick="humanDrawFromDiscard()"></div>
      <div class="pile-count" id="discard-count"></div>
    </div>
  </div>
  <div class="action-bar" id="action-bar"></div>
  <div class="player-zone" id="player-zone"></div>
</div>

<!-- â•â•â• GAME OVER SCREEN â•â•â• -->
<div id="gameover-screen" class="screen">
  <div class="crown-icon">â™›</div>
  <h1 id="go-title"></h1>
  <div class="winner-name" id="go-winner"></div>
  <div class="subtitle" id="go-subtitle"></div>
  <div class="final-scores" id="final-scores"></div>
  <button class="start-btn" onclick="showScreen('title-screen')">Play Again</button>
  <a href="../index.html" class="hub-link" style="margin-top:12px;">â† Back to Game Hub</a>
</div>

<!-- â•â•â• TOAST â•â•â• -->
<div class="toast" id="toast"></div>

<!-- â•â•â• RULES MODAL â•â•â• -->
<div class="modal-overlay" id="rules-modal">
  <div class="modal-content">
    <button class="modal-close" onclick="hideRules()">âœ•</button>
    <h2>How to Play</h2>
    <div class="rule-section">
      <div class="rule-title">Goal</div>
      Lowest score after 11 rounds wins. Make your entire hand into <strong>books</strong> (3+ same rank) and/or <strong>runs</strong> (3+ consecutive, same suit), then discard your last card to <strong>go out</strong>.
    </div>
    <div class="rule-section">
      <div class="rule-title">The Rounds</div>
      Round 1 deals <strong>3 cards</strong>, Round 2 deals <strong>4 cards</strong>, and so on until Round 11 deals <strong>13 cards</strong>. The number of cards dealt also determines the <strong>wild card</strong> for that round.
    </div>
    <div class="rule-section">
      <div class="rule-title">Wild Cards</div>
      <strong>Jokers</strong> are always wild. The rank matching the number of cards dealt is also wild. So in Round 1 (3 cards), <strong>3s are wild</strong>. In Round 11 (13 cards), <strong>Kings are wild</strong>. Wild cards can substitute for any card in a book or run.
    </div>
    <div class="rule-section">
      <div class="rule-title">Your Turn</div>
      <strong>1.</strong> Draw a card from the draw pile or take the top discard.<br>
      <strong>2.</strong> If you can arrange your entire hand into melds with one card left over, you may <strong>go out</strong>.<br>
      <strong>3.</strong> Discard one card to end your turn.
    </div>
    <div class="rule-section">
      <div class="rule-title">Going Out & Last Chance</div>
      When someone goes out, all other players get <strong>one final turn</strong> to lay down melds. Cards not in melds count against your score.
    </div>
    <div class="rule-section">
      <div class="rule-title">Scoring</div>
      Number cards = face value (3â€“10). <strong>J = 11, Q = 12, K = 13</strong>. <strong>Jokers = 50</strong>. <strong>Current wild rank = 20</strong>. Cards in valid melds score 0.
    </div>
    <div class="rule-section">
      <div class="rule-title">Five Suits</div>
      â˜… Stars &nbsp; â™¥ Hearts &nbsp; â™£ Clubs &nbsp; â™  Spades &nbsp; â™¦ Diamonds
    </div>
  </div>
</div>

<!-- â•â•â• ROUND END MODAL â•â•â• -->
<div class="modal-overlay" id="round-modal">
  <div class="modal-content round-results" id="round-results"></div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const SUITS = ['â˜…','â™¥','â™£','â™ ','â™¦'];
const SUIT_NAMES = { 'â˜…':'stars', 'â™¥':'hearts', 'â™£':'clubs', 'â™ ':'spades', 'â™¦':'diamonds' };
const RANKS = [3,4,5,6,7,8,9,10,11,12,13]; // 3-10, J=11, Q=12, K=13
const RANK_DISPLAY = { 3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K' };
const AI_NAMES = ['Rosalind','Oberon','Titania','Prospero','Ariel','Cordelia'];

function makeCard(rank, suit) {
  return { rank, suit, id: rank + suit + Math.random().toString(36).slice(2,6) };
}
function makeJoker() {
  return { rank: 0, suit: 'JK', id: 'JK' + Math.random().toString(36).slice(2,6) };
}

function makeDeck() {
  const d = [];
  // Two 58-card decks
  for (let n = 0; n < 2; n++) {
    for (const s of SUITS) {
      for (const r of RANKS) {
        d.push(makeCard(r, s));
      }
    }
    // 3 Jokers per deck
    d.push(makeJoker());
    d.push(makeJoker());
    d.push(makeJoker());
  }
  return d; // 116 cards total
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function isWild(card, wildRank) {
  return card.rank === 0 || card.rank === wildRank; // 0 = Joker
}

function cardScore(card, wildRank) {
  if (card.rank === 0) return 50; // Joker
  if (card.rank === wildRank) return 20; // Current wild
  return card.rank; // Face value (J=11, Q=12, K=13)
}

function displayRank(card) {
  if (card.rank === 0) return 'â˜…';
  return RANK_DISPLAY[card.rank] || card.rank;
}

function displaySuit(card) {
  if (card.suit === 'JK') return 'âœ¦';
  return card.suit;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MELD DETECTION (Optimized backtracking)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Enumerate all possible melds from a set of non-wild cards
function enumeratePossibleMelds(normals) {
  const melds = [];
  
  // Books: groups of 1+ same rank (wilds fill to reach 3+)
  // Also generate larger books that absorb extra wilds (e.g. 2 naturals + 2 wilds = book of 4)
  const byRank = {};
  normals.forEach((c, i) => {
    if (!byRank[c.rank]) byRank[c.rank] = [];
    byRank[c.rank].push(i);
  });
  const maxExtraWilds = 6; // reasonable upper bound on extra wilds per meld
  for (const [rank, indices] of Object.entries(byRank)) {
    for (let size = 1; size <= indices.length; size++) {
      const baseWilds = Math.max(0, 3 - size);
      const selectedIndices = size === indices.length ? [...indices] : indices.slice(0, size);
      for (let extra = 0; extra <= maxExtraWilds; extra++) {
        const wildsNeeded = baseWilds + extra;
        const totalMeldSize = size + wildsNeeded;
        if (totalMeldSize < 3) continue;
        melds.push({ type: 'book', indices: [...selectedIndices], rank: +rank, wildsNeeded });
      }
    }
  }
  
  // Runs: consecutive cards of same suit (allow single card + wilds for runs of 3)
  const bySuit = {};
  normals.forEach((c, i) => {
    if (!bySuit[c.suit]) bySuit[c.suit] = [];
    bySuit[c.suit].push({ rank: c.rank, idx: i });
  });
  
  for (const [suit, suitCards] of Object.entries(bySuit)) {
    const sorted = [...suitCards].sort((a, b) => a.rank - b.rank);
    
    for (let i = 0; i < sorted.length; i++) {
      // Allow runs starting up to 2 below this card (wilds fill the gaps)
      const minStart = Math.max(3, sorted[i].rank - 2);
      for (let startRank = minStart; startRank <= sorted[i].rank; startRank++) {
        for (let endRank = Math.max(startRank + 2, sorted[i].rank); endRank <= 13; endRank++) {
          const usedIdx = [];
          let gaps = 0;
          
          for (let r = startRank; r <= endRank; r++) {
            const found = sorted.find(sc => sc.rank === r && !usedIdx.includes(sc.idx));
            if (found) {
              usedIdx.push(found.idx);
            } else {
              gaps++;
            }
          }
          
          if (usedIdx.length >= 1) { // At least 1 real card + wilds
            melds.push({ type: 'run', indices: usedIdx, suit, startRank, endRank, wildsNeeded: gaps });
          }
        }
      }
    }
  }
  
  return melds;
}

function findBestMelds(cards, wildRank) {
  const wilds = cards.filter(c => isWild(c, wildRank));
  const normals = cards.filter(c => !isWild(c, wildRank));
  const totalWilds = wilds.length;
  
  // All wilds? They can form melds of 3+ (any count >= 3 is valid: book of 4, 5, etc.)
  if (normals.length === 0) {
    const deadCount = totalWilds < 3 ? totalWilds : (totalWilds % 3 === 1 ? 0 : (totalWilds % 3 === 2 ? 0 : 0));
    // Any number of wilds >= 3 can be partitioned into valid melds (e.g. 4=book of 4, 5=book of 5, 7=3+4, etc.)
    // Only 1 or 2 wilds can't form a meld
    const canMeld = totalWilds === 0 || totalWilds >= 3;
    const deadScore = canMeld ? 0 : totalWilds * (wildRank === 0 ? 50 : 20);
    return { melds: [], deadwood: canMeld ? [] : wilds.slice(), deadScore };
  }
  
  const possibleMelds = enumeratePossibleMelds(normals);
  
  let bestDeadScore = normals.reduce((s, c) => s + cardScore(c, wildRank), 0) +
                      wilds.reduce((s, c) => s + cardScore(c, wildRank), 0);
  let bestMelds = [];
  let bestUsed = new Set();
  let calls = 0;
  const MAX_CALLS = 50000;
  
  function backtrack(meldIdx, usedSet, wildsUsed, meldsSoFar) {
    calls++;
    if (calls > MAX_CALLS) return;
    
    // Calc current deadwood
    const deadCards = normals.filter((_, i) => !usedSet.has(i));
    const unusedWilds = totalWilds - wildsUsed;
    let deadScore = deadCards.reduce((s, c) => s + cardScore(c, wildRank), 0);
    // Unused wilds are deadwood too (but 3+ wilds can form a valid book)
    const leftoverWilds = unusedWilds >= 3 ? 0 : unusedWilds;
    deadScore += leftoverWilds * cardScore(wilds[0] || {rank:0}, wildRank);
    
    if (deadScore < bestDeadScore) {
      bestDeadScore = deadScore;
      bestMelds = [...meldsSoFar];
      bestUsed = new Set(usedSet);
    }
    
    if (deadScore === 0) return; // Perfect!
    
    // Try remaining melds
    for (let i = meldIdx; i < possibleMelds.length; i++) {
      const m = possibleMelds[i];
      if (m.wildsNeeded > totalWilds - wildsUsed) continue;
      if (m.indices.some(idx => usedSet.has(idx))) continue;
      
      m.indices.forEach(idx => usedSet.add(idx));
      meldsSoFar.push(m);
      backtrack(i + 1, usedSet, wildsUsed + m.wildsNeeded, meldsSoFar);
      meldsSoFar.pop();
      m.indices.forEach(idx => usedSet.delete(idx));
      
      if (calls > MAX_CALLS) return;
    }
  }
  
  backtrack(0, new Set(), 0, []);
  
  const deadwood = normals.filter((_, i) => !bestUsed.has(i));
  const unusedWilds = totalWilds - bestMelds.reduce((s, m) => s + m.wildsNeeded, 0);
  const leftoverWilds = unusedWilds >= 3 ? 0 : unusedWilds;
  for (let i = 0; i < leftoverWilds; i++) deadwood.push(wilds[i] || wilds[0]);
  
  return {
    melds: bestMelds.map(m => {
      const mc = m.indices.map(i => normals[i]);
      for (let w = 0; w < m.wildsNeeded; w++) mc.push(wilds[0]);
      return mc;
    }),
    deadwood,
    deadScore: bestDeadScore
  };
}

// Check if player can go out: all cards except 1 form valid melds
function canGoOut(hand, wildRank) {
  if (hand.length < 4) return { canGo: false }; // Need at least 3 in a meld + 1 discard
  
  // Try discarding highest-value non-wild cards first (more likely to succeed)
  const indices = hand.map((c, i) => i);
  indices.sort((a, b) => {
    const aW = isWild(hand[a], wildRank) ? -1000 : 0;
    const bW = isWild(hand[b], wildRank) ? -1000 : 0;
    return (bW + cardScore(hand[b], wildRank)) - (aW + cardScore(hand[a], wildRank));
  });
  
  for (const d of indices) {
    const remaining = hand.filter((_, i) => i !== d);
    const result = findBestMelds(remaining, wildRank);
    if (result.deadScore === 0) {
      return { canGo: true, discardIdx: d, melds: result.melds };
    }
  }
  return { canGo: false };
}

// Score a hand after round ends (find best melds, score remaining)
function scoreHand(hand, wildRank) {
  if (hand.length === 0) return { score: 0, melds: [], deadwood: [] };
  const result = findBestMelds(hand, wildRank);
  return {
    score: result.deadScore,
    melds: result.melds,
    deadwood: result.deadwood
  };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME STATE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let G = {};

function initGame(numPlayers) {
  const players = [];
  for (let i = 0; i < numPlayers; i++) {
    players.push({
      name: i === 0 ? 'You' : AI_NAMES[i - 1],
      isHuman: i === 0,
      hand: [],
      totalScore: 0,
      roundScores: [],
      wentOut: false,
    });
  }
  
  G = {
    players,
    drawPile: [],
    discardPile: [],
    currentPlayer: 0,
    round: 1, // 1-11
    phase: 'draw', // draw | play | roundEnd | gameOver
    hasDrawn: false,
    someoneWentOut: false,
    whoWentOut: -1,
    lastChanceTurns: 0,
    dealerIdx: 0,
  };
  
  startRound();
}

function getWildRank() {
  return G.round + 2; // Round 1 â†’ 3s wild, Round 11 â†’ 13s (K) wild
}

function getCardsDealt() {
  return G.round + 2; // Round 1 â†’ 3 cards, Round 11 â†’ 13 cards
}

function startRound() {
  const deck = shuffle(makeDeck());
  const numCards = getCardsDealt();
  
  for (const p of G.players) {
    p.hand = [];
    p.wentOut = false;
  }
  
  // Deal cards
  for (let c = 0; c < numCards; c++) {
    for (const p of G.players) {
      p.hand.push(deck.pop());
    }
  }
  
  // Sort human hand
  sortHand(G.players[0]);
  
  G.drawPile = deck;
  G.discardPile = [deck.pop()]; // Flip one for discard
  G.hasDrawn = false;
  G.someoneWentOut = false;
  G.whoWentOut = -1;
  G.lastChanceTurns = 0;
  G.phase = 'draw';
  
  // First player is left of dealer
  G.currentPlayer = (G.dealerIdx + 1) % G.players.length;
  
  render();
  
  if (!G.players[G.currentPlayer].isHuman) {
    delay(600).then(() => aiTurn());
  }
}

function sortHand(player) {
  const wr = getWildRank();
  player.hand.sort((a, b) => {
    // Wilds last
    const aW = isWild(a, wr) ? 100 : 0;
    const bW = isWild(b, wr) ? 100 : 0;
    if (aW !== bW) return aW - bW;
    // By suit
    const si = SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
    if (si !== 0) return si;
    // By rank
    return a.rank - b.rank;
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AI LOGIC
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function aiTurn() {
  if (G.phase === 'roundEnd' || G.phase === 'gameOver') return;
  const player = G.players[G.currentPlayer];
  const wr = getWildRank();
  
  // Draw phase
  const topDiscard = G.discardPile.length > 0 ? G.discardPile[G.discardPile.length - 1] : null;
  let drewFromDiscard = false;
  
  // Always take wild cards from discard
  if (topDiscard && isWild(topDiscard, wr)) {
    player.hand.push(G.discardPile.pop());
    drewFromDiscard = true;
  }
  
  if (!drewFromDiscard && topDiscard) {
    // Check if discard card helps melds
    const handWith = [...player.hand, topDiscard];
    const scoreWith = scoreHand(handWith, wr).score;
    const scoreCurrent = scoreHand(player.hand, wr).score;
    // Take if it reduces deadwood (accounting for the extra card)
    if (scoreWith < scoreCurrent + cardScore(topDiscard, wr) * 0.3) {
      player.hand.push(G.discardPile.pop());
      drewFromDiscard = true;
    }
  }
  
  if (!drewFromDiscard) {
    if (G.drawPile.length === 0) reshuffleDiscard();
    if (G.drawPile.length > 0) {
      player.hand.push(G.drawPile.pop());
    } else {
      // No cards anywhere â€” force end round
      endRound();
      return;
    }
  }
  
  G.hasDrawn = true;
  render();
  await delay(400);
  
  // Check if can go out (only if nobody went out yet)
  if (!G.someoneWentOut) {
    const goOutCheck = canGoOut(player.hand, wr);
    if (goOutCheck.canGo) {
      const discardCard = player.hand[goOutCheck.discardIdx];
      player.hand.splice(goOutCheck.discardIdx, 1);
      G.discardPile.push(discardCard);
      player.wentOut = true;
      G.someoneWentOut = true;
      G.whoWentOut = G.currentPlayer;
      G.lastChanceTurns = 0;
      showToast(`${player.name} goes out! ğŸ‘‘`);
      G.hasDrawn = false;
      render();
      await delay(600);
      advanceTurn();
      return;
    }
  }
  
  // Discard worst card
  const discardIdx = findBestDiscard(player.hand, wr);
  const discardCard = player.hand[discardIdx];
  player.hand.splice(discardIdx, 1);
  G.discardPile.push(discardCard);
  G.hasDrawn = false;
  
  render();
  await delay(300);
  advanceTurn();
}

function findBestDiscard(hand, wildRank) {
  let bestIdx = 0;
  let bestScore = Infinity;
  
  // Try non-wild cards first (prefer discarding those)
  const nonWildIndices = hand.map((c, i) => i).filter(i => !isWild(hand[i], wildRank));
  const tryIndices = nonWildIndices.length > 0 ? nonWildIndices : hand.map((_, i) => i);
  
  for (const i of tryIndices) {
    const remaining = hand.filter((_, j) => j !== i);
    const result = scoreHand(remaining, wildRank);
    if (result.score < bestScore) {
      bestScore = result.score;
      bestIdx = i;
    }
  }
  return bestIdx;
}

function reshuffleDiscard() {
  if (G.discardPile.length <= 1) return;
  const top = G.discardPile.pop();
  G.drawPile = shuffle(G.discardPile);
  G.discardPile = [top];
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TURN MANAGEMENT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function advanceTurn() {
  // Move to next player first
  G.currentPlayer = (G.currentPlayer + 1) % G.players.length;
  // Skip player who went out
  if (G.players[G.currentPlayer].wentOut) {
    G.currentPlayer = (G.currentPlayer + 1) % G.players.length;
  }
  
  if (G.someoneWentOut) {
    G.lastChanceTurns++;
    // All other players have had their last turn
    if (G.lastChanceTurns > G.players.length - 1) {
      endRound();
      return;
    }
  }
  
  G.hasDrawn = false;
  G.phase = 'draw';
  render();
  
  if (!G.players[G.currentPlayer].isHuman) {
    delay(500).then(() => aiTurn());
  }
}

function endRound() {
  G.phase = 'roundEnd';
  const wr = getWildRank();
  
  // Score each player
  for (const p of G.players) {
    if (p.wentOut) {
      p.roundScores.push(0);
    } else {
      const result = scoreHand(p.hand, wr);
      p.roundScores.push(result.score);
      p.totalScore += result.score;
    }
  }
  
  showRoundResults();
}

function showRoundResults() {
  const wr = getWildRank();
  const modal = document.getElementById('round-modal');
  const content = document.getElementById('round-results');
  
  let html = `<button class="modal-close" onclick="closeRoundModal()">âœ•</button>`;
  html += `<h2>Round ${G.round} Complete</h2>`;
  html += `<p style="color:var(--text-dim);font-size:12px;margin-bottom:12px;">Wild: ${RANK_DISPLAY[wr] || wr}s &nbsp;Â·&nbsp; ${getCardsDealt()} cards</p>`;
  
  html += `<table class="score-table"><thead><tr><th>Player</th><th>Round</th><th>Total</th></tr></thead><tbody>`;
  
  // Sort display by total score
  const sorted = [...G.players].sort((a,b) => a.totalScore - b.totalScore);
  for (const p of sorted) {
    const roundScore = p.roundScores[p.roundScores.length - 1];
    const isPlayer = p.isHuman;
    const wentOut = p.wentOut;
    html += `<tr class="${isPlayer ? 'player-row' : ''}">
      <td>${p.name} ${wentOut ? 'ğŸ‘‘' : ''}</td>
      <td class="${wentOut ? 'went-out-cell' : ''}">${wentOut ? 'Out!' : roundScore}</td>
      <td class="total-col">${p.totalScore}</td>
    </tr>`;
  }
  html += `</tbody></table>`;
  
  if (G.round < 11) {
    html += `<button class="start-btn" style="margin-top:16px;font-size:13px;padding:12px 36px;" onclick="closeRoundModal(); nextRound();">Next Round</button>`;
  } else {
    html += `<button class="start-btn" style="margin-top:16px;font-size:13px;padding:12px 36px;" onclick="closeRoundModal(); showFinalResults();">Final Scores</button>`;
  }
  
  content.innerHTML = html;
  modal.classList.add('show');
}

function closeRoundModal() {
  document.getElementById('round-modal').classList.remove('show');
}

function nextRound() {
  G.round++;
  G.dealerIdx = (G.dealerIdx + 1) % G.players.length;
  startRound();
}

function showFinalResults() {
  G.phase = 'gameOver';
  showScreen('gameover-screen');
  
  const sorted = [...G.players].sort((a,b) => a.totalScore - b.totalScore);
  const winner = sorted[0];
  
  const titleEl = document.getElementById('go-title');
  const winnerEl = document.getElementById('go-winner');
  const subEl = document.getElementById('go-subtitle');
  
  if (winner.isHuman) {
    titleEl.textContent = 'VICTORY!';
    titleEl.style.color = 'var(--gold)';
    winnerEl.textContent = 'You win with the lowest score!';
    subEl.textContent = 'The Five Crowns bow to you.';
  } else {
    titleEl.textContent = 'GAME OVER';
    titleEl.style.color = 'var(--red)';
    winnerEl.textContent = `${winner.name} wins!`;
    subEl.textContent = 'Better luck next time...';
  }
  
  let html = `<table class="score-table"><thead><tr><th>Place</th><th>Player</th><th>Score</th></tr></thead><tbody>`;
  sorted.forEach((p, i) => {
    html += `<tr class="${p.isHuman ? 'player-row' : ''}">
      <td>${i === 0 ? 'ğŸ‘‘' : i + 1}</td>
      <td>${p.name}</td>
      <td class="total-col">${p.totalScore}</td>
    </tr>`;
  });
  html += `</tbody></table>`;
  document.getElementById('final-scores').innerHTML = html;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   HUMAN INTERACTION
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function humanDrawFromDeck() {
  if (G.currentPlayer !== 0 || G.hasDrawn || G.phase !== 'draw') return;
  const player = G.players[0];
  
  if (G.drawPile.length === 0) {
    reshuffleDiscard();
    if (G.drawPile.length === 0) {
      showToast('No cards left!');
      return;
    }
  }
  
  player.hand.push(G.drawPile.pop());
  G.hasDrawn = true;
  G.phase = 'play';
  render();
}

function humanDrawFromDiscard() {
  if (G.currentPlayer !== 0 || G.hasDrawn || G.phase !== 'draw') return;
  if (G.discardPile.length === 0) { showToast('Discard pile is empty!'); return; }
  
  const player = G.players[0];
  player.hand.push(G.discardPile.pop());
  G.hasDrawn = true;
  G.phase = 'play';
  render();
}

function humanSelectCard(index) {
  if (G.currentPlayer !== 0 || !G.hasDrawn) return;
  
  const player = G.players[0];
  if (player.hand[index]._selected) {
    player.hand[index]._selected = false;
  } else {
    // Clear other selections
    player.hand.forEach(c => c._selected = false);
    player.hand[index]._selected = true;
  }
  render();
}

function humanDiscard() {
  if (G.currentPlayer !== 0 || !G.hasDrawn) return;
  const player = G.players[0];
  const selIdx = player.hand.findIndex(c => c._selected);
  if (selIdx < 0) { showToast('Select a card to discard'); return; }
  
  const card = player.hand.splice(selIdx, 1)[0];
  delete card._selected;
  G.discardPile.push(card);
  G.hasDrawn = false;
  G.phase = 'draw';
  
  render();
  advanceTurn();
}

function humanGoOut() {
  if (G.currentPlayer !== 0 || !G.hasDrawn) return;
  if (G.someoneWentOut) { showToast("Someone already went out â€” just discard!"); return; }
  
  const player = G.players[0];
  const wr = getWildRank();
  const check = canGoOut(player.hand, wr);
  
  if (!check.canGo) {
    showToast("Can't go out â€” not all cards form melds!");
    return;
  }
  
  // Discard the suggested card
  const discardCard = player.hand[check.discardIdx];
  player.hand.splice(check.discardIdx, 1);
  delete discardCard._selected;
  G.discardPile.push(discardCard);
  
  player.wentOut = true;
  G.someoneWentOut = true;
  G.whoWentOut = 0;
  G.lastChanceTurns = 0;
  G.hasDrawn = false;
  
  showToast("You went out! ğŸ‘‘ Others get one last turn.");
  render();
  delay(600).then(() => advanceTurn());
}

function humanSort() {
  sortHand(G.players[0]);
  render();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDERING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function cardHTML(card, opts = {}) {
  const { selectable = false, selected = false, clickData = '', small = false } = opts;
  const wr = getWildRank();
  const wild = isWild(card, wr);
  const joker = card.rank === 0;
  const suitClass = joker ? '' : `suit-${SUIT_NAMES[card.suit] || 'stars'}`;
  const wildClass = wild && !joker ? ' is-wild' : '';
  const jokerClass = joker ? ' is-joker' : '';
  const selClass = selected ? ' selected' : (selectable ? ' selectable' : '');
  const dr = displayRank(card);
  const ds = displaySuit(card);
  
  return `<div class="card card-face ${suitClass}${wildClass}${jokerClass}${selClass}" ${clickData}>
    <span class="card-corner tl"><span>${dr}</span><span>${ds}</span></span>
    <span class="card-rank">${dr}</span>
    <span class="card-suit">${ds}</span>
    <span class="card-corner br"><span>${dr}</span><span>${ds}</span></span>
  </div>`;
}

function render() {
  renderRoundBar();
  renderOpponents();
  renderCenter();
  renderPlayer();
  renderActions();
  renderStatus();
  renderGameInfo();
}

function renderRoundBar() {
  const bar = document.getElementById('round-bar');
  const wr = getWildRank();
  const wildDisplay = RANK_DISPLAY[wr] || wr;
  bar.innerHTML = `
    <span class="round-label">Round ${G.round} of 11</span>
    <span class="wild-label">Wild: <span>${wildDisplay}s + Jokers</span></span>
    <span style="font-size:10px;color:var(--text-dim);">${getCardsDealt()} cards</span>
  `;
}

function renderGameInfo() {
  const el = document.getElementById('game-info');
  el.textContent = `Draw: ${G.drawPile.length}`;
}

function renderOpponents() {
  const row = document.getElementById('opponents-row');
  let html = '';
  for (let i = 1; i < G.players.length; i++) {
    const p = G.players[i];
    const isActive = G.currentPlayer === i && G.phase !== 'roundEnd';
    const wentOut = p.wentOut;
    html += `<div class="opponent-zone ${isActive ? 'is-turn' : ''} ${wentOut ? 'went-out' : ''}">
      <div class="opponent-name ${isActive ? 'active-turn' : ''}">${p.name} ${wentOut ? 'ğŸ‘‘' : ''} <span class="hand-count">${p.hand.length}</span></div>
      <div class="opp-cards">`;
    const showCards = Math.min(p.hand.length, 8);
    for (let j = 0; j < showCards; j++) {
      html += `<div class="card card-back"></div>`;
    }
    if (p.hand.length > 8) html += `<span style="font-size:9px;color:var(--text-dim);">+${p.hand.length - 8}</span>`;
    html += `</div>
      <div class="opp-score">Score: ${p.totalScore}</div>
    </div>`;
  }
  row.innerHTML = html;
}

function renderCenter() {
  const drawEl = document.getElementById('draw-pile');
  const drawCountEl = document.getElementById('draw-count');
  const canDraw = G.currentPlayer === 0 && !G.hasDrawn && G.phase === 'draw';
  
  if (G.drawPile.length > 0) {
    drawEl.className = `pile-cards ${canDraw ? 'clickable' : ''}`;
    drawEl.innerHTML = `<div class="card card-back"></div>`;
    drawCountEl.textContent = G.drawPile.length;
  } else {
    drawEl.className = 'pile-cards';
    drawEl.innerHTML = `<div class="pile-placeholder">Empty</div>`;
    drawCountEl.textContent = '';
  }
  
  const discEl = document.getElementById('discard-pile');
  const discCountEl = document.getElementById('discard-count');
  const top = G.discardPile.length > 0 ? G.discardPile[G.discardPile.length - 1] : null;
  const canDrawDiscard = canDraw && top;
  
  if (top) {
    discEl.className = `pile-cards ${canDrawDiscard ? 'clickable' : ''}`;
    let html = '';
    const showCount = Math.min(G.discardPile.length, 3);
    for (let i = G.discardPile.length - showCount; i < G.discardPile.length; i++) {
      const offset = (i - (G.discardPile.length - showCount)) * 2;
      const c = G.discardPile[i];
      const wr = getWildRank();
      const wild = isWild(c, wr);
      const joker = c.rank === 0;
      const suitClass = joker ? '' : `suit-${SUIT_NAMES[c.suit] || 'stars'}`;
      const wildClass = wild && !joker ? ' is-wild' : '';
      const jokerClass = joker ? ' is-joker' : '';
      const dr = displayRank(c);
      const ds = displaySuit(c);
      html += `<div class="card card-face ${suitClass}${wildClass}${jokerClass}" style="top:${offset}px;left:${offset}px;">
        <span class="card-corner tl"><span>${dr}</span><span>${ds}</span></span>
        <span class="card-rank">${dr}</span>
        <span class="card-suit">${ds}</span>
        <span class="card-corner br"><span>${dr}</span><span>${ds}</span></span>
      </div>`;
    }
    discEl.innerHTML = html;
    discCountEl.textContent = G.discardPile.length;
  } else {
    discEl.className = 'pile-cards';
    discEl.innerHTML = `<div class="pile-placeholder">Empty</div>`;
    discCountEl.textContent = '';
  }
}

function renderPlayer() {
  const zone = document.getElementById('player-zone');
  const player = G.players[0];
  const isMyTurn = G.currentPlayer === 0 && G.phase !== 'roundEnd';
  const wr = getWildRank();
  
  let html = '';
  html += `<div class="player-label ${isMyTurn ? 'active-turn' : ''}">${
    player.wentOut ? 'ğŸ‘‘ You went out!' : (isMyTurn ? (G.hasDrawn ? 'â™  Select & Discard' : 'â™  Draw a Card') : 'Waiting...')
  }</div>`;
  
  // Score
  html += `<div class="player-score-bar">Total Score: <span>${player.totalScore}</span></div>`;
  
  // Hand
  html += `<div class="player-hand-section ${G.hasDrawn && canGoOut(player.hand, wr).canGo && !G.someoneWentOut ? 'go-out-ready' : ''}">`;
  html += `<div class="section-label">Your Hand (${player.hand.length})</div>`;
  html += `<div class="player-hand">`;
  
  const canClick = isMyTurn && G.hasDrawn;
  for (let i = 0; i < player.hand.length; i++) {
    const c = player.hand[i];
    html += cardHTML(c, {
      selectable: canClick,
      selected: !!c._selected,
      clickData: canClick ? `onclick="humanSelectCard(${i})"` : '',
    });
  }
  html += `</div></div>`;
  
  zone.innerHTML = html;
}

function renderActions() {
  const bar = document.getElementById('action-bar');
  if (G.phase === 'roundEnd' || G.phase === 'gameOver' || G.currentPlayer !== 0) {
    bar.innerHTML = '';
    return;
  }
  
  const player = G.players[0];
  const wr = getWildRank();
  const hasSel = player.hand.some(c => c._selected);
  
  if (G.hasDrawn) {
    const goCheck = canGoOut(player.hand, wr);
    let html = `<button class="action-btn btn-sort" onclick="humanSort()">Sort</button>`;
    if (goCheck.canGo && !G.someoneWentOut) {
      html += `<button class="action-btn btn-go-out" onclick="humanGoOut()">Go Out!</button>`;
    }
    html += `<button class="action-btn btn-discard" ${hasSel ? '' : 'disabled'} onclick="humanDiscard()">Discard</button>`;
    bar.innerHTML = html;
  } else {
    bar.innerHTML = `<span style="font-size:11px;color:var(--text-dim);letter-spacing:1px;">Tap the Draw or Discard pile</span>`;
  }
}

function renderStatus() {
  const bar = document.getElementById('status-bar');
  if (G.phase === 'roundEnd') {
    bar.textContent = '';
    return;
  }
  const cp = G.players[G.currentPlayer];
  if (G.someoneWentOut) {
    const who = G.players[G.whoWentOut];
    if (cp.isHuman) {
      bar.textContent = `${who.name === 'You' ? 'You' : who.name} went out! This is your last turn â€” meld what you can!`;
    } else {
      bar.textContent = `${who.name} went out! ${cp.name} takes their last turn...`;
    }
    return;
  }
  if (cp.isHuman) {
    bar.textContent = G.hasDrawn ? 'Select a card to discard, or go out if you can' : 'Draw from the deck or discard pile';
  } else {
    bar.textContent = `${cp.name} is thinking...`;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOAST & UTILITY
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let toastTimer = null;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.classList.remove('show'), 2400);
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SCREEN & MODAL MANAGEMENT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function showRules() {
  document.getElementById('rules-modal').classList.add('show');
}
function hideRules() {
  document.getElementById('rules-modal').classList.remove('show');
}
document.getElementById('rules-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) hideRules();
});

function confirmQuit() {
  if (confirm('Quit the current game?')) {
    showScreen('title-screen');
  }
}

function startGame() {
  const count = parseInt(document.querySelector('#player-select .option-btn.sel').dataset.count);
  initGame(count);
  showScreen('game-screen');
  render();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   OPTION SELECT BUTTONS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.querySelectorAll('#player-select .option-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#player-select .option-btn').forEach(b => b.classList.remove('sel'));
    btn.classList.add('sel');
  });
});
</script>
</body>
</html>
